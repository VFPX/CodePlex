SCCTEXT Version 4.0.0.2
PLATFORM C(8,0),UNIQUEID C(10,0),TIMESTAMP N(10,0),CLASS M(4,0),CLASSLOC M(4,0),BASECLASS M(4,0),OBJNAME M(4,0),PARENT M(4,0),PROPERTIES M(4,0),PROTECTED M(4,0),METHODS M(4,0),OBJCODE M(4,0),OLE M(4,0),OLE2 M(4,0),RESERVED1 M(4,0),RESERVED2 M(4,0),RESERVED3 M(4,0),RESERVED4 M(4,0),RESERVED5 M(4,0),RESERVED6 M(4,0),RESERVED7 M(4,0),RESERVED8 M(4,0),USER M(4,0)
1252

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] Class     
[START RESERVED1]
VERSION =   3.00[END RESERVED1]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _13T0MHHPZ
[CLASS] reportlistener
[BASECLASS] reportlistener
[OBJNAME] _reportlistener
[START PROPERTIES]
</VFPData>
<memberdata name="adjustreportpagesinfo" display="adjustReportPagesInfo" type="method"/>
<memberdata name="isfrxswapcopypresent" display="isFRXSwapCopyPresent" type="method"/>
AllowModalMessages = (INLIST(_VFP.Startmode, 0, 4))
FRXDataSession = -1
Height = 23
Name = "_reportlistener"
QuietMode = (NOT INLIST(_VFP.Startmode, 0, 4))
Width = 23
_memberdata =     5188<VFPData><memberdata name="addreport" type="method" display="addReport" favorites="True" /><memberdata name="appname" type="property" display="appName" favorites="True" /><memberdata name="clearerrors" type="method" display="clearErrors" favorites="True" /><memberdata name="drivingalias" type="property" display="drivingAlias" favorites="False" /><memberdata name="getfrxstartupinfo" type="method" display="getFRXStartupInfo" favorites="False" /><memberdata name="getlasterrormessage" type="method" display="getLastErrorMessage" favorites="True" /><memberdata name="haderror" type="property" display="hadError" favorites="False" /><memberdata name="invokeoncurrentpass" type="method" display="invokeOnCurrentPass" favorites="True" /><memberdata name="isrunning" type="property" display="isRunning" favorites="False" /><memberdata name="isrunningreports" type="property" display="isRunningReports" favorites="False" /><memberdata name="issuccessor" type="property" display="isSuccessor" favorites="True" /><memberdata name="lasterrormessage" type="property" display="lastErrorMessage" favorites="False" /><memberdata name="lignoreerrors" type="property" display="lIgnoreErrors" favorites="False" /><memberdata name="listeners" type="property" display="listeners" favorites="False" /><memberdata name="popglobalsets" type="method" display="popGlobalSets" favorites="False" /><memberdata name="prepareerrormessage" type="method" display="prepareErrorMessage" favorites="True" /><memberdata name="pushglobalsets" type="method" display="pushGlobalSets" favorites="False" /><memberdata name="removereports" type="method" display="removeReports" favorites="True" /><memberdata name="reportclauses" type="property" display="reportClauses" favorites="False" /><memberdata name="reportfilenames" type="property" display="reportFilenames" favorites="False" /><memberdata name="reportpages" type="property" display="reportPages" favorites="False" /><memberdata name="reportusesprivatedatasession" type="property" display="reportUsesPrivateDataSession" favorites="True" /><memberdata name="resetdatasession" type="method" display="resetDataSession" favorites="False" /><memberdata name="runreports" type="method" display="runReports" favorites="True" /><memberdata name="setcurrentdatasession" type="method" display="setCurrentDataSession" favorites="False" /><memberdata name="setfrxdatasession" type="method" display="setFRXDataSession" favorites="False" /><memberdata name="setfrxdatasessionenvironment" type="method" display="setFRXDataSessionEnvironment" favorites="False" /><memberdata name="setsuccessordynamicproperties" type="method" display="setSuccessorDynamicProperties" favorites="True" /><memberdata name="sharedgdiplusgraphics" type="property" display="sharedGdiplusGraphics" favorites="True" /><memberdata name="sharedpagetotal" type="property" display="sharedPageTotal" favorites="True" /><memberdata name="sharedoutputpagecount" type="property" display="sharedOutputPageCount" favorites="True" /><memberdata name="sharedpageno" type="property" display="sharedPageNo" favorites="True" /><memberdata name="sharedpageheight" type="property" display="sharedPageHeight" favorites="True" /><memberdata name="sharedpagewidth" type="property" display="sharedPageWidth" favorites="True" /><memberdata name="listenerdatasession" type="property" display="listenerDataSession" favorites="False" /><memberdata name="successor" type="property" display="successor" favorites="True" /><memberdata name="setfrxrunstartupconditions" type="method" display="setFRXRunStartupConditions"/><memberdata name="pagelimit" type="property" display="pageLimit" favorites="True" /><memberdata name="pagetoplimit" type="property" display="pageTopLimit" favorites="True" /><memberdata name="pagetaillimit" type="property" display="pageTailLimit" favorites="True" /><memberdata name="pagelimitquietmode" type="property" display="pageLimitQuietMode" favorites="True" /><memberdata name="pagelimitinsiderange" type="property" display="pageLimitInsideRange" favorites="True" /><memberdata name="resetdynamicmethodcalls" type="method" display="resetDynamicMethodCalls"/><memberdata name="resetcallevaluatecontents" type="method" display="resetCallEvaluateContents"/><memberdata name="resetcalladjustobjectsize" type="method" display="resetCallAdjustObjectSize"/><memberdata name="runcollector" display="runCollector" type="property" favorites="True"/><memberdata name="resetruncollector" display="resetRunCollector" type="method"/><memberdata name="fillruncollector" display="fillRunCollector" type="method"/><memberdata name="frxheaderrecno" display="frxHeaderRecno" type="property"/><memberdata name="sharedlistenertype" display="sharedListenerType" type="property"/><memberdata name="commandclausesfile" display="commandClausesFile" type="property" favorites="True"/><memberdata name="preparefrxswapcopy" display="prepareFRXSwapCopy" type="method"/><memberdata name="removefrxswapcopy" display="removeFRXSwapCopy" type="method"/>
appname = ("VFP Report Listener")
commandclausesfile = .NULL.
drivingalias = ("")
frxheaderrecno = 1
lasterrormessage = ("")
listenerdatasession = 1
listeners = (NULL)
pagelimit = -1
pagelimitinsiderange = .F.
pagelimitquietmode = .F.
pagetaillimit = -1
pagetoplimit = -1
reportclauses = (NULL)
reportfilenames = (NULL)
runcollector = (NULL)
sharedgdiplusgraphics = 0
sharedlistenertype = -1
sharedoutputpagecount = 0
sharedpageheight = 0
sharedpageno = 0
sharedpagetotal = 0
sharedpagewidth = 0
successor = (NULL)
[END PROPERTIES]
[START PROTECTED]
adjustreportpagesinfo
drivingalias
fillruncollector
frxheaderrecno
getfrxstartupinfo
haderror
isrunning
isrunningreports
lasterrormessage
listeners
popglobalsets
pushglobalsets
reportclauses
reportfilenames
resetcalladjustobjectsize
resetcallevaluatecontents
resetdatasession
resetdynamicmethodcalls
resetruncollector
runcollector
setcurrentdatasession
setfrxdatasession
setfrxdatasessionenvironment
setfrxrunstartupconditions
[END PROTECTED]
[START METHODS]
PROCEDURE AfterBand
LPARAMETERS m.nBandObjCode, m.nFRXRecno
IF NOT ISNULL(THIS.Successor)
   THIS.SetSuccessorDynamicProperties()
   THIS.Successor.AfterBand(m.nBandObjCode, m.nFRXRecNo)
ENDIF

ENDPROC
PROCEDURE AfterReport
IF NOT THIS.IsSuccessor
   THIS.SharedPageWidth = THIS.GetPageWidth()
   THIS.SharedPageHeight = THIS.GetPageHeight()
ENDIF

IF NOT ISNULL(THIS.Successor)
   WITH THIS.Successor
      .FRXDataSession = THIS.FRXDataSession
      .CurrentDataSession = THIS.CurrentDataSession
      .TwoPassProcess = THIS.TwoPassProcess
      .CommandClauses = THIS.CommandClauses
      .SharedPageHeight = THIS.SharedPageHeight
      .SharedPageWidth = THIS.SharedPageWidth
      THIS.SetSuccessorDynamicProperties()
      .AfterReport()
      .ResetToDefault("FRXDataSession")
      .ResetToDefault("CurrentDataSession")
      
   ENDWITH
ENDIF
IF NOT THIS.IsSuccessor
   NODEFAULT
   DODEFAULT()
ENDIF   


ENDPROC
PROCEDURE BeforeBand
LPARAMETERS m.nBandObjCode, m.nFRXRecNo

IF NOT ISNULL(THIS.Successor)
   THIS.SetSuccessorDynamicProperties()
   THIS.Successor.BeforeBand(m.nBandObjCode, m.nFRXRecNo)
ENDIF

THIS.resetDataSession() 

ENDPROC
PROCEDURE BeforeReport
THIS.setFRXRunStartupConditions()

THIS.getFRXStartupInfo()

THIS.resetDataSession()

IF NOT THIS.IsSuccessor
   THIS.sharedPageHeight = THIS.GetPageHeight()
   THIS.sharedPageWidth = THIS.GetPageWidth()
   THIS.sharedListenerType = THIS.ListenerType
   THIS.ResetToDefault("sharedPageNo")
   THIS.ResetToDefault("sharedPageTotal")
   THIS.ResetToDefault("sharedOutputPageCount")
   THIS.ResetToDefault("sharedGDIPlusGraphics")
ENDIF

IF NOT ISNULL(THIS.Successor)
   WITH THIS.Successor
      .AddProperty("sharedGDIPlusGraphics", THIS.sharedGDIPlusGraphics)      
      .AddProperty("sharedPageHeight", THIS.sharedPageHeight)
      .AddProperty("sharedPageWidth", THIS.sharedPageWidth)      
      .AddProperty("sharedOutputPageCount", THIS.sharedOutputPageCount)
      .AddProperty("sharedPageNo", THIS.sharedPageNo)      
      .AddProperty("sharedPageTotal", THIS.sharedPageTotal) 
      .AddProperty("sharedListenerType",THIS.ListenerType)               
       THIS.setSuccessorDynamicProperties()        
      .FRXDataSession = THIS.FRXDataSession
      .CurrentDataSession = THIS.CurrentDataSession
      .TwoPassProcess = THIS.TwoPassProcess
      .CommandClauses = THIS.CommandClauses
      .commandClausesFile = THIS.commandClausesFile 
      * doing the above line here because some dynamic
      * object may have adjusted it in the Load and we can
      * correct original value here.
      .BeforeReport()
   ENDWITH
ENDIF

*&* Sedna -- we want this *after* successor has run BeforeReport code,
*&* but some Successor.BeforeReport code might
*&* have an affect on Dynamics
THIS.resetDynamicMethodCalls()
*&* .. so we'll re-set those dynamic properties again afterwards
IF NOT ISNULL(THIS.Successor)
   WITH THIS.successor
       IF .CallEvaluateContents < THIS.CallEvaluateContents
          .CallEvaluateContents = THIS.CallEvaluateContents
       ENDIF
       IF .CallAdjustObjectSize < THIS.CallAdjustObjectSize
          .CallAdjustObjectSize = THIS.CallAdjustObjectSize
       ENDIF
   ENDWITH
ENDIF   
ENDPROC
PROCEDURE CancelReport
IF NOT THIS.IsSuccessor
   DODEFAULT()
   NODEFAULT
ENDIF   
IF NOT ISNULL(THIS.Successor)
   THIS.SetSuccessorDynamicProperties()
   THIS.Successor.CancelReport()
ENDIF

ENDPROC
PROCEDURE ClearStatus
DODEFAULT()
IF NOT ISNULL(THIS.Successor)
   THIS.SetSuccessorDynamicProperties()
   THIS.Successor.ClearStatus()
ENDIF   
ENDPROC
PROCEDURE Destroy
STORE NULL TO ;
  THIS.runCollector, ;
  THIS.Successor, ;
  THIS.Listeners, ;
  THIS.ReportClauses, ;
  THIS.ReportFileNames, ;
  THIS.PreviewContainer, ;
  THIS.CommandClauses

ENDPROC
PROCEDURE DoMessage
LPARAMETERS m.cMessage,m.iParams,m.cTitle
NODEFAULT
IF THIS.QuietMode OR ;
  (THIS.IsRunning AND THIS.CommandClauses.NoDialog)
   * to emulate the base class behavior, do both checks,
   * in case the call to DoMessage() occurs
   * before the baseclass sets QuietMode .T. in response
   * to NoDialog at the beginning of the report run,
   * or after the baseclass re-sets Quietmode to .F.
   * at the end of the report run.
   RETURN 0
ELSE
   IF THIS.AllowModalMessages
      IF VARTYPE(m.cTitle) = "C"
         RETURN MESSAGEBOX(TRANS(m.cMessage),VAL(TRANS(m.iParams)),m.cTitle)
      ELSE
         RETURN MESSAGEBOX(TRANS(m.cMessage),VAL(TRANS(m.iParams)),THIS.AppName)
      ENDIF
   ELSE
      THIS.DoStatus(m.cMessage)
      RETURN 0
   ENDIF
ENDIF   
ENDPROC
PROCEDURE DoStatus
LPARAMETERS m.cMessage
NODEFAULT
IF NOT (THIS.QuietMode OR (THIS.IsRunning AND THIS.CommandClauses.Nodialog))
   IF THIS.TwoPassProcess AND THIS.CurrentPass = 0
      WAIT WINDOW NOWAIT OUTPUTCLASS_PREPSTATUS_LOC 
   ELSE
      IF VARTYPE(m.cMessage) = "C"
         DODEFAULT(m.cMessage)      
      ENDIF
   ENDIF
ENDIF
ENDPROC
PROCEDURE Error
LPARAMETERS m.nError, m.cMethod, m.nLine
LOCAL m.lcOnError,m.lcErrorMsg,m.lcCodeLineMsg
THIS.HadError = .T.
IF this.lIgnoreErrors OR _vfp.StartMode>0
	RETURN .F.
ENDIF
m.lcOnError=UPPER(ALLTRIM(ON("ERROR")))
IF NOT EMPTY(m.lcOnError)
	m.lcOnError=STRTRAN(STRTRAN(STRTRAN(lcOnError,"ERROR()","nError"), ;
			"PROGRAM()","cMethod"),"LINENO()","nLine")
	&lcOnError
	RETURN
ENDIF
m.lcErrorMsg = THIS.PrepareErrorMessage(m.nError,m.cMethod, m.nLine)
THIS.LastErrorMessage = m.lcErrorMsg

THIS.DoMessage(m.lcErrorMsg, MB_ICONSTOP )

#IF OUTPUTCLASS_DEBUGGING
    ERROR m.nError
#ENDIF    
ENDPROC
PROCEDURE IncludePageInOutput
LPARAMETERS m.nPageNo
LOCAL m.llInclude
IF (NOT THIS.isSuccessor) AND ;
   (THIS.PageLimit > 0) AND ;
   (THIS.PageNo > THIS.PageLimit)
   * note that nPageNo and the 
   * current CommandClauses.RangeFrom and RangeTo values
   * only refer to the current report, which
   * is potentially one of a series using NOPAGEEJECT.
   * THIS.PageNo refers to the overall number of pages that
   * have been run, across the multiple reports.
   IF NOT THIS.pageLimitQuietMode 
      THIS.DoMessage(OUTPUTCLASS_PAGELIMIT_LOC , MB_ICONEXCLAMATION)
   ENDIF      
   THIS.LastErrorMessage = OUTPUTCLASS_PAGELIMIT_LOC
   THIS.CancelReport()
ELSE
   DO CASE
   CASE (THIS.isSuccessor) 
      * do not try to limit run unless
      * communicating with native engine
      m.llInclude = .T.
   CASE (THIS.PageTopLimit = -1) AND ;
        (THIS.PageTailLimit = -1)
      * no limits set        
      m.llInclude = .T.      
   CASE THIS.PageTopLimit = -1
     * only bottom end requested
      IF THIS.PageLimitInsideRange 
         m.llInclude = (THIS.PageNo <= THIS.PageTailLimit)      
      ELSE
         m.llInclude = (THIS.PageNo >= THIS.PageTailLimit)
      ENDIF         
   CASE THIS.PageTailLimit = -1
     * only top end requested
      IF THIS.PageLimitInsideRange 
         m.llInclude = (THIS.PageNo >= THIS.PageTopLimit)      
      ELSE
         m.llInclude = (THIS.PageNo <= THIS.PageTopLimit)
      ENDIF         
   OTHERWISE
      * both top and tail requested
      IF THIS.PageLimitInsideRange
         m.llInclude = BETWEEN(THIS.PageNo,THIS.PageTopLimit, THIS.PageTailLimit)
      ELSE
         m.llInclude = ((THIS.PageNo <= THIS.PageTopLimit) OR ;
                        (THIS.PageNo >= THIS.PageTailLimit))
      ENDIF                        
   ENDCASE      
ENDIF          
RETURN (m.llInclude AND DODEFAULT(m.nPageNo))

ENDPROC
PROCEDURE Init
THIS.listenerDataSession = SET("DATASESSION")  

IF DODEFAULT() 
   THIS.AppName = OUTPUTCLASS_APPNAME_LOC
ELSE
   RETURN .F.
ENDIF      

*&* Sedna
* this may be necessary if you
* modify and compile these classes in a build that
* does have the two native properties
* and then go back to use them with a version
* that does *not* have the native properties
* (it's possible to lose the custom definitions)

IF NOT PEMSTATUS(THIS,"CallEvaluateContents",5)
   THIS.AddProperty("CallEvaluateContents", LISTENER_CALLDYNAMICMETHOD_CHECK_CODE)
ENDIF   

IF NOT PEMSTATUS(THIS,"CallAdjustObjectSize",5)
   THIS.AddProperty("CallAdjustObjectSize", LISTENER_CALLDYNAMICMETHOD_CHECK_CODE)
ENDIF   


RETURN NOT THIS.HadError
ENDPROC
PROCEDURE LoadReport
THIS.clearErrors()

THIS.setFRXDataSessionEnvironment()

THIS.resetDataSession()
THIS.frxHeaderRecno = -1

IF NOT ISNULL(THIS.Successor)
   WITH THIS.Successor
      .AddProperty("isSuccessor",.T.)
      .AddProperty("commandClausesFile",THIS.commandClausesFile )
      .PrintJobName = THIS.PrintJobName 
      .CommandClauses = THIS.CommandClauses
      .LoadReport()
   ENDWITH
ENDIF


   


   
ENDPROC
PROCEDURE Render
LPARAMETERS m.nFRXRecno, m.nLeft, m.nTop, m.nWidth, m.nHeight, ;
            m.nObjectContinuationType, m.cContentsToBeRendered, m.GDIPlusImage
IF NOT ISNULL(THIS.Successor)
   THIS.SetSuccessorDynamicProperties()
   THIS.Successor.Render( m.nFRXRecno, m.nLeft, m.nTop, m.nWidth, m.nHeight, ;
                          m.nObjectContinuationType, m.cContentsToBeRendered, m.GDIPlusImage)
ENDIF


ENDPROC
PROCEDURE UnloadReport

IF NOT THIS.IsSuccessor
   THIS.SharedPageWidth = THIS.GetPageWidth()
   THIS.SharedPageHeight = THIS.GetPageHeight()
ENDIF

THIS.resetDataSession()

IF NOT ISNULL(THIS.Successor)

   WITH THIS.Successor
      .FRXDataSession = THIS.FRXDataSession
      .CurrentDataSession = THIS.CurrentDataSession
      .TwoPassProcess = THIS.TwoPassProcess
      .CommandClauses = THIS.CommandClauses
      .SharedPageHeight = THIS.SharedPageHeight
      .SharedPageWidth = THIS.SharedPageWidth
      THIS.SetSuccessorDynamicProperties()      
      .UnloadReport()
      .IsSuccessor = .F.
   ENDWITH
  
ENDIF

   
ENDPROC
PROCEDURE UpdateStatus
DODEFAULT()
IF NOT ISNULL(THIS.Successor)
   THIS.SetSuccessorDynamicProperties()
   THIS.Successor.UpdateStatus()
ENDIF   
ENDPROC
PROCEDURE addreport
LPARAMETERS m.tcFRXName, m.tcClauses, m.toListener

* can this one be done while report is running?
* Possibly yes because we're always adding to the end.

IF VARTYPE(m.tcFrxName) = "C" AND ;
   (FILE(m.tcFRXName) OR FILE(FORCEEXT(m.tcFRXName,"FRX")) OR FILE(FORCEEXT(m.tcFRXName,"LBX")))

   * If any is null, create all collections
   * always add to all three collections
   * to keep them in synch
   
   IF ISNULL(THIS.ReportFileNames) OR ;
      ISNULL(THIS.ReportClauses) OR ;
      ISNULL(THIS.Listeners) 
      * start fresh
      * this *shouldn't* be a datasession problem
      * unless they're doing it from inside a form,
      * but JIC:
      LOCAL liSession
      m.liSession = SET("DATASESSION")
      THIS.resetDataSession()
      THIS.ReportFileNames = CREATEOBJECT("Collection")
      THIS.ReportClauses = CREATEOBJECT("Collection")
      THIS.Listeners = CREATEOBJECT("Collection")
      DIME THIS.ReportPages[1]
      SET DATASESSION TO (m.liSession)
   ENDIF
   
   THIS.ReportFileNames.Add(m.tcFRXName)
   
   DIME THIS.ReportPages[THIS.ReportFileNames.Count]
   THIS.ReportPages[THIS.ReportFileNames.Count] = 0

   IF VARTYPE(m.tcClauses) = "C"
      THIS.ReportClauses.Add(m.tcClauses)
   ELSE
      THIS.ReportClauses.Add("")   
   ENDIF

   IF TYPE("toListener.BaseClass") = "C" AND ;
      UPPER(toListener.BaseClass) == "REPORTLISTENER"
      THIS.Listeners.Add(toListener)
   ELSE
      THIS.Listeners.Add(NULL)      
   ENDIF
   
ELSE

   * TBD: should we error here?   
   
ENDIF   


ENDPROC
PROCEDURE adjustreportpagesinfo
LPARAMETERS m.tiReportIndex, m.tcClauses, m.toListener

   * this is a *sketch*.  There are lots of different ways you
   * could decide you wanted this to work.
   * Subclasses can make this a multi-column array with 
   * output pages (responsive to RANGE clause)
   * represented as well, decide when to accumulate and when not, 
   * or whether to set up a separate array col for 
   * curr page versus total page,
   * when to use listener ref data versus _PAGENO when a 
   * listener ref is available,
   * and if so how to deal with NORESET,
   * when to use the shared/writable versions of FFC's SharedPageNo 
   * and SharedPageTotal versus the readonly product versions, 
   * because they are more similar to _PAGENO and _PAGETOTAL,
   * whether page limits (top and tail) are significant, etc, etc, etc, etc.
   
IF m.tiReportIndex = 1 
   * adjust the columns however you want to use them...
   * in our version:
   IF ALEN(THIS.reportPages,2) < 2
      DIME THIS.reportPages(THIS.ReportFileNames.Count,2)
   ENDIF
   
ENDIF   
IF THIS.ReportFileNames.Count >= m.tiReportIndex
   IF ISNULL(m.toListener) 
      THIS.reportPages[m.tiReportIndex,1] = _PAGENO
   ELSE    
      THIS.reportPages[m.tiReportIndex,1] = m.toListener.PageNo 
   ENDIF
   IF m.tiReportIndex = 1
      THIS.reportPages[m.tiReportIndex,2] = THIS.reportPages[m.tiReportIndex,1]
   ELSE
      THIS.reportPages[m.tiReportIndex,2] = ;
         THIS.reportPages[m.tiReportIndex,1] + ;
         THIS.reportPages[m.tiReportIndex-1,2]
   ENDIF
ENDIF
ENDPROC
PROCEDURE allowmodalmessages_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "L"
   THIS.AllowModalMessages = m.vNewVal
ENDIF   


ENDPROC
PROCEDURE appname_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "C"
   THIS.appname = m.vNewVal
ENDIF   

ENDPROC
PROCEDURE clearerrors
THIS.HadError = .F.
THIS.LastErrorMessage = ""
ENDPROC
PROCEDURE commandclausesfile_assign
LPARAMETERS m.tvNewVal
IF VARTYPE(m.tvNewVal) = "C" AND ;
   FILE(m.tvNewVal) && not SYS(2000), could be built into an app
   THIS.commandClausesFile = m.tvNewVal
ELSE
   THIS.commandClausesFile = NULL   
ENDIF   

ENDPROC
PROCEDURE getfrxstartupinfo
THIS.SetFRXDataSession()
IF USED("FRX")
   SELECT FRX
   LOCATE FOR ObjType = FRX_OBJTYP_DATAENV AND ;
              Platform = FRX_PLATFORM_WINDOWS AND ;
              NOT DELETED()
   THIS.ReportUsesPrivateDataSession = Frx.Environ
   * could also use 
   * THIS.CommandClauses.StartDataSession # THIS.CurrentDataSession
   LOCATE FOR ObjType = FRX_OBJTYP_REPORTHEADER AND ;
                        Platform = FRX_PLATFORM_WINDOWS AND ;
                        NOT DELETED()
   THIS.frxHeaderRecno = RECNO("FRX")
ELSE
   THIS.ReportUsesPrivateDataSession = .F.   
   THIS.frxHeaderRecno = -1
ENDIF   
THIS.SetCurrentDataSession()
IF THIS.reportUsesPrivateDataSession
   SET TALK OFF
ENDIF
THIS.DrivingAlias = UPPER(ALIAS())
ENDPROC
PROCEDURE getlasterrormessage
RETURN STRTRAN(THIS.LastErrorMessage, CHR(13), " ")
ENDPROC
PROCEDURE invokeoncurrentpass
RETURN .T.
ENDPROC
PROCEDURE isfrxswapcopypresent
RETURN (NOT ISNULL(THIS.commandClausesFile)) AND ;
       (NOT EMPTY(THIS.commandClausesFile)) AND ;
       (TYPE("THIS.commandClauses.File") = "C") AND ;
       (NOT UPPER(THIS.commandClausesFile) == UPPER(THIS.CommandClauses.File))

ENDPROC
PROCEDURE issuccessor_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "L"
   THIS.isSuccessor = m.vNewVal
ENDIF   

ENDPROC
PROCEDURE lignoreerrors_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "L"
   THIS.lIgnoreErrors = m.vNewVal
ENDIf   


ENDPROC
PROCEDURE listenertype_assign
LPARAMETERS m.vNewVal
IF THIS.SupportsListenerType(m.vNewVal) AND ;
   NOT THIS.IsRunning
   THIS.ListenerType = m.vNewVal
ENDIF

ENDPROC
PROCEDURE outputtype_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "N" AND NOT THIS.IsRunning
   THIS.OutputType = INT(m.vNewVal)
   IF THIS.SupportsListenerType(THIS.OutputType) 
      THIS.ListenerType = THIS.OutputType
   ENDIF    
ENDIF

ENDPROC
PROCEDURE pagelimit_assign
LPARAMETERS m.tVal
IF VARTYPE(m.tVal) = "N" AND CEILING(m.tVal) > 0
   THIS.PageLimit = CEILING(m.tVal)
ELSE 
   THIS.PageLimit = -1        
ENDIF


ENDPROC
PROCEDURE pagelimitinsiderange_assign
LPARAMETERS m.tVal
IF VARTYPE(m.tVal) = "L" 
   THIS.PageLimitInsideRange = m.tVal
ENDIF


ENDPROC
PROCEDURE pagelimitquietmode_assign
LPARAMETERS m.tVal
IF VARTYPE(m.tVal) = "L" 
   THIS.PageLimitQuietMode = m.tVal
ENDIF


ENDPROC
PROCEDURE pagetaillimit_assign
LPARAMETERS m.tVal
IF VARTYPE(m.tVal) = "N" AND CEILING(m.tVal) > 0
   THIS.PageTailLimit = CEILING(m.tVal)
ELSE 
   THIS.PageTailLimit = -1        
ENDIF


ENDPROC
PROCEDURE pagetoplimit_assign
LPARAMETERS m.tVal
IF VARTYPE(m.tVal) = "N" AND CEILING(m.tVal) > 0
   THIS.PageTopLimit = CEILING(m.tVal)
ELSE 
   THIS.PageTopLimit = -1        
ENDIF


ENDPROC
PROCEDURE popglobalsets
* abstract: restore any globals here that aren't session-bound      


ENDPROC
PROCEDURE prepareerrormessage
LPARAMETERS m.nError, m.cMethod, m.nLine, m.cName, m.cMessage, m.cCodeLine

LOCAL m.lcErrorMessage, m.lcCodeLineMsg

IF VARTYPE(cMessage) = "C"
   m.lcErrorMessage = m.cMessage
ELSE
   m.lcErrorMessage = MESSAGE()
ENDIF

m.lcErrorMessage = m.lcErrorMessage + CHR(13) + CHR(13)

IF VARTYPE(cName) = "C"
   m.lcErrorMessage = m.lcErrorMessage + m.cName
ELSE
   m.lcErrorMessage = m.lcErrorMessage + this.Name
ENDIF

m.lcErrorMessage = m.lcErrorMessage + CHR(13)+ ;
 		 OUTPUTCLASS_ERRNOLABEL_LOC +ALLTRIM(STR(m.nError))+CHR(13)+ ;
		 OUTPUTCLASS_ERRPROCLABEL_LOC +LOWER(ALLTRIM(m.cMethod))
		
IF VARTYPE(m.cCodeLine) = "C"
   m.lcCodeLineMsg = m.cCodeLine
ELSE
   m.lcCodeLineMsg = MESSAGE(1)
ENDIF		

IF BETWEEN(m.nLine,1,100000) AND NOT m.lcCodeLineMsg="..."
	m.lcErrorMessage= ;
       m.lcErrorMessage+CHR(13)+ OUTPUTCLASS_ERRLINELABEL_LOC+ ;
	    ALLTRIM(STR(m.nLine))
	IF NOT EMPTY(m.lcCodeLineMsg)
       m.lcErrorMessage= ;
		   m.lcErrorMessage+CHR(13)+CHR(13)+m.lcCodeLineMsg
	ENDIF
ENDIF

RETURN m.lcErrorMessage
ENDPROC
PROCEDURE preparefrxswapcopy
LPARAMETERS m.tcPath, m.tlKeepCopyOpen, m.tlAdjustCommandClausesInLoadReport
LOCAL m.lcPath, m.lcFile, m.liSession, m.lcAlias, m.liSelect, m.llSafety
m.lcFile = ""
m.liSession = SET("DATASESSION")
m.liSelect = 0
TRY
   THIS.setFRXDataSession()
   m.liSelect = SELECT(0)
   DO CASE
   CASE VARTYPE(m.tcPath) = "C" AND ;
      (NOT EMPTY(m.tcPath)) AND DIRECTORY(ADDBS(m.tcPath))
      m.lcPath = m.tcPath
   CASE NOT DIRECTORY(ADDBS(JUSTPATH(THIS.CommandClauses.FILE)))
      * report does not exist on disk
      * and its path has not been re-created in the
      * current environment, potentially with related
      * image directories, etc.
      m.lcPath = SYS(2023)
   CASE EMPTY(SYS(2000,THIS.CommandClauses.File)) 
      * report does not exist on disk
      m.lcPath = SYS(2023)
   OTHERWISE
      * whenever possible,
      * the best place for this copy will
      * always be in the same location as the
      * original FRX, for relative-pathing reasons.
      m.lcPath = JUSTPATH(THIS.CommandClauses.File)
   ENDCASE
   m.lcFile = FORCEEXT(FORCEPATH("F"+SYS(2015), m.lcPath),"FRX")
   IF USED("FRX") && this method should ordinarily
                  && be used as part of a report swap, and that
                  && means in LoadReport only.  FRX isn't used yet.
                  && But we'll provide this mechanism,
                  && in case somebody has a different reason
                  && to use this method at another 
                  && point in report processing -- 
                  && XML Listener has one,
                  && for example!
      SELECT 0
      CREATE CURSOR x (onefield l)
      * we're in the frxdatasession, this is safe
      CREATE REPORT (m.lcFile) FROM  (ALIAS()) && (DBF("x"))
      USE IN x
      SELECT 0
      USE (m.lcFile) EXCLUSIVE ALIAS (JUSTSTEM(m.lcFile))
      m.lcAlias = ALIAS()
      m.llSafety = (SET("SAFETY") == "ON")
      SET SAFETY OFF
      ZAP
      IF m.llSafety
         SET SAFETY ON
      ENDIF
      SELECT FRX
      SCAN ALL FOR NOT DELETED()
         SCATTER MEMVAR MEMO
         INSERT INTO (m.lcAlias) FROM MEMVAR
      ENDSCAN
      IF NOT m.tlKeepCopyOpen
         USE IN (m.lcAlias)
      ENDIF   
   ELSE
      * this is the normal swap mechanism
      * SYS(2000) may be empty but FILE() should not
      * be, even if this report was not on disk,
      * and CommandClauses.File should be fully-qualified.
      SELECT 0
      USE (THIS.CommandClauses.File) ;
        SHARED NOUPDATE ;
        ALIAS (JUSTSTEM(THIS.CommandClauses.File))
      m.lcAlias = ALIAS()
      SELECT * FROM (THIS.CommandClauses.File) ;
         WHERE NOT DELETED() ;
         INTO TABLE (m.lcFile)
      USE IN (m.lcAlias)
      IF NOT m.tlKeepCopyOpen
         m.lcAlias = JUSTSTEM(m.lcFile)
         * this should always work because of the way
         * we've defined the m.lcFile contents
         IF USED(m.lcAlias)
            USE IN (m.lcAlias)   
         ENDIF         
      ENDIF   
   ENDIF
CATCH WHEN .T.
   m.lcFile = ""
FINALLY
   IF (NOT (EMPTY(m.lcFile) OR EMPTY(SYS(2000,m.lcFile)))) AND ;
      m.tlAdjustCommandClausesInLoadReport AND ;
      NOT m.tlKeepCopyOpen
      THIS.CommandClauses.File = m.lcFile
   ENDIF 
   IF m.liSelect > 0
      SELECT (m.liSelect)
   ENDIF
   SET DATASESSION TO (m.liSession)      
ENDTRY      

RETURN m.lcFile
ENDPROC
PROCEDURE pushglobalsets
  * abstract: set any globals here that aren't session-bound

ENDPROC
PROCEDURE quietmode_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "L"
   THIS.quietmode = m.vNewVal
ENDIF 
ENDPROC
PROCEDURE removefrxswapcopy
LPARAMETERS m.tcFile,m.tlRecycle
LOCAL m.lcRecyle, m.llResettingSharedCopy
IF EMPTY(m.tcFile) AND THIS.isFRXSwapCopyPresent()
   m.llResettingSharedCopy = .T.
   m.tcFile = THIS.CommandClauses.File
ENDIF
IF NOT EMPTY(m.tcFile)
   IF m.tlRecycle
      m.lcRecycle = " RECYCLE"
   ELSE
      m.lcRecycle = ""
   ENDIF      
   IF NOT EMPTY(SYS(2000,FORCEEXT(m.tcFile,"FRX")))
      ERASE (FORCEEXT(m.tcFile,"FRX")) &lcRecycle
   ENDIF      
   IF NOT EMPTY(SYS(2000,FORCEEXT(m.tcFile,"FRT")))
      ERASE (FORCEEXT(m.tcFile,"FRT")) &lcRecycle
   ENDIF      
   IF m.llResettingSharedCopy
      THIS.CommandClauses.File = THIS.commandClausesFile 
   ENDIF
ENDIF   

ENDPROC
PROCEDURE removereports
IF NOT (THIS.IsRunningReports)
   THIS.ReportFileNames = NULL
   THIS.ReportClauses = NULL
   THIS.Listeners = NULL
   DIME THIS.ReportPages[1]
   THIS.ReportPages[1] = 0
   
ENDIF   
ENDPROC
PROCEDURE resetcalladjustobjectsize
* abstract, poll members
ENDPROC
PROCEDURE resetcallevaluatecontents
* abstract, poll members
ENDPROC
PROCEDURE resetdatasession
IF (THIS.listenerDataSession > -1) 
   TRY
      SET DATASESSION TO (THIS.listenerDataSession)
   CATCH WHEN .T.
      THIS.ResetToDefault("listenerDataSession")
      SET DATASESSION TO (THIS.listenerDataSession)      
   ENDTRY
ENDIF   

ENDPROC
PROCEDURE resetdynamicmethodcalls
*&* Sedna:

* poll Successor, who would
* have already run all this code on its
* own behalf:

IF INLIST(THIS.callAdjustObjectSize,;
          LISTENER_CALLDYNAMICMETHOD_CHECK_CODE,;
          LISTENER_CALLDYNAMICMETHOD_NEVER) 
   THIS.resetCallAdjustObjectSize()
ELSE  && already set to LISTENER_CALLDYNAMICMETHOD_ALWAYS, always call
  * leave alone
ENDIF   

IF INLIST(THIS.callEvaluateContents,;
          LISTENER_CALLDYNAMICMETHOD_CHECK_CODE,;
          LISTENER_CALLDYNAMICMETHOD_NEVER) 
   THIS.resetCallEvaluateContents()
ELSE  && already set to LISTENER_CALLDYNAMICMETHOD_ALWAYS, always call
  * leave alone
ENDIF   

IF NOT ISNULL(THIS.Successor) 
   IF PEMSTATUS(THIS.successor,"CallAdjustObjectSize",5) AND ;
      THIS.successor.CallAdjustObjectSize = LISTENER_CALLDYNAMICMETHOD_ALWAYS
      THIS.CallAdjustObjectSize = LISTENER_CALLDYNAMICMETHOD_ALWAYS
   ENDIF
   IF PEMSTATUS(THIS.successor,"CallEvaluateContents",5) AND ;
      THIS.successor.CallEvaluateContents = LISTENER_CALLDYNAMICMETHOD_ALWAYS
      THIS.CallEvaluateContents = LISTENER_CALLDYNAMICMETHOD_ALWAYS
   ENDIF      
ENDIF         




ENDPROC
PROCEDURE runreports
LPARAMETERS m.tlRemoveReportsAfterRun, m.tlOmitListenerReferences

IF NOT ;
 (THIS.IsRunningReports OR ;
  ISNULL(THIS.ReportFileNames) OR ;
  THIS.ReportFileNames.Count = 0)

  LOCAL m.oError, m.liIndex, m.lcClauses, m.loListener, m.lcParse
  m.oError = NULL

  THIS.IsRunningReports = .T. 
  
  TRY 
  
    FOR m.liIndex = 1 TO THIS.ReportFileNames.Count
       * the clauses, filenames, and listener collections are 
       * protected properties, we're
       * taking care of how they match up, 
       * that FRXs exist, etc.
       m.lcClauses = UPPER(THIS.ReportClauses[m.liIndex])
       m.loListener = THIS.Listeners[m.liIndex]
       DO CASE 
       CASE " OBJE " $ STRTRAN(" "+m.lcClauses,"CT", " ") OR ;
            " OBJEC " $ " "+m.lcClauses OR ;
            m.tlOmitListenerReferences
          m.loListener = NULL  
          REPORT FORM (THIS.ReportFileNames[m.liIndex]) &lcClauses
          TRY
             m.lcParse = " " + STRTRAN(" "+m.lcClauses," OBJECT ", " OBJE ")
             m.lcParse = STRTRAN(m.lcParse," OBJEC ", " OBJE ")
             m.lcParse = SUBSTR(m.lcParse,AT(" OBJE ", m.lcParse)+5)        
             DO CASE
             CASE m.tlOmitListenerReferences
                * we're going with old-style behavior for sure here
             CASE " TYPE " $ " " + m.lcClauses
                m.lcParse = ALLTRIM(STRTRAN(" " + m.lcParse," TYPE ",""))
                IF " " $ m.lcParse
                   m.lcParse = ALLTRIM(LEFT(m.lcParse,AT(" ",m.lcParse,1)))
                ENDIF
                IF VAL(m.lcParse) > 0
                   m.loListener = EVALUATE("_oReportOutput['" + m.lcParse+"']")
                ENDIF
             OTHERWISE
                m.lcParse = ALLTRIM(m.lcParse)
                IF " " $ m.lcParse
                   m.lcParse = ALLTRIM(LEFT(m.lcParse,AT(" ",m.lcParse,1)))
                ENDIF
                m.loListener = EVALUATE(m.lcParse)         
             ENDCASE
          CATCH
             m.loListener = NULL
          ENDTRY   
       CASE ISNULL(loListener)
          REPORT FORM (THIS.ReportFileNames[m.liIndex]) &lcClauses  OBJECT THIS
          m.loListener = THIS
       OTHERWISE
          REPORT FORM (THIS.ReportFileNames[m.liIndex]) &lcClauses  OBJECT m.loListener
       ENDCASE
       
       THIS.adjustReportPagesInfo(m.liIndex, m.lcClauses, m.loListener)

*&* Sedna change: 
*&*  see new THIS.adjustReportPagesInfo method, to which we pass report index, clauses, and 
*&*  evaluated listener ref.  Original code here was:
*&*          IF NOT (" NOWA " $ STRTRAN(" "+m.lcClauses,"IT"," ") OR ;
*&*                  " NOWAI " $ " " + m.lcClauses) 
*&*             THIS.ReportPages[m.liIndex] = THIS.SharedPageTotal
*&*             * TBD: make this a two-column array with 
*&*             * output pages (responsive to RANGE clause)
*&*             * represented as well?
*&*          ENDIF
       
    ENDFOR
    
         
  CATCH TO m.oError
     LOCAL lcErrMsg
     IF (ISNULL(m.oError))
         lcErrMsg = MESSAGE() + CHR(13) + MESSAGE(1)
     ELSE
         lcErrMsg = THIS.PrepareErrorMessage(;
               m.oError.ErrorNo, ;
               m.oError.PROCEDURE, ;
               m.oError.LINENO, ;
               THIS.AppName, ;
               m.oError.MESSAGE, ;
               m.oError.LineContents)
     ENDIF
     THIS.DoMessage(lcErrMsg, MB_ICONSTOP)
     THIS.lastErrorMessage = lcErrMsg
     #IF OUTPUTCLASS_DEBUGGING
         SUSPEND
     #ENDIF                   
     EXIT  
  FINALLY
  
     THIS.IsRunningReports = .F.  
     IF m.tlRemoveReportsAfterRun
       THIS.RemoveReports()
     ENDIF  
     STORE NULL TO m.loListener, m.oError

  ENDTRY
  
  
ENDIF   





ENDPROC
PROCEDURE setcurrentdatasession
IF (THIS.CurrentDataSession # SET("DATASESSION"))  
   TRY
      SET DATASESSION TO (THIS.CurrentDataSession)
   CATCH WHEN .T.
      THIS.ResetToDefault("CurrentDataSession")
      THIS.resetDataSession()
   ENDTRY
ENDIF   


ENDPROC
PROCEDURE setfrxdatasession
IF (THIS.FRXDataSession > -1) AND (THIS.FRXDataSession # SET("DATASESSION"))

   TRY
      SET DATASESSION TO (THIS.FRXDataSession)
   CATCH WHEN .T.
      THIS.ResetToDefault("FRXDataSession")
      THIS.resetDataSession()
   ENDTRY
   
ENDIF   

ENDPROC
PROCEDURE setfrxdatasessionenvironment
THIS.setFRXDataSession()
SET TALK OFF 

ENDPROC
PROCEDURE setfrxrunstartupconditions
IF ISNULL(THIS.CommandClauses)
   THIS.CommandClauses = CREATEOBJECT("Empty")
ENDIF
IF TYPE("THIS.CommandClauses.NoDialog") # "L"
   ADDPROPERTY(THIS.CommandClauses,"NoDialog",.F.)
ENDIF      


* add anything critical during a run
* that might not be available, whether
* because this is a custom attribute
* or because public methods of ReportListener
* might be called outside a normal report run.
ENDPROC
PROCEDURE setsuccessordynamicproperties
IF NOT THIS.isSuccessor
   THIS.sharedOutputPageCount = THIS.OutputPageCount
   THIS.sharedPageTotal = THIS.PageTotal
   THIS.sharedPageNo = THIS.PageNo
   THIS.sharedGdiplusGraphics = THIS.GDIPlusGraphics 
ENDIF
WITH THIS.Successor
   .CurrentPass = THIS.CurrentPass
   .TwoPassProcess = THIS.TwoPassProcess   
   .sharedOutputPageCount = THIS.sharedOutputPageCount
   .sharedPageTotal = THIS.sharedPageTotal   
   .sharedPageNo = THIS.sharedPageNo
   .sharedGdiplusGraphics  = THIS.sharedGdiplusGraphics
   .CallEvaluateContents = THIS.CallEvaluateContents
   .CallAdjustObjectSize = THIS.CallAdjustObjectSize
ENDWITH   

ENDPROC
PROCEDURE sharedgdiplusgraphics_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "N"
   THIS.SharedGDIplusGraphics = m.vNewVal
ENDIF   

ENDPROC
PROCEDURE sharedlistenertype_assign
LPARAMETERS vNewVal
IF VARTYPE(m.vNewVal) = "N" AND ;
   INLIST(m.vNewVal,LISTENER_TYPE_DEF,;
                    LISTENER_TYPE_PRN,;
                    LISTENER_TYPE_PRV,;
                    LISTENER_TYPE_PAGED,;
                    LISTENER_TYPE_ALLPGS)
   THIS.sharedListenerType = m.vNewVal
ENDIF   

ENDPROC
PROCEDURE sharedoutputpagecount_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "N"
   THIS.sharedOutputPageCount = m.vNewVal
ENDIF   

ENDPROC
PROCEDURE sharedpageheight_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "N"
   THIS.sharedPageHeight = m.vNewVal
ENDIF   

ENDPROC
PROCEDURE sharedpageno_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "N"
   THIS.sharedPageNo = m.vNewVal
ENDIF   

ENDPROC
PROCEDURE sharedpagetotal_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "N"
   THIS.sharedPageTotal = m.vNewVal
ENDIF   

ENDPROC
PROCEDURE sharedpagewidth_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "N"
   THIS.sharedPageWidth = m.vNewVal
ENDIF   

ENDPROC
PROCEDURE successor_assign
LPARAMETERS m.vNewVal
IF (NOT THIS.IsRunning) AND ;
   (ISNULL(m.vNewVal) OR ;
   (VARTYPE(m.vNewVal) = "O" AND UPPER(m.vNewVal.BaseClass) == "REPORTLISTENER"))
   THIS.Successor = m.vNewVal
ENDIF   


ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*addreport Adds to the class's collection of ReportFileNames, optionally associating REPORT FORM clauses and a listener for the specified report.
*adjustreportpagesinfo Hook to allow subclasses to decide how to associate the page numbers for each report in a collection with the member array representing page numbers, during the runReports method.
*allowmodalmessages_assign 
*appname_assign 
*clearerrors Resets the class's error status.
*commandclausesfile_assign 
*fillruncollector Abstract method to set up up runCollector object with contents at whatever point is appropriate in a given implementation.
*getfrxstartupinfo Provides a hook for gathering FRX information during BeforeReport method processing.
*getlasterrormessage Provides information about the last error that occurred.
*invokeoncurrentpass Provides a hook for listeners to evaluate whether they wish to generate output or perform other actions during the current report execution pass.
*isfrxswapcopypresent Indicates whether the original CommandClauses.File value has been swapped for a temporary copy during a report run.
*issuccessor_assign 
*lignoreerrors_assign 
*listenertype_assign 
*outputtype_assign 
*pagelimit_assign 
*pagelimitinsiderange_assign 
*pagelimitquietmode_assign 
*pagetaillimit_assign 
*pagetoplimit_assign 
*popglobalsets Provides a hook for Listeners to restore global settings not scoped to a data session after saving them with PushGlobalSets.
*prepareerrormessage Organizes common error information values (nError, cMethod, nLine, cName, cMessage, cCodeLine) into a coherent string for presentation to the user.
*preparefrxswapcopy Provides an FRX copy on disk, in the same path/location as the original FRX if possible to support relative file references, for use during a report run.  Returns fully-qualified temporary file name it generates for the copy.
*pushglobalsets Provides a hook for Listeners to save global settings not scoped to a data session for later restoration with PopGlobalSets.
*quietmode_assign 
*removefrxswapcopy Removes an FRX file and its matching FRT file from disk, if present.
*removereports Removes report filenames as well as associated clauses and listeners from this Listeners' various collections.
*resetcalladjustobjectsize Evaluates whether this reportlistener's activity requires calls to AdjustObjectSize method for any layout controls on this report run.
*resetcallevaluatecontents Evaluates whether this reportlistener's activity requires calls to EvaluateContents method for any layout controls on this report run.
*resetdatasession Sets the DataSessionID to the session where the Listener originated.
*resetdynamicmethodcalls Evaluates whether AdjustObjectSize and EvaluateContents methods should be called for a report run, for this reportlistener's activity or as requested by Successor chain.
*resetruncollector Abstract method to clean up runCollector object at whatever point is appropriate in a given implementation.
*runreports Executes a series of REPORT FORM commands according to the instructions in the ReportFileNames, ReportClauses, and Listeners collections.  Optionally clears collection after run and issues the REPORT FORM commands without OBJECTreferences.
*setcurrentdatasession Sets the DataSessionID to the data session holding report's data tables.
*setfrxdatasession Sets the DataSessionID to the data session in which the Engine has opened a readonly copy of the report file as a table for the Listener's use.
*setfrxdatasessionenvironment Provides a hook for classes to determine the datasession-scoped SETs they wish to add to the private FRX data session.
*setfrxrunstartupconditions Hook method called in BeforeReport, allowing you to set up CommandClauses properties or other attributes required by your class.
*setsuccessordynamicproperties Provides a hook for the Listener to share information changed by the Engine with a succession of Listeners, during the run of a report.
*sharedgdiplusgraphics_assign 
*sharedlistenertype_assign 
*sharedoutputpagecount_assign Provides a readwrite copy of the the Engine's OutputPageCount property which the Listener can share with a succession chain.
*sharedpageheight_assign 
*sharedpageno_assign 
*sharedpagetotal_assign 
*sharedpagewidth_assign 
*successor_assign 
^reportpages[1,0] Holds accumulated page count  info when this class runs a collection of reports as a series. Can be used in report expressions or checked after a report run (if .removeReports has not been called).  Set in adjustReportPagesInfo.
_memberdata XML Metadata for customizable properties
appname Localizable application name string for use in user feedback.
commandclausesfile Allows saving and restoring of the original CommandClauses.File value by any derived class that permits dynamic FRX-fileswapping during LoadReport.
drivingalias Holds the alias of the table or cursor driving the report scope.
frxheaderrecno Stores the header record number for the Windows platform in cross-platform FRXs.
haderror Provides a flag indicating whether an error occurred.
isrunning Provides a flag to indicate whether a report run is underway.  When IsRunning is true, the class may wish to disallow certain activities or method calls.
isrunningreports Provides a flag to indicate this ReportListener is running a series of reports using its collection.
issuccessor Indicates whether this Listener is chained to one or more others to provide output during a report run.  When .T., this Listener was not the object referenced in the REPORT FORM command OBJECT clauses.
lasterrormessage
lignoreerrors Provides a flag to determine how this class handles activities subsequent to an error.
listenerdatasession Saves the DataSessionID in which the Listener originated.
listeners Collection of ReportListeners associated with each report in this Listener's ReportFileNames collection.
pagelimit If > 0, represents the highest number of pages allowed in a report run (potentially across multiple reports using NOPAGEEJECT).  Especially useful for ListenerTypes 1 and 3, to avoid GDI resource issues, but can provide abbreviated results for any type
pagelimitinsiderange If .T., indicates that pageTopLimit and pageTailLimit provide an inside range rather than beginning and end of report contents.  Makes pageTopLimit and pageTailLimit similar to RANGE clause, but active over multiple reports with NOPAGEEJECT.
pagelimitquietmode Indicates whether the class provides user feedback when the report results are limited because the run exceeded the specified pageLimit.
pagetaillimit If > 0, represents the lowest number of pages for "tail" section of report run (potentially across multiple reports using NOPAGEEJECT).   Use with pageTopLimit or alone. No user feedback provided. 
pagetoplimit If > 0, represents the highest number of pages for "top" section of report run (potentially across multiple reports using NOPAGEEJECT).   Use with pageTailLimit or alone. No user feedback provided.
reportclauses Stores REPORT FORM command clauses associated with each report in the ReportFileNames collection.
reportfilenames Stores the filenames of reports to be managed and executed in a series.
reportusesprivatedatasession Provides a flag to indicate whether this report shares the data session from which it was executed or maintains a private data session.
runcollector Placeholder available to hold extension output generated during a report run. Property may contain an alias for a cursor holding property names and values, a collection object reference, or an empty-type object reference.
sharedgdiplusgraphics Provides a readwrite copy of the the Engine's GDIPlusGraphics handle which the Listener can share with a succession chain.
sharedlistenertype Provides a readwrite copy of the the Engine's ListenerType property which the Listener can share with a succession chain.
sharedoutputpagecount Provides a readwrite copy of the the Engine's OutputPageCount property which the Listener can share with a succession chain.
sharedpageheight Shares information gathered by the GetPageHeight method with other Listeners linked in a succession chain.
sharedpageno Provides a readwrite copy of the the Engine's PageNo property which the Listener can share with a succession chain.
sharedpagetotal Provides a readwrite copy of the the Engine's PageTotal property which the Listener can share with a succession chain.
sharedpagewidth Shares information gathered by the GetPageWidth method with other Listeners linked in a succession chain.
successor An object reference to the next Listener in a succession chain.
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED7]
Adds error handling, session handling, and other common report run-time tasks to ReportListener base class.  Provides the ability to chain a series of reports as well as the means to delegate or share output activities to a chain of Listener-successors.[END RESERVED7]
[START RESERVED8]
reportlisteners.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] _reportlistener

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _14110GV5X
[CLASS] utilityreportlistener
[CLASSLOC] listener.vcx
[BASECLASS] reportlistener
[OBJNAME] debuglistener
[START PROPERTIES]
FRXDataSession = -1
Height = 23
Name = "debuglistener"
Width = 23
_memberdata =      461<VFPData><memberdata name="verbose" type="property" display="verbose" favorites="True" /><memberdata name="dodebug" type="method" display="doDebug" favorites="True" /><memberdata name="dodebugcommandclauses" type="method" display="doDebugCommandClauses" favorites="False" /><memberdata name="targetalias" type="property" display="targetAlias" /><memberdata name="includeloadandunload" type="property" display="includeLoadAndUnload" favorites="True" /></VFPData>
includeloadandunload = .T.
targetalias = ("")
[END PROPERTIES]
[START PROTECTED]
dodebugcommandclauses
targetalias
[END PROTECTED]
[START METHODS]
PROCEDURE AddProperty
LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
THIS.DoDebug(PROGRAM(), PCOUNT(), ;
             m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)

ENDPROC
PROCEDURE AdjustObjectSize
LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
DODEFAULT(m.p1, m.p2)
THIS.DoDebug(PROGRAM(), PCOUNT(), ;
     m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)

ENDPROC
PROCEDURE AfterBand
LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
THIS.DoDebug(PROGRAM(), PCOUNT(), ;
     m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)
DODEFAULT(m.p1, m.p2)
ENDPROC
PROCEDURE AfterReport
LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12

LOCAL m.lcProgram
m.lcProgram = PROGRAM()
THIS.DoDebug(m.lcProgram, PCOUNT(), ;
   m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)
THIS.DoDebugCommandClauses(THIS.CommandClauses,m.lcProgram+ " current CommandClauses")

IF NOT (THIS.IncludeLoadAndUnload OR THIS.CommandClauses.NoPageEject)
   THIS.CloseTargetFile()
   IF NOT THIS.QuietMode
      MODI COMM (THIS.TargetFileName) NOWAIT
   ENDIF   
ENDIF   

DODEFAULT()

ENDPROC
PROCEDURE BeforeBand
LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
THIS.DoDebug(PROGRAM(), PCOUNT(), ;
    m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)
DODEFAULT(m.p1, m.p2)
IF THIS.Verbose
   THIS.TargetAlias = ""
   IF m.p1 = FRX_OBJCOD_DETAIL
      THIS.SetFRXDataSession()
      GO m.p2 IN FRX
      IF NOT EMPTY(FRX.Expr)
         THIS.TargetAlias = UPPER(EVALUATE(FRX.Expr))
      ENDIF
      THIS.resetDataSession()
   ENDIF
ENDIF   
ENDPROC
PROCEDURE BeforeReport
LPARAMETERS m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12

   LOCAL m.lcProgram
   m.lcProgram = PROGRAM()
   
   DODEFAULT()
   
   IF THIS.Verbose
   
      THIS.setCurrentDataSession()

   ENDIF
   
  
   IF THIS.TargetHandle = -1 
      THIS.OpenTargetFile()
   ENDIF

  THIS.DoDebug(PROGRAM(), PCOUNT(), ;
       m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)
   
  THIS.DoDebugCommandClauses(THIS.CommandClauses,m.lcProgram+ " received CommandClauses")


   IF THIS.verbose
      THIS.resetDataSession()
   ENDIF      
   

ENDPROC
PROCEDURE CancelReport
LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
THIS.DoDebug(PROGRAM(), PCOUNT(), ;
     m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)
DODEFAULT()

ENDPROC
PROCEDURE ClearStatus
LPARAMETERS m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
THIS.DoDebug(PROGRAM(), PCOUNT(), ;
    m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)
DODEFAULT()

ENDPROC
PROCEDURE DoStatus
LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
THIS.DoDebug(PROGRAM(), PCOUNT(), ;
     m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)
DODEFAULT(m.p1)

ENDPROC
PROCEDURE EvaluateContents
LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
DODEFAULT(m.p1, m.p2)
THIS.DoDebug(PROGRAM(), PCOUNT(), ;
    m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)

ENDPROC
PROCEDURE IncludePageInOutput
LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
THIS.DoDebug(PROGRAM(), PCOUNT(), ;
    m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)
RETURN DODEFAULT(m.p1)

ENDPROC
PROCEDURE Init
IF DODEFAULT()
   THIS.AppName = OUTPUTCLASS_APPNAME_LOC
   RETURN NOT THIS.hadError 
ELSE
   RETURN .F.   
ENDIF


ENDPROC
PROCEDURE LoadReport
LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12

DODEFAULT()

IF THIS.IncludeLoadandUnload 

  IF THIS.TargetHandle = -1
     THIS.OpenTargetFile()
  ENDIF
  
  THIS.DoDebug(PROGRAM(), PCOUNT(), ;
      m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)
  THIS.DoDebugCommandClauses(THIS.CommandClauses,PROGRAM()+ " received CommandClauses")
  
ENDIF  

ENDPROC
PROCEDURE OnPreviewClose
LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
THIS.DoDebug(PROGRAM(), PCOUNT(), ;
    m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)

ENDPROC
PROCEDURE OutputPage
LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
THIS.DoDebug(PROGRAM(), PCOUNT(), ;
    m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)


ENDPROC
PROCEDURE ReadExpression
LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
THIS.DoDebug(PROGRAM(), PCOUNT(), ;
     m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)

ENDPROC
PROCEDURE ReadMethod
LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
THIS.DoDebug(PROGRAM(), PCOUNT(), ;
     m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)

ENDPROC
PROCEDURE Render
LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
IF DODEFAULT( m.p1, @m.p2, @m.p3, @m.p4, @m.p5, @m.p6, @m.p7,@m.p8) #  OUTPUTFX_BASERENDER_NORENDER
    THIS.DoDebug(PROGRAM(), PCOUNT(), ;
        m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)
ENDIF

ENDPROC
PROCEDURE ResetToDefault
LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
THIS.DoDebug(PROGRAM(), PCOUNT(), ;
    m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)

ENDPROC
PROCEDURE SaveAsClass
LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
THIS.DoDebug(PROGRAM(), PCOUNT(), ;
    m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)

ENDPROC
PROCEDURE SupportsListenerType
LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
THIS.DoDebug(PROGRAM(), PCOUNT(), ;
    m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)

ENDPROC
PROCEDURE UnloadReport
LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12

IF THIS.includeLoadAndUnload 
   LOCAL lcProgram
   lcProgram = PROGRAM()
   THIS.DoDebug(lcProgram, PCOUNT(),;
        m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)
   THIS.DoDebugCommandClauses(THIS.CommandClauses,m.lcProgram+ " current CommandClauses")
ENDIF   

IF THIS.TargetHandle > 0 AND (NOT THIS.CommandClauses.NoPageEject)
   THIS.CloseTargetFile()
   IF NOT THIS.QuietMode
      MODI FILE (THIS.Targetfilename) NOWAIT
   ENDIF
ENDIF   

DODEFAULT()

ENDPROC
PROCEDURE UpdateStatus
LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
THIS.DoDebug(PROGRAM(), PCOUNT(), ;
     m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)
DODEFAULT()

ENDPROC
PROCEDURE WriteExpression
LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
THIS.DoDebug(PROGRAM(), PCOUNT(), ;
     m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)

ENDPROC
PROCEDURE WriteMethod
LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
THIS.DoDebug(PROGRAM(), PCOUNT(), ;
     m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)

ENDPROC
PROCEDURE dodebug
LPARAMETERS m.p0, m.pcount, m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12

IF THIS.TargetHandle > 0 

   LOCAL m.liIndex, m.loObj, m.lvParam, m.liObjIndex, m.liMembers, laMembers[1]

   FWRITE( THIS.TargetHandle, m.p0 )
   
   FOR m.liIndex = 1 TO m.pcount
   
      m.lvParam = EVAL("p"+TRANS(liIndex))
   
      IF THIS.Verbose AND VARTYPE(m.lvParam) = "O"

         m.liMembers = AMEMBERS(laMembers, m.lvParam) && ,0,"G"
 
         FOR m.liIndex = 1 TO m.liMembers
   
            IF TYPE("lvParam."+laMembers[m.liIndex]) # "U"
               FWRITE(THIS.TargetHandle, ;
                  ",Obj."+laMembers[m.liIndex]+"="+TRANSFORM(EVAL("lvParam."+laMembers[m.liIndex])) )
            ENDIF
     
         ENDFOR

      ELSE
  
         FWRITE(THIS.TargetHandle, ","+TRANSF(m.lvParam))

      ENDIF

   ENDFOR

   FPUTS(THIS.TargetHandle, "")

   IF THIS.Verbose
      THIS.setCurrentDataSession()
   
      FWRITE(THIS.TargetHandle, ;
          "Listener.PageNo=" + IIF(THIS.sharedPageNo=0,;
                                   TRANSFORM(THIS.PageNo),  ;
                                   TRANSFORM(THIS.sharedPageNo))+ ", " + ;
          "_PAGENO="+TRANSFORM(_PAGENO))

      IF (NOT EMPTY(THIS.DrivingAlias)) AND USED(THIS.DrivingAlias)
         FWRITE(THIS.TargetHandle, ", " + THIS.DrivingAlias + " recno=" + TRANSFORM(RECNO(THIS.Drivingalias)))   
      ENDIF   
      
      IF NOT EMPTY(THIS.TargetAlias)
      
         FWRITE(THIS.TargetHandle, ", TargetAlias=" + THIS.TargetAlias + ", targetRecno=" + TRANSFORM(RECNO(THIS.TargetAlias)))         
      
      ENDIF
   
      FPUTS(THIS.TargetHandle, "")   
      THIS.resetDataSession()
   ENDIF
   
   FFLUSH(THIS.targetHandle)
   
ENDIF   




ENDPROC
PROCEDURE dodebugcommandclauses
LPARAMETERS m.tvCommand, m.tcHeader

IF VARTYPE(m.tvCommand) = "O" AND THIS.TargetHandle > 0 
   LOCAL m.liIndex, laMembers[1], m.liMembers

   FPUTS( THIS.TargetHandle, REPL("-",30) )   
   FPUTS( THIS.TargetHandle, "MEMBERS:" )
   m.liMembers = AMEMBERS(laMembers, THIS) && ,0,"G"
 
   FOR m.liIndex = 1 TO m.liMembers
   
      IF TYPE("THIS."+laMembers[m.liIndex]) # "U"
  
         FPUTS(THIS.TargetHandle, "."+laMembers[m.liIndex]+"="+TRANSFORM(EVAL("THIS."+laMembers[m.liIndex])) )
      ENDIF

   ENDFOR

   FPUTS( THIS.TargetHandle, REPL("-",30) )   
   FPUTS( THIS.TargetHandle, tcHeader )
      
   m.liMembers = AMEMBERS(laMembers, m.tvCommand)   
   IF m.liMembers = 0
      FPUTS(THIS.TargetHandle, "... NO MEMBERS")
   ELSE

      FOR m.liIndex = 1 TO m.liMembers
  
        FPUTS(THIS.TargetHandle, "."+laMembers[m.liIndex]+"="+TRANSFORM(EVAL("tvCommand."+laMembers[m.liIndex])) )

      ENDFOR
     
   ENDIF   
   FPUTS( THIS.TargetHandle, REPL("-",30) )      
   FFLUSH(THIS.targetHandle)

ENDIF
ENDPROC
PROCEDURE opentargetfile
IF WEXIST(JUSTSTEM(THIS.targetFileName))
   * because of the MODI FILE NOWAIT,
   * generate a new filename:
   THIS.targetFileName = SYS(2015)
ENDIF
DODEFAULT()   
ENDPROC
PROCEDURE verbose_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "L"
   THIS.Verbose = m.vNewVal
ENDIF   

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*dodebug Provides debug information for a ReportListener event or method.
*dodebugcommandclauses Provides debug information for the CommandClauses object and ReportListener member properties.
*verbose_assign 
includeloadandunload Indicates whether the debug information should include values from the LoadReport and UnloadReport events.
targetalias Holds the target alias during the processing of a detail band.
verbose Specifies whether the DebugListener should include extended information about parameter values of object type, as well as page, alias, and recno() information for each event or method.
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED7]
Provides debugging output to help developers understand what happens during an object-assisted report run.[END RESERVED7]
[START RESERVED8]
reportlisteners.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] debuglistener

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1PC0NFKPY
[CLASS] custom
[BASECLASS] custom
[OBJNAME] fxabstract
[START PROPERTIES]
Name = "fxabstract"
_memberdata = <VFPData><memberdata name="applyfx" type="property" display="applyFX" favorites="True"/></VFPData>
[END PROPERTIES]
[START METHODS]
PROCEDURE applyfx
LPARAMETERS m.toListener, m.tcMethodToken,;
            m.tP1, m.tP2, m.tP3, m.tP4, m.tP5, m.tP6, ;
            m.tP7, m.tP8, m.tP9, m.tP10, m.tP11, m.tP12
            

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*applyfx Required method to implement the FX interface.
_memberdata XML Metadata for customizable properties
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED7]
Custom-derived class, supplying an abstract instance of the required interface to implement an FX or GFX object. For use with FXListener as a report decorator.[END RESERVED7]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] fxabstract

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1L50LCL98
[CLASS] _reportlistener
[CLASSLOC] listener.vcx
[BASECLASS] reportlistener
[OBJNAME] fxlistener
[START PROPERTIES]
</VFPData>
<memberdata name="checkcollectionforspecifiedmember" type="method" display="checkCollectionForSpecifiedMember" favorites="True"/><memberdata name="addcollectionmember" type="method" display="addCollectionMember" favorites="True"/>
<memberdata name="creatememberdatacursor" type="method" display="createMemberDataCursor"/><memberdata name="runcollectorresetlevel" type="property" favorites="True" display="runCollectorResetLevel"/><memberdata name="getfrxrecno" type="method" display="getFRXRecno" favorites="True"/><memberdata name="getrotategfxobject" type="method" display="getRotateGFXObject" favorites="True"/><memberdata name="gfxrotateclass" type="property" display="gfxRotateClass" favorites="True" /><memberdata name="gfxrotateclasslib" type="property" display="gfxRotateClassLib" favorites="True" /><memberdata name="gfxrotatemodule" type="property" display="gfxRotateModule" favorites="True" /><memberdata name="removecollectionmember" display="removeCollectionMember" type="method" favorites="True"/> <memberdata name="reportstartrundatetime" type="property" display="reportStartRunDatetime" favorites="True" /> <memberdata name="reportstoprundatetime" type="property" display="reportStopRunDatetime" favorites="True" /><memberdata name="evaluateuserexpression" display="evaluateUserExpression" type="method"/><memberdata name="getnorendergfxobject" type="method" display="getNoRenderGFXObject" favorites="True"/><memberdata name="gfxnorenderclass" type="property" display="gfxNoRenderClass" favorites="True" /><memberdata name="gfxnorenderclasslib" type="property" display="gfxNoRenderClassLib" favorites="True" /><memberdata name="gfxnorendermodule" type="property" display="gfxNoRenderModule" favorites="True" /><memberdata name="ensurecollection" type="method" display="ensureCollection"/>
<memberdata name="getpathforexternals" type="method" display="getPathForExternals" favorites="True" /> <memberdata name="loadfrxcursor" type="property" display="loadFrxCursor" favorites="True" /> <memberdata name="frxcursor" type="property" display="frxCursor" favorites="True" />
<memberdata name="memberdataalias" type="property" display="memberDataAlias" favorites = "True"/>
FRXDataSession = -1
Name = "fxlistener"
_memberdata =     3942<VFPData><memberdata name="fxs" type="property" display="FXs" favorites="True" /><memberdata name="gfxs" type="property" display="GFXs" favorites="True" /><memberdata name="ffcgraphics" type="property" display="FFCGraphics"  favorites="True"/><memberdata name="createhelperobjects" type="method" display="createHelperObjects"/><memberdata name="needgfxs" type="method" display="needGFXs"/><memberdata name="sendfx" type="method" display="sendFX"/><memberdata name="checkcollectionmembers" type="method" display="checkCollectionMembers"/><memberdata name="uppermethodname" type="method" display="upperMethodName" favorites="True"/><memberdata name="cancelrequested" type="property" display="cancelRequested" /><memberdata name="fxmemberdatascriptclass" type="property" display="fxMemberDataScriptClass" favorites="True" /><memberdata name="fxmemberdatascriptclasslib" type="property" display="fxMemberDataScriptClassLib" favorites="True" /><memberdata name="fxmemberdatascriptmodule" type="property" display="fxMemberDataScriptModule" favorites="True" /><memberdata name="fxfeedbackclass" type="property" display="fxFeedbackClass" favorites="True" /><memberdata name="fxfeedbackclasslib" type="property" display="fxFeedbackClassLib" favorites="True" /><memberdata name="fxfeedbackmodule" type="property" display="fxFeedbackModule" favorites="True" /><memberdata name="getmemberdatascriptfxobject" type="method" display="getMemberDataScriptFXObject" favorites="True"/><memberdata name="getfeedbackfxobject" type="method" display="getFeedbackFXObject" favorites="True"/><memberdata name="classpath" type="property" display="classPath" favorites="True"/><memberdata name="getobjectinstance" type="method" display="getObjectInstance" favorites="True"/>
cancelrequested = .F.
classpath = ("")
ffcgraphics = (NULL)
frxcursor = (NULL)
fxfeedbackclass = ("fxTherm")
fxfeedbackclasslib = (THIS.ClassLibrary)
fxfeedbackmodule = ("")
fxmemberdatascriptclass = ("fxMemberDataScript")
fxmemberdatascriptclasslib = (THIS.ClassLibrary)
fxmemberdatascriptmodule = ("")
fxs = (NULL)
gfxnorenderclass = ("gfxNoRender")
gfxnorenderclasslib = (THIS.ClassLibrary)
gfxnorendermodule = ("")
gfxrotateclass = ("gfxRotate")
gfxrotateclasslib = (THIS.ClassLibrary)
gfxrotatemodule = ("")
gfxs = (NULL)
memberdataalias = ("M"+SYS(2015))
reportstartrundatetime = (DTOT({}))
reportstoprundatetime = (DTOT({}))
runcollectorresetlevel = 0
[END PROPERTIES]
[START PROTECTED]
checkcollectionmembers
createhelperobjects
creatememberdatacursor
ensurecollection
evaluateuserexpression
getfeedbackfxobject
getmemberdatascriptfxobject
getnorendergfxobject
getobjectinstance
getrotategfxobject
needgfxs
sendfx
uppermethodname
[END PROTECTED]
[START METHODS]
PROCEDURE AdjustObjectSize
LPARAMETERS m.nFRXRecno, m.oObjProperties
THIS.sendFX(PROGRAM(),m.nFRXRecno, m.oObjProperties)
NODEFAULT
IF (NOT ISNULL(THIS.Successor))
   THIS.SetSuccessorDynamicProperties()
   THIS.Successor.AdjustObjectSize(m.nFRXRecno, m.oObjProperties)
ENDIF
DODEFAULT(m.nFRXRecno, m.oObjProperties)
ENDPROC
PROCEDURE AfterBand
LPARAMETERS m.nBandObjCode, m.nFRXRecNo
THIS.sendFX(PROGRAM(),m.nBandObjCode, m.nFRXRecNo)  
NODEFAULT
RETURN DODEFAULT(m.nBandObjCode, m.nFRXRecNo)
ENDPROC
PROCEDURE AfterReport
THIS.sendFX(PROGRAM())  
NODEFAULT
RETURN DODEFAULT()

ENDPROC
PROCEDURE BeforeBand
LPARAMETERS m.nBandObjCode, m.nFRXRecNo
IF m.nBandObjCode = FRX_OBJCOD_PAGEHEADER  ;
   AND THIS.GFXs.Count > 0
   THIS.FFCGraphics.SetHandle(THIS.GDIPlusGraphics)
ENDIF
THIS.sendFX(PROGRAM(),m.nBandObjCode, m.nFRXRecNo)  
NODEFAULT
RETURN DODEFAULT(m.nBandObjCode, m.nFRXRecNo)
ENDPROC
PROCEDURE BeforeReport
THIS.setFRXDataSession()
IF (NOT THIS.IsSuccessor)
   THIS.createMemberDataCursor()  
   IF NOT ISNULL(THIS.successor)
      THIS.successor.AddProperty("memberDataAlias",THIS.memberDataAlias)
   ENDIF               
ENDIF       

* second opportunity to create FX and GFX objects,
* in case some are needed that were not needed before:
THIS.checkCollectionMembers(.T.)

* second opportunity to create non-optional helper members,
* in case some are needed that were not needed before,
* Any items that would have been required for
* FX/GFX-specific use should already have been created during
* LoadReport, so this set of calls is "backwards" 
* from LoadReport pairing:
THIS.createHelperObjects(.T.)

* note: at this point,
* the FX and GFX objects have 
* an opportunity to
* adjust items such as CallAdjustObjectSize, CallEvaluateContents, TwoPassProcess
THIS.sendFX(PROGRAM())  
NODEFAULT
RETURN DODEFAULT()

ENDPROC
PROCEDURE CancelReport
IF THIS.FXs.Count > 0
   THIS.sendFX(PROGRAM())  
   IF THIS.cancelRequested
      DODEFAULT()
   ELSE
      NODEFAULT
   ENDIF
ELSE
   DODEFAULT()
ENDIF      

ENDPROC
PROCEDURE ClearStatus
THIS.sendFX(PROGRAM())  


ENDPROC
PROCEDURE Destroy
STORE NULL TO THIS.FXs, THIS.GFXs, THIS.FFCGraphics, ;
      THIS.FRXCursor
DODEFAULT()
ENDPROC
PROCEDURE DoStatus
LPARAMETERS m.cMessage
THIS.sendFX(PROGRAM(),m.cMessage)  
NODEFAULT

ENDPROC
PROCEDURE EvaluateContents
LPARAMETERS m.nFRXRecno, m.oObjProperties
THIS.sendFX(PROGRAM(),m.nFRXRecno, m.oObjProperties)
NODEFAULT
IF (NOT ISNULL(THIS.Successor))
   THIS.SetSuccessorDynamicProperties()
   THIS.Successor.EvaluateContents(m.nFRXRecno, m.oObjProperties)
ENDIF
DODEFAULT(m.nFRXRecno, m.oObjProperties)
ENDPROC
PROCEDURE Init
IF DODEFAULT()
   THIS.AppName = OUTPUTFX_APPNAME_LOC
   THIS.Name = "FX" + SYS(2015)
   THIS.createHelperObjects()
   *&* THIS.getFeedbackFXObject(.T.)
ELSE
   RETURN .F.   
ENDIF

RETURN NOT THIS.hadError 
ENDPROC
PROCEDURE LoadReport
* always start with full reset for this run:
THIS.CallAdjustObjectSize = LISTENER_CALLDYNAMICMETHOD_NEVER
THIS.CallEvaluateContents = LISTENER_CALLDYNAMICMETHOD_NEVER
THIS.commandClausesFile = THIS.CommandClauses.File

* see notes in BeforeReport
THIS.createHelperObjects()
THIS.checkCollectionMembers()
THIS.setFRXDataSessionEnvironment() 
THIS.sendFX(PROGRAM())  

NODEFAULT
RETURN DODEFAULT() && these changes can be passed on to successors

ENDPROC
PROCEDURE Render
LPARAMETERS m.nFRXRecno, m.nLeft, m.nTop, m.nWidth, m.nHeight, ;
            m.nObjectContinuationType, m.cContentsToBeRendered, m.GDIPlusImage

LOCAL m.liDefaultBehavior,m.llNeedGFXs, m.lnState
       
m.llNeedGFXs = (NOT THIS.IsSuccessor) AND THIS.GFXs.Count > 0 AND ;
               THIS.NeedGFXs(PROGRAM(),m.nFRXRecno, m.nLeft, m.nTop, m.nWidth, m.nHeight, ;
               m.nObjectContinuationType, m.cContentsToBeRendered, m.GDIPlusImage)

IF m.llNeedGFXs
   THIS.FFCGraphics.SetHandle(THIS.GDIPlusGraphics)
   * done in BeforeBand for the page header
   * for GFX objects, in case they (for any reason) choose to
   * manipulate the page in other methods than Render.
   * but we'll do it again here.
   THIS.FFCGraphics.Save(@m.lnState)
ENDIF
          
m.liDefaultBehavior = ;
    THIS.sendFX(PROGRAM(),m.nFRXRecNo,;
                @m.nLeft,@m.nTop,@m.nWidth,@m.nHeight,;
                @m.nObjectContinuationType, ;
                @m.cContentsToBeRendered, @m.GDIPlusImage)
NODEFAULT

* note that FX objects get the args passed by reference, 
* however the GFX objects
* should not be seeking to change these args and 
* receive the args passed by value. Their
* job is to draw, not to change what is drawn by others or the base.
                   
DO CASE
       
CASE m.llNeedGFXs AND ;
     m.liDefaultBehavior = OUTPUTFX_BASERENDER_RENDER_BEFORE_RESTORE
     
     DODEFAULT( m.nFRXRecno, m.nLeft, m.nTop, m.nWidth, m.nHeight, ;
            m.nObjectContinuationType, m.cContentsToBeRendered, m.GDIPlusImage)
     THIS.FFCGraphics.Restore(m.lnState)

CASE m.llNeedGFXs AND ;
     m.liDefaultBehavior >= OUTPUTFX_BASERENDER_NORENDER
     THIS.FFCGraphics.Restore(m.lnState)                        
     IF (NOT ISNULL(THIS.Successor))
        THIS.SetSuccessorDynamicProperties()
        THIS.Successor.Render(m.nFRXRecno, m.nLeft, m.nTop, m.nWidth, m.nHeight, ;
             m.nObjectContinuationType, m.cContentsToBeRendered, m.GDIPlusImage)
     ENDIF
               
CASE m.llNeedGFXs && OUTPUTFX_BASERENDER_AFTERRESTORE, ;
                  && OUTPUTFX_DEFAULT_RENDER_BEHAVIOR

     THIS.FFCGraphics.Restore(m.lnState)
     DODEFAULT( m.nFRXRecno, m.nLeft, m.nTop, m.nWidth, m.nHeight, ;
                m.nObjectContinuationType, m.cContentsToBeRendered, m.GDIPlusImage)

OTHERWISE  && no GFX behavior at all, just base behavior

     DODEFAULT( m.nFRXRecno, m.nLeft, m.nTop, m.nWidth, m.nHeight, ;
                m.nObjectContinuationType, m.cContentsToBeRendered, m.GDIPlusImage)

ENDCASE

RETURN m.liDefaultBehavior
ENDPROC
PROCEDURE UnloadReport
THIS.sendFX(PROGRAM())  
THIS.CommandClauses.File = THIS.commandClausesFile 
THIS.commandClausesFile = NULL
RETURN DODEFAULT()

ENDPROC
PROCEDURE UpdateStatus
THIS.sendFX(PROGRAM())  
NODEFAULT

ENDPROC
PROCEDURE addcollectionmember
LPARAMETERS m.tcClass, m.tcClassLib,m.tcModule,m.tlSingleton, m.tlInGFX, m.tlRequired

LOCAL m.loX, m.lExists, m.liReturn

m.liReturn = OUTPUTFX_ADDCOLLECTION_NOACTION 

IF m.tlSingleton
  m.lExists =  THIS.checkCollectionForSpecifiedMember(m.tcClass,m.tcClassLib,m.tlInGFX)
ELSE
  * checkCollectionForSpecifiedMember will have done this already
  THIS.ensureCollection(m.tlInGFX)  
ENDIF

IF NOT m.lExists               
   m.loX = THIS.getObjectInstance(;
          m.tcClass,;
          m.tcClassLib,;
          m.tcModule, ;
         .T., IIF(tlInGFX,"GFX","FX"),tlRequired)
   IF ISNULL(m.loX)      
      m.liReturn = OUTPUTFX_ADDCOLLECTION_FAILURE
   ELSE
      IF (NOT PEMSTATUS(m.loX,"ApplyFX",5))
         m.liReturn = OUTPUTFX_ADDCOLLECTION_UNSUITABLE
      ELSE
         IF tlInGFX
            THIS.GFXs.Add(m.loX)         
         ELSE
            THIS.FXs.Add(m.loX)
         ENDIF            
         m.liReturn = OUTPUTFX_ADDCOLLECTION_SUCCESS
      ENDIF            
   ENDIF   

ENDIF   

RETURN m.liReturn

ENDPROC
PROCEDURE cancelrequested_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "L"
   THIS.cancelRequested = m.vNewVal
ENDIF   

ENDPROC
PROCEDURE checkcollectionforspecifiedmember
LPARAMETERS m.tcClass, m.tcClassLib, m.tlInGFX, m.tlReturnRef

LOCAL m.liIndex, m.loXs, m.loX, m.lcForceVCX, m.lcClassLib, ;
      m.lcClass, m.lcThisLib, m.llFound, m.loRef

THIS.ensureCollection(m.tlInGFX) 

IF m.tlInGFX
  m.loXs = THIS.GFXs
ELSE
   m.loXs = THIS.FXs
ENDIF   

m.loRef = NULL

m.lcClass = UPPER(m.tcClass)

IF NOT EMPTY(m.tcClassLib)
   m.lcClassLib = UPPER(JUSTFNAME(m.tcClassLib))
   m.lcForceVCX = FORCEEXT(lcClassLib,"VCX")
   m.lcForceFXP = STRTRAN(lcClassLib,".PRG",".FXP")
ENDIF   

FOR m.liIndex = 1 TO m.loXs.Count
   m.loX = loXs.Item(liIndex)
   m.lcThisLib = UPPER(JUSTFNAME(loX.ClassLibrary))
   IF UPPER(loX.Class) == m.lcClass AND ;
      (EMPTY(m.lcClassLib) OR ;
       m.lcThisLib == m.lcClassLib OR ;
       m.lcThisLib == m.lcForceVCX OR ;
       m.lcThisLib == m.lcForceFXP) 
       m.llFound = .T.
       m.loRef = m.loX
       EXIT
   ENDIF         
NEXT

IF m.tlReturnRef
   RETURN m.loRef
ELSE
   RETURN m.llFound
ENDIF   
ENDPROC
PROCEDURE checkcollectionmembers
LPARAMETERS m.tlCalledFromBeforeReport
* NB: use of this argument and 
* no distinction made between calls from
* BeforeReport and LoadReport at this level,
* this distinction is made available for subclasses
* that might not have all materials prepared for
* creation of required collection members during Load.

LOCAL m.liIndex, m.loX, m.loXs as Collection

THIS.getFeedbackFXObject()

THIS.getMemberDataScriptFXObject()

THIS.getRotateGFXObject()

THIS.getNoRenderGFXObject()

m.loXs = THIS.FXs

FOR m.liIndex = 1 TO THIS.FXs.Count
   m.loX = loXs.Item(m.liIndex)
   IF VARTYPE(m.loX) # "O" OR ;
     (NOT PEMSTATUS(m.loX,"ApplyFX",5))
     loXs.Remove(m.liIndex)
   ENDIF
NEXT

m.loXs = THIS.GFXs

FOR m.liIndex = 1 TO THIS.GFXs.Count
   m.loX = loXs.Item(liIndex)
   IF VARTYPE(m.loX) # "O" OR ;
     (NOT PEMSTATUS(m.loX,"ApplyFX",5))
     loXs.Remove(m.liIndex)
   ENDIF
NEXT

STORE NULL TO m.loX, m.loXs



ENDPROC
PROCEDURE classpath_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "C" AND ;
   DIRECTORY(m.vNewVal)
   IF NOT EMPTY(m.vNewVal)
      m.vNewVal = ADDBS(m.vNewVal)
   ENDIF
   THIS.classPath = m.vNewVal
ELSE
   THIS.ResetToDefault("classPath")   
ENDIF 

  

ENDPROC
PROCEDURE createhelperobjects
LPARAMETERS m.tlCalledFromBeforeReport
* see note in CheckCollectionMembers method about parameter, which
* is not used here but could provide significant information to
* subclasses

* NB this method creates only required helpers, not optional FX objects
* which is handled in CheckCollectionMembers
EXTERNAL CLASS _GDIPLUS.VCX
LOCAL liSession
m.liSession = SET("DATASESSION")
THIS.resetDataSession()
THIS.ensureCollection()
THIS.ensureCollection(.T.)
SET DATASESSION TO (m.liSession)
IF VARTYPE(THIS.FFCGraphics) # "O"  AND THIS.GFXs.Count > 0
   THIS.FFCGraphics =;
      THIS.getObjectInstance("GpGraphics","_GDIPlus.VCX","", .T.,"GP", .T.)
   IF NOT ISNULL(THIS.FFCGraphics)
      THIS.FFCGraphics.QuietOnError = THIS.QuietMode
   ENDIF      
ENDIF   
     

ENDPROC
PROCEDURE creatememberdatacursor

IF USED("FRX")
   SELECT FRX
   LOCATE FOR Platform = FRX_PLATFORM_WINDOWS AND NOT (EMPTY(Style) OR DELETED())
   IF  EOF() 
      THIS.loadFrxCursor = .F.
   ELSE
      THIS.loadFRXCursor = .T.
      DO CASE
      CASE (NOT THIS.loadFRXCursor) OR ISNULL(THIS.FRXCursor)
         * message already taken care of
      CASE PEMSTATUS(THIS.FRXCursor,"UnpackFRXMemberdata",5)
         THIS.FRXCursor.UnpackFRXMemberData("FRX",THIS.memberDataAlias,THIS.FRXDataSession)
      OTHERWISE
         THIS.DoMessage(OUTPUTFX_SCRIPTING_UNAVAILABLE_LOC ,MB_ICONEXCLAMATION)      
      ENDCASE
   ENDIF
ENDIF

ENDPROC
PROCEDURE ensurecollection
LPARAMETERS m.tlGFXs
IF m.tlGFXs
   IF VARTYPE(THIS.GFXs) # "O" OR ;
      (NOT UPPER(THIS.GFXs.BaseClass) == "COLLECTION")
      THIS.GFXs = CREATEOBJECT("Collection")
   ENDIF
ELSE
   IF VARTYPE(THIS.FXs) # "O" OR ;
      (NOT UPPER(THIS.FXs.BaseClass) == "COLLECTION")
      THIS.FXs = CREATEOBJECT("Collection")    
   ENDIF
ENDIF

ENDPROC
PROCEDURE evaluateuserexpression
LPARAMETERS m.tvValueExpr
LOCAL m.liSession, m.lvValue
m.lvValue = ""
m.liSession = SET("DATASESSION")
THIS.setCurrentDataSession()
IF TYPE(m.tvValueExpr) # "U"
   m.lvValue = EVALUATE(m.tvValueExpr)
ELSE
   THIS.setFRXDataSession()
   IF TYPE(m.tvValueExpr) # "U"
      m.lvValue = EVALUATE(m.tvValueExpr)
   ELSE
      THIS.resetDataSession()
      IF TYPE(m.tvValueExpr) # "U"
         m.lvValue = EVALUATE(m.tvValueExpr)
      ELSE
         IF TYPE ("THIS.CommandClauses.StartDatasession") = "N" AND ;
            THIS.CommandClauses.StartDatasession > 0 AND ;
            (THIS.CommandClauses.StartDatasession # THIS.ListenerDataSession)
            SET DATASESSION TO (THIS.CommandClauses.StartDataSession)
            IF TYPE(m.tvValueExpr) # "U"
               m.lvValue = EVALUATE(m.tvValueExpr)
            ENDIF
         ENDIF   
      ENDIF
   ENDIF
ENDIF
SET DATASESSION TO (m.liSession)
RETURN m.lvValue 
ENDPROC
PROCEDURE ffcgraphics_assign
LPARAMETERS m.tvNewVal
DO CASE
CASE ISNULL(m.tvNewVal) AND (NOT THIS.isRunning)
   THIS.FFCGraphics = m.tvNewVal
CASE VARTYPE(m.tvNewVal) = "O"
   LOCAL laDummy[1]
   IF ACLASS(laDummy,m.tvNewVal) > 0 AND ;
      ASCAN(laDummy,"GpGraphics",1,ALEN(laDummy),1, 7) > 0 && case insensitive, exact on
      THIS.FFCGraphics = m.tvNewVal
   ENDIF      
OTHERWISE
   * don't   
ENDCASE

ENDPROC
PROCEDURE frxcursor_access
IF (NOT THIS.IsRunning) AND ;
   ISNULL(THIS.frxCursor) AND THIS.loadFRXCursor
   THIS.frxCursor = ;
      THIS.getObjectInstance("FRXCursor","_FRXCURSOR.VCX","", .T.,"frx", .T.)
   IF ISNULL(THIS.frxCursor)
      THIS.loadFRXCursor = .F.
   ELSE
      THIS.frxCursor.QuietMode = THIS.QuietMode      
   ENDIF
ENDIF      
RETURN THIS.frxCursor

ENDPROC
PROCEDURE frxcursor_assign
LPARAMETERS m.vNewVal
IF ISNULL(m.vNewVal) OR (NOT THIS.IsRunning)
   THIS.frxcursor = m.vNewVal
ENDIF   

ENDPROC
PROCEDURE fxfeedbackclass_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "C" AND NOT EMPTY(m.vNewVal)
   THIS.fxFeedbackClass = m.vNewVal
ENDIF
ENDPROC
PROCEDURE fxfeedbackclasslib_assign
LPARAMETERS vNewVal
IF VARTYPE(m.vNewVal) = "C" AND NOT EMPTY(m.vNewVal)
   THIS.fxFeedbackClassLib = m.vNewVal
ENDIF   

ENDPROC
PROCEDURE fxfeedbackmodule_assign
LPARAMETERS vNewVal
IF VARTYPE(m.vNewVal) = "C" 
   THIS.fxFeedbackModule = m.vNewVal
ENDIF   

ENDPROC
PROCEDURE fxmemberdatascriptclass_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "C" AND NOT EMPTY(m.vNewVal)
   THIS.fxMemberDataScriptClass = m.vNewVal
ENDIF

ENDPROC
PROCEDURE fxmemberdatascriptclasslib_assign
LPARAMETERS vNewVal
IF VARTYPE(m.vNewVal) = "C" AND NOT EMPTY(m.vNewVal)
   THIS.fxMemberDataScriptClassLib = m.vNewVal
ENDIF   

ENDPROC
PROCEDURE fxmemberdatascriptmodule_assign
LPARAMETERS vNewVal
IF VARTYPE(m.vNewVal) = "C" 
   THIS.fxMemberDataScriptModule = m.vNewVal
ENDIF   

ENDPROC
PROCEDURE getfeedbackfxobject
LPARAMETERS m.tlQuiet


IF (NOT THIS.QuietMode) AND ;
   (NOT THIS.isSuccessor) AND ;
   (TYPE("THIS.CommandClauses.NoDialog") # "L" OR ;
    (NOT THIS.CommandClauses.NoDialog))

   THIS.addCollectionMember(;
         THIS.fxFeedbackClass,;
         THIS.fxFeedbackClassLib,;
         THIS.fxFeedbackModule, .T.)
      
   IF NOT THIS.checkCollectionForSpecifiedMember(;
          THIS.fxFeedbackClass,;
          THIS.fxFeedbackClassLib)
       IF NOT m.tlQuiet
          THIS.DoMessage(OUTPUTFX_USERFEEDBACK_UNAVAILABLE_LOC,MB_ICONEXCLAMATION)
       ENDIF       
       THIS.QuietMode = .T.
   ENDIF    

ENDIF   


ENDPROC
PROCEDURE getfrxrecno
LPARAMETERS m.tcMethodToken,m.tP1, m.tP2

LOCAL m.liFRXRecno, m.liSession

m.liFRXRecno = 0

DO CASE
CASE INLIST(m.tcMethodToken,"BEFOREREPORT","AFTERREPORT","LOADREPORT","UNLOADREPORT")
   IF THIS.frxHeaderRecno = -1
      * this is an early call. find the value early if possible
      m.liSession = SET("DATASESSION")
      THIS.setFRXDataSession()
      IF USED("FRX")
         SELECT FRX
         LOCATE FOR ObjType = FRX_OBJTYP_REPORTHEADER AND ;
                    Platform = FRX_PLATFORM_WINDOWS AND ;
                    NOT DELETED()
         THIS.frxHeaderRecno = RECNO()
      ELSE
         THIS.frxHeaderRecno = 1
      ENDIF
      SET DATASESSION TO (m.liSession)
   ENDIF   
   m.liFRXRecNo = THIS.frxHeaderRecno 
CASE INLIST(m.tcMethodToken,"BEFOREBAND","AFTERBAND") AND ;
     VARTYPE(m.tP2) = "N" && Band events
   m.liFRXRecNo = m.tP2          
CASE VARTYPE(m.tP1) = "N"  && Render, other events   
   m.liFRXRecNo = m.tP1
OTHERWISE
   * called inappropriately
ENDCASE

RETURN  m.liFRXRecno
ENDPROC
PROCEDURE getmemberdatascriptfxobject

THIS.setFRXDataSession()
IF USED(THIS.memberDataAlias) AND ;
   RECCOUNT(THIS.memberDataAlias) > 0
   SELECT (THIS.memberDataAlias)
   LOCATE FOR (NOT EMPTY(Execute))
   IF NOT EOF()
      THIS.addCollectionMember(;
           THIS.fxMemberDataScriptClass,;
           THIS.fxMemberDataScriptClassLib,;
           THIS.fxMemberDataScriptModule, .T.)
      IF NOT THIS.checkCollectionForSpecifiedMember(;
           THIS.fxMemberDataScriptClass,;
           THIS.fxMemberDataScriptClassLib)
           THIS.DoMessage(OUTPUTFX_SCRIPTING_UNAVAILABLE_LOC,MB_ICONEXCLAMATION)
      ENDIF
   ENDIF      
   IF USED("FRX")
      SELECT FRX
   ENDIF
ENDIF



ENDPROC
PROCEDURE getnorendergfxobject
IF NOT EMPTY(THIS.gfxNoRenderClass)
   LOCAL m.llNeedThisGFX, m.llOpenedMemberData
   THIS.setFRXDataSession()
   IF (NOT USED(THIS.memberDataAlias)) AND ;
      (NOT THIS.CommandClauses.IsDesignerLoaded) AND ;
      (NOT THIS.checkCollectionForSpecifiedMember(;
              THIS.gfxNoRenderClass,;
              THIS.gfxNoRenderClassLib, .T.))
      IF NOT USED("FRX") && during LoadReport
         IF FILE(THIS.CommandClauses.File)
            USE (THIS.CommandClauses.File) AGAIN SHARED NOUPDATE ALIAS FRX
            * this is a special situation, in that
            * this gfx needs to be available to do a swap
            * *before* memberdata is commonly available.
            * At this point, depending on what else has happened,
            * Memberdata may or may not be here. If it is not,
            * we could build the memberdata cursor here temporarily --
            * the gfx itself will do that, in fact -- but in this
            * method we're just ascertaining the requirement for
            * the gfx to *exist*.  This doesn't merit the extra time
            * to do an exact comparison of the appropriate memberdata
            * element.  If we might need it, the class should be 
            * instantiated.  Let it do the special build of memberdata
            * later and do its evaluations at that time.
            LOCATE FOR  FRX_BLDR_ADVPROP_PREPROCESS_NORENDER $ Style ;
                        AND NOT DELETED()
            m.llNeedThisGFX = (NOT EOF())
            USE IN FRX
         ELSE
            * built-into another app, just load without the check
            m.llNeedThisGFX = .T.
         ENDIF
         IF m.llNeedThisGFX
            THIS.loadFrxCursor = .T.
         ENDIF    
      ENDIF              
   ENDIF      
   IF (NOT m.llNeedThisGFX) AND ;
      USED(THIS.memberDataAlias) AND ;
      RECCOUNT(THIS.memberDataAlias) > 0
      * now we'll check in the normal way later in the report for
      * any required instance suppression, which occurs
      * later in the report cycle and can use the normal build
      * of memberdata
      SELECT (THIS.memberDataAlias)
      LOCATE FOR Type = FRX_BLDR_MEMBERDATATYPE AND ;
                 Name == FRX_BLDR_NAMESPACE_ADVANCEDPROPS AND ;
                 (ExecWhen == FRX_BLDR_ADVPROP_INSTANCE_NORENDER AND ;
                 NOT EMPTY(Execute))  OR ;
                 (ExecWhen == FRX_BLDR_ADVPROP_PREPROCESS_NORENDER)
      IF NOT EOF()
         m.llNeedThisGFX = .T.
      ENDIF
   ENDIF
   IF m.llNeedThisGFX
      THIS.addCollectionMember(;
           THIS.gfxNoRenderClass,;
           THIS.gfxNoRenderClassLib,;
           THIS.gfxNoRenderModule, .T., .T.)
      IF NOT THIS.checkCollectionForSpecifiedMember(;
           THIS.gfxNoRenderClass,;
           THIS.gfxNoRenderClassLib, .T.)
           THIS.DoMessage(OUTPUTFX_CONDITIONALRENDERING_UNAVAILABLE_LOC,MB_ICONEXCLAMATION)
      ENDIF
   ENDIF         
   IF USED("FRX")
      SELECT FRX
   ENDIF
ENDIF

ENDPROC
PROCEDURE getobjectinstance
LPARAMETERS m.tcClass, m.tcClassLib, m.tcModule, ;
            m.tlAssignUniqueNameToObject, ;
            m.tcNamePrefix, m.tlMandatoryObject

IF VARTYPE(m.tcClass) # "C" OR EMPTY(m.tcClass)
   IF m.tlMandatoryObject
      THIS.DoMessage(OUTPUTFX_REQUIREDOBJECTDEF_MISSING_LOC,MB_ICONEXCLAMATION)
   ENDIF
   RETURN NULL
ENDIF

LOCAL m.loX,m.lcForceVCX, m.lcForceFXP, m.lcUseThisLib, m.lcExternalsPath, m.liSession

liSession = SET("DATASESSION")
THIS.ResetDataSession()
m.lcForceVCX = FORCEEXT(m.tcClassLib,"VCX")
m.lcForceFXP = STRTRAN(m.tcClassLib,".PRG",".FXP")
m.lcExternalsPath = THIS.getPathForExternals()

m.loX = NULL

TRY 
   DO CASE
   CASE FILE(m.tcClassLib) OR ;
        FILE(m.lcForceVCX) OR ;
        ATC(FULLPATH(m.lcForceVCX) + " ALIAS ",SET("CLASSLIB")) > 0 OR ;
        ATC("\" + JUSTFNAME(m.lcForceVCX) + " ALIAS ",SET("CLASSLIB")) > 0 OR ;
        ATC(m.tcClassLib,SET("PROCEDURE")) > 0 OR ;
        ATC(m.lcForceFXP,SET("PROCEDURE")) > 0
        m.lcUseThisLib = m.tcClassLib
   CASE FILE(FORCEPATH(m.tcClassLib,m.lcExternalsPath)) OR ;
        FILE(FORCEPATH(m.lcForceVCX,m.lcExternalsPath)) OR ;
        FILE(FORCEPATH(m.lcForceFXP,m.lcExternalsPath)) 
        m.lcUseThisLib = FORCEPATH(m.tcClassLib,m.lcExternalsPath)
   CASE FILE(FORCEPATH(m.tcClassLib,HOME(0)+"FFC\")) OR ;
        FILE(FORCEPATH(m.lcForceVCX,HOME(0)+"FFC\")) 
        FILE(FORCEPATH(m.lcForceFXP,HOME(0)+"FFC\"))         
        m.lcUseThisLib = FORCEPATH(m.tcClassLib,HOME(0) + "FFC\") 
   CASE FILE(FORCEPATH(m.tcClassLib,HOME(0)+"FFC\" + THIS.classPath)) OR ;
        FILE(FORCEPATH(m.lcForceVCX,HOME(0)+"FFC\" + THIS.classPath)) 
        FILE(FORCEPATH(m.lcForceFXP,HOME(0)+"FFC\" + THIS.classPath))         
        m.lcUseThisLib = FORCEPATH(m.tcClassLib,HOME(0) + "FFC\" + THIS.classPath) 
   OTHERWISE
        m.lcUseThisLib = m.tcClassLib
        * may error, but if it's a required object,
        * it *should* error.
   ENDCASE 
             
   m.loX =  NEWOBJECT(m.tcClass, m.lcUseThisLib, ;
            IIF(VARTYPE(m.tcModule)="C",m.tcModule,""))          
   
   IF (NOT ISNULL(m.loX)) AND m.tlAssignUniqueNameToObject
      m.tcNamePrefix = IIF(VARTYPE(m.tcNamePrefix) = "C", ;
                            m.tcNamePrefix, "FXH")
      m.loX.Name = m.tcNamePrefix + SYS(2015)                         
   ENDIF   

CATCH TO err
   m.loX = NULL
   #IF OUTPUTCLASS_DEBUGGING 
       SUSPEND
   #ENDIF
ENDTRY

IF m.tlMandatoryObject AND ISNULL(m.loX)
   THIS.DoMessage(OUTPUTFX_REQUIREDOBJECT_UNAVAILABLE_LOC,MB_ICONEXCLAMATION)
ENDIF
SET DATASESSION TO (m.liSession)
RETURN m.loX
ENDPROC
PROCEDURE getpathforexternals
* this is  mostly for standalone use
* first figure out where to put it
* with the idea of not littering
* the disk too much based on CURDIR().
   
* For app pieces, look for a container module
* and put it there.
* if there isn't one,
* put it with the VCX
      
LOCAL m.liLevel, m.lcSys16, m.lcPath

IF ":" $ THIS.classPath
   * explicit path
   m.lcPath = THIS.classPath
ELSE
   FOR m.liLevel = PROGRAM(-1) TO 1 STEP -1
       m.lcSys16 = UPPER(SYS(16,m.liLevel))
      IF INLIST(RIGHT(m.lcSys16,3),"APP","EXE","DLL")
         m.lcPath = JUSTPATH(m.lcSys16)
         EXIT
      ENDIF
   ENDFOR
   IF (NOT EMPTY(lcPath)) AND ;
      (NOT EMPTY(THIS.classPath)) AND ;
       DIRECTORY(FULLPATH(THIS.classPath,ADDBS(lcPath)))
       m.lcPath = FULLPATH(THIS.classPath,ADDBS(lcPath))
   ENDIF
ENDIF   
      
IF EMPTY(m.lcPath)
   m.lcPath = JUSTPATH(THIS.ClassLibrary)
   IF (NOT EMPTY(lcPath)) AND ;
      (NOT EMPTY(THIS.classPath)) AND ;
       DIRECTORY(FULLPATH(THIS.classPath,ADDBS(lcPath)))
       m.lcPath = FULLPATH(THIS.classPath,ADDBS(lcPath))
   ENDIF
ENDIF

IF NOT DIRECTORY(m.lcPath)
   m.lcPath = ""
ELSE 
   m.lcPath = ADDBS(m.lcPath)   
ENDIF

RETURN m.lcPath
ENDPROC
PROCEDURE getrotategfxobject
THIS.setFRXDataSession()
IF USED(THIS.memberDataAlias) AND RECCOUNT(THIS.memberDataAlias) > 0
   SELECT (THIS.memberDataAlias)
   LOCATE FOR  Type = FRX_BLDR_MEMBERDATATYPE AND ;
               Name == FRX_BLDR_NAMESPACE_ROTATE AND ;
               NOT EMPTY(Execute)                    
   IF NOT EOF()
      THIS.addCollectionMember(;
           THIS.gfxRotateClass,;
           THIS.gfxRotateClassLib,;
           THIS.gfxRotateModule, .T., .T.)
      IF NOT THIS.checkCollectionForSpecifiedMember(;
           THIS.gfxRotateClass,;
           THIS.gfxRotateClassLib, .T.)
           THIS.DoMessage(OUTPUTFX_ROTATION_UNAVAILABLE_LOC,MB_ICONEXCLAMATION)
      ENDIF

   ENDIF      
   IF USED("FRX")
      SELECT FRX
   ENDIF
ENDIF

ENDPROC
PROCEDURE gfxnorenderclass_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "C" 
   THIS.gfxNoRenderClass = m.vNewVal
ENDIF

ENDPROC
PROCEDURE gfxnorenderclasslib_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "C" 
   THIS.gfxNoRenderClassLib = m.vNewVal
ENDIF

ENDPROC
PROCEDURE gfxnorendermodule_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "C" 
   THIS.gfxNoRenderModule = m.vNewVal
ENDIF

ENDPROC
PROCEDURE gfxrotateclass_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "C" AND NOT EMPTY(m.vNewVal)
   THIS.gfxRotateClass = m.vNewVal
ENDIF

ENDPROC
PROCEDURE gfxrotateclasslib_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "C" AND NOT EMPTY(m.vNewVal)
   THIS.gfxRotateClassLib = m.vNewVal
ENDIF

ENDPROC
PROCEDURE gfxrotatemodule_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "C" 
   THIS.gfxRotateModule = m.vNewVal
ENDIF

ENDPROC
PROCEDURE loadfrxcursor_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "L" AND NOT THIS.IsRunning
   THIS.loadfrxcursor = m.vNewVal
ENDIF   

ENDPROC
PROCEDURE memberdataalias_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "C" AND NOT EMPTY(m.vNewVal)
   THIS.memberDataAlias = m.vNewVal
ENDIF   

ENDPROC
PROCEDURE needgfxs
LPARAMETERS m.tcProgram,;
            m.tP1, m.tP2, m.tP3, m.tP4, m.tP5, m.tP6, ;
            m.tP7, m.tP8, m.tP8, m.tP10, m.tP11, m.tP12
* hook
* a subclass could evaluate conditions,
* such as whether any objects have custom properties
* requiring GFX activity.

RETURN .T.            
ENDPROC
PROCEDURE quietmode_assign
LPARAMETERS m.vNewVal
DODEFAULT(m.vNewVal)
IF THIS.loadFRXCursor AND (NOT ISNULL(THIS.FRXCursor))
   THIS.FRXCursor.QuietMode = THIS.QuietMode
ENDIF   
IF NOT ISNULL(THIS.FFCGraphics)
   THIS.FFCGraphics.QuietOnError = THIS.QuietMode
ENDIF      

   
ENDPROC
PROCEDURE removecollectionmember
LPARAMETERS m.tcName, m.tlInGFX, m.tlNameIsClass

LOCAL m.liIndex, m.loXs, m.loX, m.llFound, m.lcName

IF EMPTY(m.tcName) OR VARTYPE(m.tcName) # "C"
   RETURN .F.
ENDIF   

IF m.tlInGFX
  m.loXs = THIS.GFXs
ELSE
   m.loXs = THIS.FXs
ENDIF   

m.lcName = ALLTRIM(UPPER(m.tcName))

FOR m.liIndex = 1 TO m.loXs.Count
   m.loX = loXs.Item(liIndex)
   IF (UPPER(loX.Name) == m.lcName) OR ;
      (m.tlNameIsClass AND UPPER(loX.Class) == m.lcName)
       m.loXs.Remove(m.liIndex)
       m.llFound = .T.
       EXIT
   ENDIF         
NEXT

RETURN m.llFound
ENDPROC
PROCEDURE reportstartrundatetime_access
LOCAL m.lox, m.ldt
m.lox = THIS.checkCollectionForSpecifiedMember(;
      THIS.fxFeedbackClass, THIS.fxFeedbackClassLib,.f., .t.) 
IF (NOT ISNULL(m.lox)) AND PEMSTATUS(m.lox,"reportStartRunDatetime",5)
   m.ldt = m.lox.reportStartRunDateTime
ELSE
   m.ldt = THIS.reportStartRunDateTime   
ENDIF   
m.lox = NULL
RETURN m.ldt
   

ENDPROC
PROCEDURE reportstoprundatetime_access
LOCAL m.lox, m.ldt
m.lox = THIS.checkCollectionForSpecifiedMember(;
      THIS.fxFeedbackClass, THIS.fxFeedbackClassLib,.F., .T.) 
IF (NOT ISNULL(m.lox)) AND PEMSTATUS(m.lox,"reportStopRunDatetime",5)
   m.ldt = lox.reportStopRunDateTime
ELSE
   m.ldt = THIS.reportStopRunDateTime 
ENDIF   
m.lox = NULL
RETURN m.ldt
   

ENDPROC
PROCEDURE resetcalladjustobjectsize
* abstract, note that fx and gfx objects already
* have an opportunity via sendFX call.
ENDPROC
PROCEDURE resetcallevaluatecontents
* abstract, note that fx and gfx objects already
* have an opportunity via sendFX call.

ENDPROC
PROCEDURE runcollectorresetlevel_assign
LPARAMETERS tvNewVal
IF VARTYPE(m.tvNewVal) = "N" AND ;
   INLIST(m.tvNewVal,OUTPUTFX_RUNCOLLECTOR_RESET_NEVER , ;
                     OUTPUTFX_RUNCOLLECTOR_RESET_ONREPORT,;
                     OUTPUTFX_RUNCOLLECTOR_RESET_ONCHAIN)
   THIS.runCollectorResetLevel = m.tvNewVal
ENDIF   

ENDPROC
PROCEDURE sendfx
LPARAMETERS m.tcProgram, ;
            m.tP1, m.tP2, m.tP3, m.tP4, m.tP5, ;
            m.tP6, m.tP7, m.tP8, m.tP9, m.tP10, ;
            m.tP11, m.tP12)
  LOCAL m.loFX, m.liRenderBehavior, m.liTemp, m.lcMethodToken
  m.liRenderBehavior = OUTPUTFX_DEFAULT_RENDER_BEHAVIOR   
  IF THIS.IsSuccessor
     * Only the lead does this work.     
     RETURN m.liRenderBehavior
  ENDIF
  m.lcMethodToken = THIS.upperMethodName(m.tcProgram)  
  IF VARTYPE(THIS.FXs) = "O" AND THIS.FXs.Count > 0
     * The order of the 
     * invocation of this method,
     * which precedes the DODEFAULT()
     * in each event, 
     * makes the results available 
     * for all Successors.
     FOR EACH m.loFX IN THIS.FXs FOXOBJECT
         IF VARTYPE(m.loFX) = "O" && contract API is checked in LoadReport and BeforeReport
                                && but the object could release itself midway through a run
            THIS.setCurrentDataSession()                                
            m.loFX.ApplyFX(THIS,m.lcMethodToken, ;
                       @tP1, @tP2, @tP3, @tP4, @tP5, @tP6, ;
                       @tP7, @tP8, @tP9, @tP10, @tP11, @tP12)
         ENDIF              
      NEXT
  ENDIF
  IF VARTYPE(THIS.GFXs) = "O" AND THIS.GFXs.Count > 0 AND ;
     THIS.NeedGFXs(m.lcMethodToken,;
                   m.tP1, m.tP2, m.tP3, m.tP4, m.tP5, ;
                   m.tP6, m.tP7, m.tP8, m.tP9, m.tP10, ;
                   m.tP11, m.tP12)
      FOR EACH m.loFX IN THIS.GFXs FOXOBJECT
          IF VARTYPE(m.loFX) = "O" && contract API is checked in LoadReport and BeforeReport
                                   && but the object could release itself midway through a run          
             THIS.setCurrentDataSession()                                                                   
             m.liTemp = INT(VAL(TRANSFORM(m.loFX.ApplyFX(THIS, m.lcMethodToken, ;
                        @tP1, @tP2, @tP3, @tP4, @tP5, @tP6, ;
                        @tP7, @tP8, @tP9, @tP10, @tP11, @tP12))))
             IF m.liTemp > m.liRenderBehavior  && behavior is cumulative
                m.liRenderBehavior = INT(m.liTemp)
             ENDIF      
          ENDIF
      NEXT
  ENDIF
 RETURN m.liRenderBehavior  && this value only affects calls during Render method 


ENDPROC
PROCEDURE uppermethodname
LPARAMETERS m.tcProgram
LOCAL m.lcProgram
m.lcProgram = UPPER(TRANSFORM(m.tcProgram))
RETURN SUBSTR(m.lcProgram,RAT(".",m.lcProgram) + 1)      
ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*addcollectionmember Adds instance of specified class in specified class library  to FX or GFX collection. Params: tcClass, tcClassLib,tcModule,tlSingleton, tlInGFX, tlRequired
*cancelrequested_assign 
*checkcollectionforspecifiedmember Checks FX or GFX collection for instance of specified class by class and (if specified) by class library name. Returns logical (.F. if not found) or object reference (NULL if not found).
*checkcollectionmembers Eliminates members of FXs and GFXs collections in LoadReport and again in BeforeReport if they do not match required interfaces. Verifies availability of appropriate members.
*classpath_assign 
*createhelperobjects Creates FXs and GFXs collections, and additional required object members such as the FFCGraphics object.
*creatememberdatacursor Creates a cursor in the FRX datasession to hold extended information about FRX data rows.
*ensurecollection Ensures valid object collections for GFXs and FXs member references.
*evaluateuserexpression Attempts to evaluate a user-provided expression in various report run datasessions and return a valid result.
*ffcgraphics_assign 
*frxcursor_access 
*frxcursor_assign 
*fxfeedbackclass_assign 
*fxfeedbackclasslib_assign 
*fxfeedbackmodule_assign 
*fxmemberdatascriptclass_assign 
*fxmemberdatascriptclasslib_assign 
*fxmemberdatascriptmodule_assign 
*getfeedbackfxobject Instantiates FX object to provide user feedback.
*getfrxrecno Determine the current FRX cursor row number from the parameters passed to a ReportListener event.
*getmemberdatascriptfxobject Instantiates FX object to provide memberdata-based script handling.
*getnorendergfxobject Instantiates GFX object to provide memberdata-specified conditional baseclass rendering.
*getobjectinstance Provides a method for instancing classes as helper/member objects or FX/GFX collection members using specific path priorities.
*getpathforexternals Determines the location at which the current configuration table and any other required external files will be expected.
*getrotategfxobject Instantiates GFX object to provide memberdata-based rotation of layout controls.
*gfxnorenderclass_assign 
*gfxnorenderclasslib_assign 
*gfxnorendermodule_assign 
*gfxrotateclass_assign 
*gfxrotateclasslib_assign 
*gfxrotatemodule_assign 
*loadfrxcursor_assign 
*memberdataalias_assign 
*needgfxs Hook method to evaluate whether this method needs to call the GFXs collection members for rendering purposes.
*removecollectionmember Provides a way to remove an FX or GFX object from FXListener's collections by object instance name or class name.
*reportstartrundatetime_access 
*reportstoprundatetime_access 
*runcollectorresetlevel_assign 
*sendfx Applies FXs and GFXs collection members when an event or method is called.  Returns value to indicate how default render behavior should work when invoked during Render event.
*uppermethodname Passed a string such as PROGRAM(), returns an upper-case version of the method name with prefixes removed.  Utility method for use  when applying FX and GFX instructions.
cancelrequested Notification flag for FX objects to request a report cancellation.
classpath Provides optional location specifying path for loading objects from external libraries.
ffcgraphics A reference to an FFCGraphic object created during the run and provided to members of the GFXs collection. Validated as instance of GpGraphics from the FFC _GDIPLUS.VCX or a class derived from GpGraphics.
frxcursor Holds a reference to an FRXCursor helper object to aid in run-time calculations related to FRX metadata, structure, and memberdata.
fxfeedbackclass Class to instantiate in FX collection for user feedback (defaults to fxTherm).
fxfeedbackclasslib Class library from which to instantiate FX collection object providing user feedback.
fxfeedbackmodule Application module (APP or EXE)  from which to instantiate FX collection object providing user feedback.
fxmemberdatascriptclass Class to instantiate in FX collection for memberdata-based script handling (defaults to fxMemberDataScript).
fxmemberdatascriptclasslib Class library from which to instantiate FX collection object providing memberdata-based script-handling.
fxmemberdatascriptmodule Application module (APP or EXE)  from which to instantiate FX collection object providing memberdata-based script-handling.
fxs A collection of FX objects, required interface: PROCEDURE ApplyFX(toListener, tcMethodToken,tP1, tP2, tP3, tP4, tP5, tP6, tP7, tP8, tP9, tP10, tP11, tP12) Return value ignored
gfxnorenderclass Class to instantiate in GFX collection for conditionally eliminating baseclass rendering of various layout controls (defaults to gfxNoRender, if empty conditional rendering is turned off).
gfxnorenderclasslib Class library from which to instantiate GFX collection object providing conditional baseclass rendering.
gfxnorendermodule Application module (APP or EXE) from which to instantiate GFX collection object providing conditional baseclass rendering.
gfxrotateclass Class to instantiate in GFX collection for rotating layout controls (defaults to gfxRotate).
gfxrotateclasslib Class library from which to instantiate GFX collection object providing rotation.
gfxrotatemodule Application module (APP or EXE)  from which to instantiate GFX collection object providing rotation.
gfxs A collection of GFX objects, required interface: PROCEDURE ApplyFX(toListener, tcMethodToken,P1, tP2, tP3, tP4, tP5, tP6, tP7, tP8, tP9, tP10, tP11, tP12) Return value significant to Render method.
loadfrxcursor Determines whether this class should dynamically load an instance of the helper class FRXCursor when attempting to access a reference to it.
memberdataalias Alias of cursor holding memberdata in the FRXDataSession, read from the FRX table's Style field for easy access by other objects.
reportstartrundatetime A datetime value indicating when the last report generation run began, if the feedback member object has been instantiated and provides a property with a matching name. Readonly.
reportstoprundatetime A datetime value for use at the conclusion of a report run, storing when the last report generation run ended, if the feedback member object has been instantiated and provides a property with a matching name. Readonly.
runcollectorresetlevel Indicates how often the runCollector member should be automatically reset by the reportListener (0=never, 1=after each report, 2=after a chained report run).
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED7]
ReportListener supplying the means to decorate base report content during a report run, using two member collections: FXs (adjust content and format instructions) and GFXs (adjust or replace GDIPlus-graphics rendering).[END RESERVED7]
[START RESERVED8]
reportlisteners.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] fxlistener

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1PQ0P76WP
[CLASS] fxabstract
[CLASSLOC] listener.vcx
[BASECLASS] custom
[OBJNAME] fxmemberdatascript
[START PROPERTIES]
Name = "fxmemberdatascript"
_memberdata =      783<VFPData><memberdata name="applyfx" type="property" display="applyFX" favorites="True"/><memberdata name="gatherscripts" type="method" display="gatherScripts"/><memberdata name="processmemberdatascript" type="method" display="processMemberDataScript"/><memberdata name="processdynamicmethodscript" type="method" display="processDynamicMethodScript"/><memberdata name="usememberdata" type="method" display="useMemberData"/><memberdata name="scriptalias" display="scriptAlias" type="property"/><memberdata name="adjustdynamiccalls" type="method" display="adjustDynamicCalls"/><memberdata name="removescriptonfailure" display="removeScriptOnFailure" type="property" favorites="True"/><memberdata name="findparametersstatement" type="method" display="findParametersStatement"/></VFPData>
removescriptonfailure = .T.
scriptalias = ("S"+SYS(2015))
[END PROPERTIES]
[START PROTECTED]
adjustdynamiccalls
findparametersstatement
gatherscripts
processdynamicmethodscript
processmemberdatascript
scriptalias
usememberdata
[END PROTECTED]
[START METHODS]
PROCEDURE adjustdynamiccalls
LPARAMETERS m.toListener

* change m.toListener.CallEvaluateContents and 
* m.toListener.CallAdjustObjectSize if necessary

SET DATASESSION TO (m.toListener.FRXDataSession)

IF INLIST(m.toListener.callEvaluateContents,;
          LISTENER_CALLDYNAMICMETHOD_CHECK_CODE,;
          LISTENER_CALLDYNAMICMETHOD_NEVER) 

   SELECT FRX    
   GO TOP
   SCAN FOR ObjType = FRX_OBJTYP_FIELD AND Platform = FRX_PLATFORM_WINDOWS
      IF THIS.useMemberData(RECNO())
         SELECT (THIS.scriptAlias)
         IF ATC("EvaluateContents",ExecWhen) > 0 OR ;
            ATC("EvaluateContents",Execute) > 0 OR ;
            (NOT EMPTY(UserScript))
            * UserScript for a Field-type item
            * has to be EvaluateContents
            m.toListener.callEvaluateContents = LISTENER_CALLDYNAMICMETHOD_ALWAYS
            EXIT
         ENDIF
      ENDIF    
      SELECT FRX
   ENDSCAN

ENDIF          
   
IF INLIST(m.toListener.callAdjustObjectSize,;
          LISTENER_CALLDYNAMICMETHOD_CHECK_CODE,;
          LISTENER_CALLDYNAMICMETHOD_NEVER) 

   SELECT FRX    
   GO TOP
   SCAN FOR Platform = FRX_PLATFORM_WINDOWS AND INLIST(ObjType,FRX_OBJTYP_LINE,FRX_OBJTYP_RECTANGLE,FRX_OBJTYP_PICTURE)          
      IF THIS.useMemberData(RECNO())
         SELECT (THIS.scriptAlias)
         IF ATC("AdjustObjectSize",ExecWhen) > 0 OR ;
            ATC("AdjustObjectSize",Execute) > 0 OR ;
            (NOT EMPTY(UserScript))
            * UserScript for a Shape-Picture-type item
            * has to be AdjustObjectSize
            m.toListener.callAdjustObjectSize = LISTENER_CALLDYNAMICMETHOD_ALWAYS
            EXIT
         ENDIF
      ENDIF    
      SELECT FRX
   ENDSCAN

ENDIF          

ENDPROC
PROCEDURE applyfx
LPARAMETERS m.toListener, m.tcMethodToken,;
            m.tP1, m.tP2, m.tP3, m.tP4, m.tP5, m.tP6, ;
            m.tP7, m.tP8, m.tP9, m.tP10, m.tP11, m.tP12
TRY
   IF m.toListener.FRXDataSession > 0
      SET DATASESSION TO (m.toListener.FRXDataSession)
   ENDIF      

   LOCAL m.liFRXRecno

   IF m.tcMethodToken == "BEFOREREPORT"
      THIS.gatherScripts(m.toListener)
      THIS.adjustDynamicCalls(m.toListener)
   ENDIF
   
   IF m.toListener.FRXDataSession > 0
      SET DATASESSION TO (m.toListener.FRXDataSession)
   ENDIF

   m.liFRXRecno = m.toListener.getFRXRecno(m.tcMethodToken,m.tP1, m.tP2)

   IF USED("FRX") AND m.liFRXRecno > 0
      GO (m.liFRXRecno) IN FRX
   ENDIF
            
   IF THIS.useMemberData(m.liFRXRecno)
      THIS.processMemberDataScript(m.toListener, m.tcMethodToken,;
               @m.tP1, @m.tP2, @m.tP3, @m.tP4, @m.tP5, @m.tP6, ;
               @m.tP7, @m.tP8, @m.tP9, @m.tP10, @m.tP11, @m.tP12)
      IF INLIST(m.tcMethodToken,"EVALUATECONTENTS","ADJUSTOBJECTSIZE")
         THIS.processDynamicMethodScript(m.toListener,m.tP1, m.tP2)
      ENDIF  
   ENDIF    
   
   IF m.toListener.FRXDataSession > 0
      SET DATASESSION TO (m.toListener.FRXDataSession)
   ENDIF
   IF USED("FRX")
      SELECT FRX        
   ENDIF      
   SET DATASESSION TO (m.toListener.ListenerDataSession)

CATCH TO err

   #IF OUTPUTCLASS_DEBUGGING 
       SUSPEND
   #ENDIF
   
ENDTRY            

ENDPROC
PROCEDURE findparametersstatement
LPARAMETERS m.tcScript
LOCAL laLines[1], liLine, lcLine, llFound
IF VARTYPE(m.tcScript) = "C" AND NOT EMPTY(m.tcScript) 
   FOR m.liLine = 1 TO ALINES(laLines,CHRTRAN(m.tcScript,CHR(10),CHR(13)),1+4,CHR(13))
      m.lcLine = ALLTRIM(UPPER(m.laLines[liLine]))
      DO CASE
      CASE LEFT(m.lcLine,1) == "*" OR LEFT(m.lcLine,2) == REPLICATE(CHR(38),2)
         * skip leading comments
      CASE BETWEEN(ATC("PARAM",m.lcLine),1,2)
         m.llFound = .T.
         EXIT
      OTHERWISE
         EXIT
      ENDCASE
   ENDFOR
ENDIF   

RETURN m.llFound 
ENDPROC
PROCEDURE gatherscripts
LPARAMETERS m.toListener
LOCAL lcTemp1, lcTemp2, lcTemp3, liSelect
SET DATASESSION TO (m.toListener.FRXDataSession)
m.liSelect = SELECT(0)
SELECT 0
CREATE CURSOR (THIS.scriptAlias) ;
   (FRXRecno i, ExecWhen M, Execute M, UserScript M)
IF USED(m.toListener.MemberDataAlias) AND ;
   RECCOUNT(m.toListener.MemberDataAlias) > 0
   SELECT FRX   
   GO TOP
   SCAN FOR Platform = FRX_PLATFORM_WINDOWS AND NOT EMPTY(Style)
      SELECT (m.toListener.MemberDataAlias)
      LOCATE FOR FRXRecno = RECNO("FRX") AND ;
         EMPTY(Name) AND Type = FRX_BLDR_MEMBERDATATYPE   
      m.lcTemp1 = ExecWhen         
      m.lcTemp2 = Execute         
      m.lcTemp3 = ""
      IF NOT EMPTY(m.lcTemp2)
         IF NOT THIS.findParametersStatement(m.lcTemp2)
            * add a parameters statement
            m.lcTemp2 =  "LPARAMETERS toFX, toListener, tcMethodToken,;"+ CHR(13) + CHR(10) + ;
                         "tP1, tP2, tP3, tP4, tP5, tP6,"+;
                         "tP7, tP8, tP9, tP10, tP11, tP12" + CHR(13) + CHR(10) + ;
                         m.lcTemp2  
         ENDIF            
      ENDIF        
      DO CASE
      CASE INLIST(FRX.ObjType,FRX_OBJTYP_LINE,FRX_OBJTYP_RECTANGLE,FRX_OBJTYP_PICTURE)
          LOCATE FOR FRXRecno = RECNO("FRX") AND ;
                     Type = FRX_BLDR_MEMBERDATATYPE   AND ;
                     Name == FRX_BLDR_NAMESPACE_ADJUSTOBJECTSIZE 
          IF NOT EOF()           
             m.lcTemp3 = ;
               m.toListener.FRXCursor.GenerateAdjustObjectSizeScript("frx",m.toListener.MemberDataAlias,m.toListener.FRXDataSession)
          ENDIF               
      CASE FRX.ObjType = FRX_OBJTYP_FIELD 
          LOCATE FOR FRXRecno = RECNO("FRX") AND ;
                     Type = FRX_BLDR_MEMBERDATATYPE   AND ;
                     Name == FRX_BLDR_NAMESPACE_EVALUATECONTENTS
          IF NOT EOF()           
             m.lcTemp3 = ;          
               m.toListener.FRXCursor.GenerateEvaluateContentsScript("frx",m.toListener.MemberDataAlias,m.toListener.FRXDataSession)         
          ENDIF               
      OTHERWISE
          m.lcTemp3 = ""
      ENDCASE            
      SET DATASESSION TO (m.toListener.FRXDataSession)      
      IF NOT EMPTY(m.lcTemp1 + m.lcTemp2 + m.lcTemp3)
         INSERT INTO (THIS.scriptAlias) ;
            VALUES (RECNO("FRX"),m.lcTemp1, m.lcTemp2, m.lcTemp3)
      ENDIF                   
      SELECT FRX      
   ENDSCAN
  
ENDIF

SELECT (THIS.scriptAlias)
INDEX ON FrxRecno TAG FrxRecno
   
SELECT (m.liSelect)

ENDPROC
PROCEDURE processdynamicmethodscript
LPARAMETERS m.toListener,  m.tnFRXRecno, m.toProps 
* we are already positioned on the correct MemberData record
* in the script alias and in the FRXDataSession
* by the calling method.
IF (NOT EOF(THIS.scriptAlias))
   LOCAL lcScript
   m.lcScript = EVALUATE(THIS.scriptAlias + ".UserScript" ) 
   IF NOT EMPTY(m.lcScript)
      TRY
         EXECSCRIPT(m.lcScript,m.toListener, m.tnFRXRecno, m.toProps )
      CATCH TO err
         IF THIS.removeScriptOnFailure AND ;
            (m.toListener.FRXDataSession > 0)
             SET DATASESSION TO (m.toListener.FRXDataSession)
             REPLACE UserScript WITH "" IN (THIS.scriptAlias)
         ENDIF
         #IF OUTPUTCLASS_DEBUGGING 
             SUSPEND
         #ENDIF
      FINALLY
         IF m.toListener.FRXDataSession > 0
            SET DATASESSION TO (m.toListener.FRXDataSession)
         ENDIF
      ENDTRY
   ENDIF
ENDIF
ENDPROC
PROCEDURE processmemberdatascript
LPARAMETERS m.toListener, m.tcMethodToken,;
            m.tP1, m.tP2, m.tP3, m.tP4, m.tP5, m.tP6, ;
            m.tP7, m.tP8, m.tP9, m.tP10, m.tP11, m.tP12
            
* we are already positioned on the correct MemberData record
* in the FRXDataSession in the script alias
* by the calling method.
IF (NOT EOF(THIS.scriptAlias))
   LOCAL llExecute, lcExecute, lcExecWhen
   m.lcExecute = EVALUATE(THIS.scriptAlias + ".Execute")
   m.lcExecWhen = EVALUATE(THIS.scriptAlias + ".ExecWhen")
   SET DATASESSION TO (m.toListener.CurrentDataSession)
   DO CASE
   CASE EMPTY(m.lcExecute)
       * nothing to execute
   CASE EMPTY(m.lcExecWhen)
       * always execute
       m.llExecute = .T.
   CASE UPPER(m.lcExecWhen)== m.tcMethodToken
        * simple event evaluation
        * ExecWhen contains an event name
        * Note that each event, via script,
        * could potentially change the contents of
        * ExecWhen to hold another value (the next
        * event during which this script should be evaluated)
        m.llExecute = .T.
   CASE (TYPE(m.lcExecWhen) = "L") AND ;
        EVALUATE(m.lcExecWhen)
        * ExecWhen contains a logical expression to be evaluated
        m.llExecute = .T.
   CASE ATC("|"+m.tcMethodToken+"|","|" + m.lcExecWhen + "|") > 0
        * ExecWhen contains a delimited string of events
        m.llExecute = .T.
   ENDCASE

   IF m.llExecute 
      TRY
         ExecScript(m.lcExecute,;
                    THIS, m.toListener, m.tcMethodToken,;
                    @tP1, @tP2, @tP3, @tP4, @tP5, @tP6, ;
                    @tP7, @tP8, @tP9, @tP10, @tP11, @tP12)
      CATCH TO err
         IF THIS.removeScriptOnFailure AND ;
            (m.toListener.FRXDataSession > 0)
             SET DATASESSION TO (m.toListener.FRXDataSession)
             REPLACE Execute WITH "" IN (THIS.scriptAlias)
         ENDIF      
         #IF OUTPUTCLASS_DEBUGGING 
             SUSPEND
         #ENDIF
      ENDTRY                    
   ENDIF
   IF m.toListener.FRXDataSession > 0
      SET DATASESSION TO (m.toListener.FRXDataSession)
   ENDIF      
ENDIF   



ENDPROC
PROCEDURE removescriptonfailure_assign
LPARAMETERS vNewVal
IF VARTYPE(m.vNewVal) = "L"
   THIS.removeScriptOnFailure = m.vNewVal
ENDIF   

ENDPROC
PROCEDURE usememberdata
LPARAMETERS m.tiFRXRecno

LOCAL m.llUseMemberData, m.liSelect

IF (m.tiFRXRecno > 0) 
   IF USED(THIS.scriptAlias) 
      m.liSelect = SELECT(0)
      SELECT (THIS.scriptAlias)
      m.llUseMemberData = ;
         SEEK(m.tiFRXRecno,THIS.scriptAlias,"FRXRecno") 
      SELECT (m.liSelect)    
   ENDIF
ENDIF

RETURN m.llUseMemberData

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*adjustdynamiccalls Ensures that dynamic method calls are made if there is relevant MemberData script attached to them.
*findparametersstatement Checks FX scripts for a parameter statement as required for ApplyFX() method.
*gatherscripts Sets up script elements at the beginning of a report run.
*processdynamicmethodscript Processes specialized MemberData rows for the current layout control for dynamic methods EvaluateContents and AdjustObjectSize.
*processmemberdatascript Executes MemberData script from the main MemberData row for the current FRX layout element.
*removescriptonfailure_assign 
*usememberdata Evaluates whether the current event and the current FRX layout element have MemberData that this class can process and positions the MemberData and Scripting cursors appropriately.
removescriptonfailure Indicates whether any script failure should remove the  failed script for the balance of the report run. If .F., this script continues to be executed for additional report events and errors are handled silently. Defaults to .T.. 
scriptalias The alias of a cursor holding script information during the report run.
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED7]
Executes script stored in FRX Memberdata, reading it from a cursor in the FRX datasession.[END RESERVED7]
[START RESERVED8]
reportlisteners.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] fxmemberdatascript

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1Q20UZXVD
[CLASS] fxabstract
[CLASSLOC] listener.vcx
[BASECLASS] custom
[OBJNAME] fxresetpagetotal
[START PROPERTIES]
Name = "fxresetpagetotal"
_memberdata =      524<VFPData><memberdata name="applyfx" type="property" display="applyFX" favorites="True"/><memberdata name="dothisrun" type="property" display="doThisRun" favorites="True"/><memberdata name="oldpass" type="property" display="oldPass"/> <memberdata name="resetcount" type="property" display="resetCount"/><memberdata name="resetalias" type="property" display="resetAlias"/><memberdata name="dobeforeband" type="method" display="doBeforeBand"/><memberdata name="dobeforereport" type="method" display="doBeforeReport"/></VFPData>
dothisrun = .F.
oldpass = 0
resetalias = ("GR"+SYS(2015))
resetcount = 0
[END PROPERTIES]
[START PROTECTED]
dobeforeband
dobeforereport
dothisrun
oldpass
resetalias
resetcount
[END PROTECTED]
[START METHODS]
PROCEDURE applyfx
LPARAMETERS m.toListener, m.tcMethodToken, ;
            m.tP1, m.tP2, m.tP3, m.tP4, m.tP5, m.tP6,   ;
            m.tP7, m.tP8, m.tP9, m.tP10, m.tP11, m.tP12
            
DO CASE
   CASE m.tcMethodToken == "BEFOREREPORT" AND ;
        TYPE("_ResetPageTotal") # "U"
       * we can turn on behavior explicitly
        toListener.TwoPassProcess = .T.
        THIS.doThisRun = .T.
        THIS.doBeforeReport(toListener)
   CASE m.tcMethodToken == "BEFOREREPORT" AND ;
       (TYPE("_ResetPageTotal") = "U")
        THIS.doThisRun = .F.
   CASE NOT THIS.DoThisRun          
        * do nothing
   CASE m.tcMethodToken == "BEFOREBAND"
        THIS.doBeforeBand(toListener,tP1)          
   OTHERWISE
        * do nothing
ENDCASE
   
                        

ENDPROC
PROCEDURE dobeforeband
LPARAMETERS m.toListener,m.tnBandCode

LOCAL m.liSession, m.liSelect
IF m.tnBandCode = 1 && pageheader
   m.liSession = SET("DATASESSION")
   SET DATASESSION TO (m.toListener.FRXDataSession )
   liSelect = SELECT(0)      
   SELECT (THIS.resetAlias)
   IF _PAGENO = 1 && user reset occurred
      IF THIS.oldPass = 0 AND toListener.CurrentPass = 1
         * we're entering the rendering pass
         THIS.resetCount = 1
         THIS.oldPass = 1
         IF TYPE("_ReportPageTotal") = "N"
            CALCULATE SUM(ResetPageTotal) TO _ReportPageTotal
         ENDIF
      ELSE
         THIS.resetCount = THIS.resetCount + 1       
      ENDIF
      IF m.toListener.CurrentPass = 0 
         INSERT INTO (THIS.resetAlias) VALUES (THIS.ResetCount, 1)
      ENDIF          
   ELSE
      * we're not starting a set of page numbers,
      * so we need to keep track of the pages in 
      * this particular group.
      IF m.toListener.CurrentPass = 0
         SEEK THIS.ResetCount 
         REPLACE ResetPageTotal WITH ResetPageTotal + 1 
      ENDIF              
   ENDIF
   IF m.toListener.CurrentPass = 1
      * make the current group's page total available
      * for display/output
      SEEK THIS.ResetCount 
      _ResetPageTotal = ResetPageTotal
      _ReportPageNo = m.toListener.PageNo && don't even worry about whether the var has been declared
   ENDIF
   SELECT (m.liSelect)
   SET DATASESSION TO (m.toListener.CurrentDataSession)
ENDIF     

ENDPROC
PROCEDURE dobeforereport
LPARAMETERS m.toListener
LOCAL liSession, liSelect
liSession = SET("DATASESSION")
SET DATASESSION TO (m.toListener.FRXDataSession )
liSelect = SELECT(0)      
SELECT 0
CREATE CURSOR (THIS.resetAlias) (ResetsNo i, ResetPageTotal i)
INDEX ON ResetsNo TAG Resets
THIS.resetCount = 0
THIS.oldPass = 0
_ResetPageTotal = 0
SELECT (liSelect)
SET DATASESSION TO (m.toListener.CurrentDataSession)

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*dobeforeband Accumulates page counts into the ResetAlias cursor as the report run progresses.
*dobeforereport Initializes page count activity at the start of a report run.
dothisrun Holds assessment of whether this object must perform its function during the current report run.
oldpass Internal processing variable.
resetalias Alias of cursor used to accumulate page counts for groups.
resetcount Internal processing variable.
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED7]
Provides page count & total in any report. Runs if _ResetPageTotal var exists, also fills vars _ReportPageNo & _ReportPageTotal if available. Results are similar to system variables _PAGENO & _PAGETOTAL, but accurate in reports that reset _PAGENO on band.[END RESERVED7]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] fxresetpagetotal

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1L50OW0FK
[CLASS] form
[BASECLASS] form
[OBJNAME] fxtherm
[START PROPERTIES]
</VFPDATA>
<memberdata name="percentdone" type="property" display="percentDone" favorites="False" /> <memberdata name="currentrecord" type="property" display="currentRecord" favorites="False" /><memberdata name="designateddriver" type="property" display="designatedDriver" favorites="False" /> <memberdata name="drivingaliascurrentrecno" type="property" display="drivingAliasCurrentRecno" favorites="False" /> <memberdata name="escapereference" type="property" display="escapeReference" favorites="False" /> <memberdata name="frxbandrecno" type="property" display="frxBandRecno" favorites="False" /> <memberdata name="getparentwindowref" type="method" display="getParentWindowRef" favorites="False" /> <memberdata name="getreportscopedriver" type="method" display="getReportScopeDriver" favorites="False"/><memberdata name="includeseconds" type="property" display="includeSeconds" favorites="True" /> <memberdata name="initstatustext" type="property" display="initStatusText" favorites="True" /> <memberdata name="onescapecommand" type="property" display="onEscapeCommand" favorites="False" /> <memberdata name="prepassstatustext" type="property" display="prepassStatusText" favorites="True" /> <memberdata name="reportstartrundatetime" type="property" display="reportStartRunDatetime" favorites="True" /> <memberdata name="reportstoprundatetime" type="property" display="reportStopRunDatetime" favorites="True" /> <memberdata name="resetuserfeedback" type="method" display="resetUserFeedback" favorites="False" /> <memberdata name="runstatustext" type="property" display="runStatusText" favorites="True" /> <memberdata name="secondstext" type="property" display="secondsText" favorites="True" /> <memberdata name="setescape" type="property" display="setEscape" favorites="False" /> <memberdata name="setnotifycursor" type="property" display="setNotifyCursor" favorites="False" /> <memberdata name="setthermformcaption" type="method" display="setThermformCaption" favorites="False" /> <memberdata name="thermcaption" type="property" display="thermCaption" favorites="True" /> <memberdata name="thermform" type="property" display="thermForm" favorites="False" /> <memberdata name="thermformcaption" type="property" display="thermFormCaption" favorites="True" /> <memberdata name="thermformheight" type="property" display="thermFormHeight" favorites="True" /> <memberdata name="thermformwidth" type="property" display="thermFormWidth" favorites="True" /> 
<memberdata name="thermprecision" type="property" display="thermPrecision" favorites="True" /> <memberdata name="thermmargin" type="property" display="thermMargin" favorites="True" /> <memberdata name="synchstatus" type="method" display="synchStatus" favorites="False" /><memberdata name="successorsys2024" type="property" display="successorSys2024" favorites="False" /><memberdata name="dostatus" type="method" display="doStatus" favorites="True" /><memberdata name="clearstatus" type="method" display="clearStatus" favorites="True" /><memberdata name="updatestatus" type="method" display="updateStatus" favorites="True" /><memberdata name="pushuserfeedbackglobalsets" display="pushUserFeedbackGlobalSets" type="method"/><memberdata name="popuserfeedbackglobalsets" display="popUserFeedbackGlobalSets" type="method"/><memberdata name="synchuserinterface" display="synchUserInterface" type="method"/><memberdata name="setupreport" type="method" display="setupReport"/><memberdata name="drivingalias" type="method" display="drivingAlias"/><memberdata name="persistbetweenruns" display="persistBetweenRuns" type="property" favorites="True"/>
AllowOutput = .F.
AlwaysOnTop = .T.
AutoCenter = .T.
BorderStyle = 2
Caption = "ThermForm"
ControlBox = .F.
DoCreate = .T.
HalfHeightCaption = .T.
Height = 40
MaxButton = .F.
MinButton = .F.
Name = "fxtherm"
Width = 356
_memberdata =     3665<VFPDATA><memberdata name="applyfx" display="applyFX" type="method"/>
currentrecord = (0)
designateddriver = ("")
drivingalias = ("")
drivingaliascurrentrecno = (0)
escapereference = ("")
frxbandrecno = (0)
includeseconds = .T.
initstatustext = ("")
isrunning = .F.
onescapecommand = ("")
percentdone = (0)
persistbetweenruns = .F.
prepassstatustext = ("")
reportstartrundatetime = (DTOT({}))
reportstoprundatetime = (DTOT({}))
runstatustext = ("secs")
secondstext = ("")
setescape = .F.
setnotifycursor = .F.
successorsys2024 = ("N")
thermcaption =      284[m.cMessage+ " "+ TRANSFORM(THIS.PercentDone,"999"+IIF(THIS.ThermPrecision=0,"","."+REPL("9",THIS.ThermPrecision))) + "%" + IIF(NOT THIS.IncludeSeconds, "" , " "+TRANSFORM(IIF(THIS.IsRunning,DATETIME(), THIS.ReportStopRunDateTime)-THIS.ReportStartRunDateTime)+" " + THIS.SecondsText)]
thermformcaption = ("")
thermformheight = (40)
thermformwidth = (356)
thermmargin = (5)
thermprecision = (2)
[END PROPERTIES]
[START PROTECTED]
currentrecord
designateddriver
drivingalias
drivingaliascurrentrecno
escapereference
frxbandrecno
getparentwindowref
getreportscopedriver
isrunning
onescapecommand
percentdone
popuserfeedbackglobalsets
pushuserfeedbackglobalsets
resetuserfeedback
setescape
setnotifycursor
setthermformcaption
setupreport
successorsys2024
synchstatus
synchuserinterface
[END PROTECTED]
[START METHODS]
PROCEDURE Init
THIS.Name = "X"+SYS(2015)
WITH THIS
     .InitStatusText = OUTPUTCLASS_INITSTATUS_LOC
     .PrepassStatusText = OUTPUTCLASS_PREPSTATUS_LOC
     .RunStatusText =  OUTPUTCLASS_RUNSTATUS_LOC
     .SecondsText = OUTPUTCLASS_TIME_SECONDS_LOC
     .thermCaption = OUTPUTCLASS_THERMCAPTION_LOC     
     .resetUserFeedback()
ENDWITH



ENDPROC
PROCEDURE Load

            
ENDPROC
PROCEDURE applyfx
LPARAMETERS m.toListener, m.tcMethodToken,;
            m.tP1, m.tP2, m.tP3, m.tP4, m.tP5, m.tP6, ;
            m.tP7, m.tP8, m.tP9, m.tP10, m.tP11, m.tP12

LOCAL m.liSession            
IF VARTYPE(m.toListener) = "O" && AND ;
   (NOT m.toListener.IsSuccessor)
   DO CASE
   CASE m.tcMethodToken == "DOSTATUS"
      THIS.DoStatus(m.toListener, m.tP1)
   CASE m.tcMethodToken == "UPDATESTATUS"
      THIS.UpdateStatus(m.toListener)    
   CASE m.tcMethodToken == "CLEARSTATUS"
      THIS.ClearStatus(m.toListener)
   CASE m.tcMethodToken == "AFTERBAND"
       THIS.synchStatus(m.toListener,m.tP1,m.tP2)
   CASE m.tcMethodToken == "AFTERREPORT"
      IF SYS(2024) # "Y" 
         IF THIS.isRunning AND TYPE("m.toListener.CommandClauses.RecordTotal") = "N"
            THIS.CurrentRecord = m.toListener.CommandClauses.RecordTotal
         ENDIF   
         THIS.UpdateStatus(m.toListener) 
      ENDIF
      THIS.designatedDriver = ""
      THIS.drivingAlias = ""
      THIS.successorSys2024 = "N"
      THIS.Visible = .F.
      THIS.ReportStopRunDateTime = DATETIME()
      THIS.popUserFeedbackGlobalSets()
      THIS.ClearStatus(m.toListener)       
   CASE m.tcMethodToken == "BEFOREBAND"
      IF THIS.successorSys2024 = "Y" AND ;
         m.toListener.CurrentPass = LISTENER_FULLPASS
         * user cancelled during the prepass,
         * we need to re-cancel.
         m.liSession = SET("DATASESSION")
         SET DATASESSION TO (m.toListener.CurrentDataSession)
         IF USED(THIS.designatedDriver)
            GO BOTTOM IN (THIS.designatedDriver)
         ENDIF   
         SET DATASESSION TO (m.liSession)
      ENDIF   
      THIS.synchStatus(m.toListener,m.tP1,m.tP2)
  CASE m.tcMethodToken == "BEFOREREPORT"
      THIS.setupReport(m.toListener)
   CASE m.tcMethodToken == "CANCELREPORT"
      IF THIS.isRunning AND ;
         (m.toListener.QuietMode OR ;
         (m.toListener.pageLimit > 0 AND m.toListener.PageNo > m.toListener.pageLimit) OR ;
          (NOT m.toListener.AllowModalMessages) OR ;
          m.toListener.DoMessage(OUTPUTCLASS_REPORT_CANCELQUERY_LOC,;
                                 MB_ICONQUESTION+MB_YESNO) =  IDYES )

          m.toListener.cancelRequested = .T.

          IF m.toListener.isSuccessor AND NOT EMPTY(THIS.designatedDriver)
             * NB: FX should ordinarily not be used in a successor,
             * but this won't hurt and will take care of the exception
             THIS.successorSys2024 = "Y"
             m.liSession = SET("DATASESSION")
             SET DATASESSION TO (m.toListener.CurrentDataSession)
             IF USED(THIS.designatedDriver)
                GO BOTTOM IN (THIS.designatedDriver)
             ENDIF   
             SET DATASESSION TO (m.liSession)
          ENDIF
          IF SYS(2024) = "Y"  OR m.toListener.IsSuccessor
             THIS.Visible = .F.
             IF (m.toListener.pageLimit = -1 OR m.toListener.PageNo <= m.toListener.pageLimit)
                m.toListener.DoMessage(OUTPUTCLASS_REPORT_INCOMPLETE_LOC, ;
                               MB_ICONEXCLAMATION)
             ENDIF                        
          ENDIF
          RETURN .F.
       ELSE
          RETURN .T. && did not handle, use default behavior          
       ENDIF          
   CASE m.tcMethodToken == "LOADREPORT"
      THIS.ResetUserFeedback(.T.)
      m.toListener.AddProperty("reportStartRunDatetime",THIS.reportStartRunDatetime)
      IF NOT (m.toListener.QuietMode OR ;
           (TYPE("m.toListener.CommandClauses.NoDialog") = "L" AND ;
           m.toListener.CommandClauses.NoDialog) )
           THIS.DoStatus(m.toListener,THIS.initStatusText) 
          * NB: a user can call LoadReport manually,
          * hence the need for a TYPE() check here.
      ENDIF   
      THIS.pushUserFeedbackGlobalSets(m.toListener) 
   CASE m.tcMethodToken == "UNLOADREPORT"
      THIS.ReportStopRunDateTime = DATETIME()
      m.toListener.AddProperty("reportStopRunDatetime",THIS.reportStopRunDatetime)      
      THIS.IsRunning = .F.
      THIS.ClearStatus()       
      IF NOT THIS.persistBetweenRuns 
         SET DATASESSION TO (m.toListener.ListenerDataSession)      
         THIS.Release()
      ENDIF            
   ENDCASE
   SET DATASESSION TO (m.toListener.ListenerDataSession)
ENDIF            


ENDPROC
PROCEDURE clearstatus
LPARAMETERS m.toListener
IF THIS.Visible 
   THIS.Visible = .F.
ENDIF   

ENDPROC
PROCEDURE dostatus
LPARAMETERS m.toListener, m.cMessage
LOCAL m.loParentForm, m.lcCaption, m.lcParentFormName

IF (VARTYPE(m.toListener) # "O") OR (NOT (m.toListener.QuietMode OR ;
   (THIS.isRunning AND m.toListener.CommandClauses.NoDialog)))

   IF EMPTY(m.cMessage) OR ISNULL(m.cMessage)
      m.cMessage = ""
   ENDIF

   m.lcCaption = EVALUATE(THIS.ThermCaption)

   WITH THIS
      
      IF THIS.isRunning
         THIS.Closable = .F.
         THIS.Movable = .F.
      ENDIF
     .ThermShape.Width = MAX( (((THIS.PercentDone/100) * .ThermBack.Width)-2) ,0)      
     IF NOT .Visible
        
        m.loParentForm = THIS.GetParentWindowRef()
        
        DO CASE
        CASE VARTYPE(m.loParentForm) # "O" AND (NOT _SCREEN.Visible)
           m.lcParentFormName = "MACDESKTOP"
        CASE VARTYPE(m.loParentForm) # "O"
           m.lcParentFormName = "SCREEN"              
        CASE (NOT m.loParentForm.Visible) AND ;
           (m.loParentForm.DeskTop OR NOT EMPTY(m.loParentForm.MacDesktop) OR ;
           m.loParentForm.ShowWindow = 2 OR (NOT _SCREEN.Visible))
           * in many cases, 
           * they've probably made a programming error,
           * the parent should be visible according to
           * the requirements of REPORT FORM ... IN WINDOW
           * if it's a WINDOW clause they
           * have no need to show it, might not be an error
           * Either way, they should see the therm
           * to know that the report is progressing                
           m.lcParentFormName = "MACDESKTOP"
        CASE (NOT m.loParentForm.Visible) 
           * same comment as above
           m.lcParentFormName = "SCREEN"
        OTHERWISE
           m.lcParentFormName = m.loParentForm.Name
        ENDCASE
           
        SHOW WINDOW (.Name) IN WINDOW (m.lcParentFormName) 
        .AlwaysOnTop = .T.
        .AutoCenter = .T.
        .Visible = .T.
     ENDIF
     .ThermLabel.Visible = .F.
     .ThermLabel.Caption = m.lcCaption     
     .ThermLabel.Left = (.Width - .ThermLabel.Width) /2 && doesn't work until after visibility of form
     .ThermLabel.Visible = .T.     
      
   ENDWITH
   
   m.loParentForm = NULL

  
ENDIF   



ENDPROC
PROCEDURE getparentwindowref
LOCAL m.loForm, m.loTopForm, m.lcInWindow

* first top form in the list
* will be the current top form.

ASSERT TYPE("_SCREEN.ActiveForm") # "O"  OR ;
       INLIST(_SCREEN.ActiveForm.ShowWindow, 0,1,2)

m.loTopForm = NULL

IF TYPE("THIS.CommandClauses.InWindow") = "C"
   m.lcInWindow = UPPER(ALLTRIM(THIS.CommandClauses.InWindow))
ENDIF   

IF EMPTY(lcInWindow) AND TYPE("THIS.CommandClauses.Window") = "C"
   m.lcInWindow = UPPER(ALLTRIM(THIS.CommandClauses.Window))
ENDIF   


IF NOT EMPTY(m.lcInWindow) 

     FOR EACH m.loForm IN _SCREEN.Forms  FOXOBJECT
        IF m.loForm.ShowWindow = 2  AND ;
           UPPER(m.loForm.Name) == m.lcInWindow
           m.loTopForm = m.loForm
           EXIT
        ENDIF
     ENDFOR
     
ENDIF

DO CASE

CASE VARTYPE(m.loTopForm) = "O"
    * already found
CASE _SCREEN.FormCount = 0 OR ;
     (TYPE("_SCREEN.ActiveForm") = "O" AND ;
     _SCREEN.ActiveForm.ShowWindow = 0 )     && ShowWindow In Screen
		     
     m.loTopForm = _SCREEN

CASE (TYPE("_SCREEN.ActiveForm") = "O" AND ;
      _SCREEN.ActiveForm.ShowWindow = 2 )    && ShowWindow As Top Form

     m.loTopForm = _SCREEN.ActiveForm
		     
OTHERWISE 
		                                       
     FOR EACH m.loForm IN _SCREEN.Forms  FOXOBJECT
        IF m.loForm.ShowWindow = 2 
           m.loTopForm = m.loForm
           EXIT
        ENDIF
     ENDFOR
		     
     IF VARTYPE(m.loTopForm) # "O"
        m.loTopForm = _SCREEN
     ENDIF
		          
ENDCASE

IF VARTYPE(m.loTopForm) # "O" OR ;
   EMPTY(m.loTopForm.Name)
   m.loTopForm = NULL
ENDIF

RETURN m.loTopForm     

ENDPROC
PROCEDURE getreportscopedriver
LPARAMETERS m.toListener

LOCAL m.liSelect, m.lcAlias, ;
      m.liSkips,  laSkips[1]

IF m.toListener.FRXDataSession > 0
   SET DATASESSION TO (m.toListener.FRXDataSession)
ELSE
   RETURN .F.
ENDIF   

THIS.designatedDriver = THIS.drivingAlias
* used later if we have to cancel report as
* a Successor

IF USED("frx")

   m.liSelect = SELECT(0)
   m.lcAlias = ""

   SELECT FRX
   * first look for any target alias that
   * is the same as the driver
   
   SCAN ALL FOR ObjType = FRX_OBJTYP_BAND AND ;
           Objcode = FRX_OBJCOD_DETAIL AND ;
           TYPE(Expr) = "C" AND ;
           NOT (EMPTY(Expr)  OR DELETED())
       m.lcAlias = ALLTRIM(Expr)
       SET DATASESSION TO (m.toListener.CurrentDataSession)   
       m.lcAlias = UPPER(EVALUATE(m.lcAlias)) 
       SET DATASESSION TO (m.toListener.FRXDataSession)              
       IF m.lcAlias == UPPER(THIS.drivingAlias)
          EXIT
       ENDIF
   ENDSCAN

   IF m.lcAlias == UPPER(THIS.drivingAlias)

      SELECT (m.liSelect)
      * if the driver is also a target alias,
      * don't touch.
      * otherwise:
   ELSE 

      LOCATE FOR ObjType = FRX_OBJTYP_BAND AND ;
              Objcode = FRX_OBJCOD_DETAIL AND ;
              Platform = FRX_PLATFORM_WINDOWS AND ;
              NOT (EMPTY(Expr) OR DELETED())
      IF FOUND()
         * use the first detail band, on the theory
         * that people are going to put pre-processing 
         * calculations before other bands, 
         * so an early band has the best chance to be
         * the right driver.
         m.lcAlias = ALLTRIM(Expr)
         SET DATASESSION TO (m.toListener.CurrentDataSession)
         THIS.drivingAlias = UPPER(EVALUATE(m.lcAlias))
         SET DATASESSION TO (m.toListener.FrxDataSession)
         SELECT (m.liSelect)

      ELSE   
   
         * adjust the driver based on any
         * one to many relationships we can find.
  
         SELECT (m.liSelect)
         SET DATASESSION TO (m.toListener.CurrentDataSession)

         m.lcAlias = THIS.drivingAlias

         m.liSelect = SELECT(0)

         DO WHILE NOT EMPTY(m.lcAlias)

            SELECT (m.lcAlias)
            m.liSkips = ALINES(laSkips,SET("SKIP"),",")
            IF m.liSkips = 0 OR EMPTY(laSkips[1])
               THIS.drivingAlias = m.lcAlias
               m.lcAlias = ""
            ELSE
               m.lcAlias = laSkips[1]
               * it doesn't really matter how many lines there
               * are in the array; this is not going to be perfect
               * but we can't predict which child 
               * has the most records.
            ENDIF
         ENDDO

         SELECT (m.liSelect)
   
      ENDIF   
    
   ENDIF  
ELSE
   RETURN .F.    
ENDIF

ENDPROC
PROCEDURE includeseconds_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "L"
   THIS.includeSeconds = m.vNewVal
ENDIF   

ENDPROC
PROCEDURE initstatustext_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "C"
   THIS.initStatusText = m.vNewVal
ENDIF   
ENDPROC
PROCEDURE persistbetweenruns_assign
LPARAMETERS vNewVal
IF VARTYPE(m.vNewVal) = "L"
   THIS.persistBetweenRuns = m.vNewVal
ENDIF   

ENDPROC
PROCEDURE popuserfeedbackglobalsets
IF (NOT INLIST(_VFP.StartMode,2,3,5))
   LOCAL m.lcRef
   m.lcRef = THIS.EscapeReference
   IF (NOT EMPTY(m.lcRef)) AND ;
       TYPE(m.lcRef) = "O"
      * push occurred earlier
      STORE NULL TO (m.lcRef)
      RELEASE &lcRef.
      THIS.escapeReference = ""
      m.lcRef = THIS.OnEscapeCommand
      ON ESCAPE &lcRef
      POP KEY
      IF THIS.SetNotifyCursor
         SET NOTIFY CURSOR ON
      ENDIF   
      IF THIS.SetEscape 
         SET ESCAPE OFF
      ENDIF   
   ENDIF   
ENDIF   
   
   
ENDPROC
PROCEDURE prepassstatustext_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "C"
   THIS.prepassStatusText = m.vNewVal
ENDIF   

ENDPROC
PROCEDURE pushuserfeedbackglobalsets
LPARAMETERS m.toListener
IF (NOT INLIST(_VFP.StartMode,2,3,5))
   PUSH KEY CLEAR
   LOCAL m.lcRef
   SET MESSAGE TO ""
   THIS.SetNotifyCursor = (SET("Notify",2) = "ON")
   IF THIS.SetNotifyCursor
      SET NOTIFY CURSOR OFF
   ENDIF   
   THIS.OnEscapeCommand = ON("ESCAPE")   
   m.lcRef = SYS(2015)   
   PUBLIC &lcRef.   
   STORE m.toListener TO (m.lcRef)
   ON ESCAPE &lcRef..CancelReport()      
   THIS.EscapeReference = m.lcRef   
   THIS.SetEscape = (SET("ESCAPE")="OFF") 
   IF THIS.SetEscape
      SET ESCAPE ON
   ENDIF   
ENDIF   
   
   
ENDPROC
PROCEDURE resetuserfeedback
LPARAMETERS m.tlResetTimes

THIS.CurrentRecord = 0
THIS.PercentDone = 0
IF m.tlResetTimes
   THIS.ReportStartRunDateTime= DATETIME()
   THIS.ReportStopRunDateTime= DTOT({})
   THIS.thermFormCaption = ""
   THIS.synchUserInterface()
ENDIF

ENDPROC
PROCEDURE runstatustext_assign
LPARAMETERS vNewVal
*To do: Modify this routine for the Assign method
THIS.runStatusText = m.vNewVal

ENDPROC
PROCEDURE secondstext_assign
LPARAMETERS vNewVal
*To do: Modify this routine for the Assign method
THIS.secondsText = m.vNewVal

ENDPROC
PROCEDURE setthermformcaption
LPARAMETERS tcCommandClausesFile, tcPrintJobName
IF EMPTY(THIS.ThermFormCaption)
   IF VARTYPE(tcCommandClausesFile) = "C"
      LOCAL m.cName
      IF EMPTY( tcPrintJobName) OR VARTYPE( tcPrintJobName) # "C"
         m.cName = PROPER(JUSTFNAME(tcCommandClausesFile))
      ELSE
         m.cName =  tcPrintJobName
      ENDIF   
      THIS.thermFormCaption = ;
         m.cName + ": " + OUTPUTCLASS_CANCEL_INSTRUCTIONS_LOC
   ELSE
      THIS.thermFormCaption = ""
   ENDIF
ENDIF
THIS.Caption = THIS.thermFormCaption






ENDPROC
PROCEDURE setupreport
LPARAMETERS m.toListener

LOCAL m.llFRXAvailable, m.lcAlias

THIS.isRunning = .T.

WITH m.toListener
   SET DATASESSION TO (.CurrentDataSession)
   THIS.DrivingAlias = UPPER(ALIAS())
   IF .FRXDataSession > 0
      SET DATASESSION TO (.FRXDataSession)   
   ENDIF
   m.llFRXAvailable = THIS.getReportScopeDriver(m.toListener) 
   
   IF m.llFRXAvailable
      THIS.setThermformCaption(m.toListener.CommandClauses.File, m.toListener.PrintJobName)

      IF TYPE("m.toListener.CommandClauses.Summary") # "L"
         ADDPROPERTY(.CommandClauses,"Summary",.F.)
      ENDIF   
      IF TYPE("m.toListener.CommandClauses.RecordTotal") # "N"
         ADDPROPERTY(.CommandClauses,"RecordTotal",0)
      ENDIF   
      IF TYPE("m.toListener.CommandClauses.NoDialog") # "L"
        ADDPROPERTY(.CommandClauses,"NoDialog",.F.)
      ENDIF      
      SET DATASESSION TO (.FRXDataSession)   
      THIS.FRXBandRecno = 0
      SELECT FRX
   
      IF .CommandClauses.Summary
         * don't use groups unless
         * we're forced to by Summary.
         * Group usage will not work if
         * there's a group on .T. or some
         * other nonsensical expression that
         * doesn't change.
    
         LOCATE FOR ObjType = FRX_OBJTYP_BAND AND ;
             Objcode = FRX_OBJCOD_GROUPHEADER AND ;
             Platform = FRX_PLATFORM_WINDOWS AND ;
             NOT DELETED()
         DO WHILE NOT EOF()
            * find the innermost group
            THIS.FRXBandRecno = RECNO()
            CONTINUE
         ENDDO        
      
         IF THIS.frxBandRecno = 0
            * no groups in a Summary report
            * doesn't make a lot of sense, but
            * can happen.
             LOCATE FOR ObjType = FRX_OBJTYP_BAND AND ;
                Platform = FRX_PLATFORM_WINDOWS AND ;
                Objcode = FRX_OBJCOD_PAGEHEADER AND ;
                NOT DELETED()
             IF NOT EOF()
                THIS.FRXBandRecno = RECNO()
             ENDIF     
         ENDIF
   
      ENDIF

      IF THIS.FRXBandRecno = 0
         * not a Summary report.
         * look for the appropriate detail
         * using the report driver

         LOCATE FOR ObjType = FRX_OBJTYP_BAND AND ;
                    Objcode = FRX_OBJCOD_DETAIL AND ;
                    Platform = FRX_PLATFORM_WINDOWS AND ;
                    TYPE(Expr) = "C" AND ; 
                    NOT (EMPTY(Expr) OR DELETED())
         DO WHILE NOT EOF()
             m.lcAlias = ALLTRIM(Expr)
             SET DATASESSION TO (.CurrentDataSession)             
             m.lcAlias = UPPER(EVALUATE(m.lcAlias))
             SET DATASESSION TO (.FRXDataSession)                          
             IF m.lcAlias == UPPER(THIS.DrivingAlias)             
                THIS.FRXBandRecno = RECNO()
             ENDIF   
             CONTINUE && try not to use the first detail band
         ENDDO
   
      ENDIF   
   
      IF THIS.frxBandRecno = 0
         * couldn't match up a band with
         * the known driver
         LOCATE FOR ObjType = FRX_OBJTYP_BAND AND ;
              Objcode = FRX_OBJCOD_DETAIL AND ;
              Platform = FRX_PLATFORM_WINDOWS AND ;
              EMPTY(Expr) AND NOT DELETED()
         IF NOT EOF()
            THIS.FRXBandRecno = RECNO()      
         ELSE
            IF THIS.FRXBandRecno = 0 
               LOCATE FOR ObjType = FRX_OBJTYP_BAND AND ;
                    Platform = FRX_PLATFORM_WINDOWS AND ;
                    Objcode = FRX_OBJCOD_DETAIL AND ;
                    NOT DELETED()
               IF NOT EOF()
                  THIS.FRXBandRecno = RECNO()
               ENDIF  
            ENDIF               
         ENDIF        
      ENDIF   
   ENDIF
   THIS.DrivingAliasCurrentRecno = 0
   SET DATASESSION TO (.ListenerDataSession)   
   
ENDWITH   




ENDPROC
PROCEDURE synchstatus
LPARAMETERS m.toListener, m.nBandObjCode, m.nFRXRecNo

IF THIS.isRunning AND ;
   THIS.frxBandRecno = m.nFRXRecNo
   WITH m.toListener
      TRY
         SET DATASESSION TO (.CurrentDataSession)
         IF THIS.drivingAliasCurrentRecno  # RECNO(THIS.drivingAlias)
            THIS.currentRecord = THIS.CurrentRecord + 1
            THIS.drivingAliasCurrentRecno = RECNO(THIS.drivingAlias)
         ENDIF   
         IF THIS.currentRecord >= .CommandClauses.RecordTotal
            IF .CurrentPass = 0 AND .TwoPassProcess
               THIS.resetUserFeedback() 
            ELSE
               THIS.currentRecord = .CommandClauses.RecordTotal
            ENDIF
         ENDIF
         THIS.updateStatus(m.toListener)
       CATCH TO err
          #IF OUTPUTCLASS_DEBUGGING 
              SUSPEND
          #ENDIF
       ENDTRY         
       SET DATASESSION TO (.ListenerDataSession)       
   ENDWITH      
ENDIF  


ENDPROC
PROCEDURE synchuserinterface

#define CTLCOLOR_MSGBOX             0
#define CTLCOLOR_EDIT               1
#define CTLCOLOR_LISTBOX            2
#define CTLCOLOR_BTN                3
#define CTLCOLOR_DLG                4
#define CTLCOLOR_SCROLLBAR          5
#define CTLCOLOR_STATIC             6
#define CTLCOLOR_MAX                7
#define COLOR_SCROLLBAR             0
#define COLOR_BACKGROUND            1
#define COLOR_ACTIVECAPTION         2
#define COLOR_INACTIVECAPTION       3
#define COLOR_MENU                  4
#define COLOR_WINDOW                5
#define COLOR_WINDOWFRAME           6
#define COLOR_MENUTEXT              7
#define COLOR_WINDOWTEXT            8
#define COLOR_CAPTIONTEXT           9
#define COLOR_ACTIVEBORDER         10
#define COLOR_INACTIVEBORDER       11
#define COLOR_APPWORKSPACE         12
#define COLOR_HIGHLIGHT            13
#define COLOR_HIGHLIGHTTEXT        14
#define COLOR_BTNFACE              15
#define COLOR_BTNSHADOW            16
#define COLOR_GRAYTEXT             17
#define COLOR_BTNTEXT              18
#define COLOR_INACTIVECAPTIONTEXT  19
#define COLOR_BTNHIGHLIGHT         20
#if("4" $ OS())
#define COLOR_3DDKSHADOW           21
#define COLOR_3DLIGHT              22
#define COLOR_INFOTEXT             23
#define COLOR_INFOBK               24
#define COLOR_DESKTOP           COLOR_BACKGROUND
#define COLOR_3DFACE            COLOR_BTNFACE
#define COLOR_3DSHADOW          COLOR_BTNSHADOW
#define COLOR_3DHIGHLIGHT       COLOR_BTNHIGHLIGHT
#define COLOR_3DHILIGHT         COLOR_BTNHIGHLIGHT
#define COLOR_BTNHILIGHT        COLOR_BTNHIGHLIGHT
#endif


DECLARE INTEGER GetSysColor IN Win32API INTEGER  

LOCAL m.liThermTop, m.liThermLeft, m.liThermWidth, m.liThermHeight

WITH THIS
     .Height = .ThermFormHeight     
     .Width = .ThermFormWidth
     .ControlBox = .F.
     .Closable = .T.
     .Movable = .T.     
     m.liThermHeight = .Height - (.ThermMargin* 2)
     m.liThermWidth =  .Width - (.ThermMargin*2)
     .SetThermFormCaption()    
     m.liThermTop =  .ThermMargin
     m.liThermLeft = .ThermMargin  
ENDWITH

WITH THIS.ThermBack
   .Top = m.liThermTop     
   .Left = m.liThermLeft
   .Height = m.liThermHeight
   .Width = m.liThermWidth
ENDWITH
  
WITH THIS.ThermLabel
   .Top = (.Parent.Height - .Height) /2
   .ForeColor = GetSysColor( COLOR_MENUTEXT )
ENDWITH
  
WITH THIS.ThermShape
   .Top = m.liThermTop +1    
   .Left = m.liThermLeft+1
   .Height = m.liThermHeight -2
   .Width = 0
   .BackColor = .Parent.BackColor
   .FillColor = GetSysColor(COLOR_HIGHLIGHT)
ENDWITH
  
  


ENDPROC
PROCEDURE thermcaption_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "C"
   LOCAL m.lcType, m.cMessage
   m.cMessage = ""
   TRY 
    m.lcType = VARTYPE(EVALUATE(m.vNewVal))
      IF m.lcType = "C"
        THIS.thermCaption = m.vNewVal
    ENDIF
   CATCH 
   ENDTRY     

ENDIF   

ENDPROC
PROCEDURE thermformcaption_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "C"
   THIS.thermFormCaption = m.vNewVal
   THIS.setThermFormCaption()
ENDIF   

ENDPROC
PROCEDURE thermformheight_assign
LPARAMETERS m.vNewVal
IF  VARTYPE(m.vNewVal) = "N" AND ;
   BETWEEN(m.vNewVal,30,SYSMETRIC(SYSMETRIC_SCREENHEIGHT )-30)  AND ;
   INT(m.vNewVal) # THIS.thermFormHeight
   THIS.thermFormHeight = INT(m.vNewVal)
   IF THIS.thermMargin > THIS.thermFormHeight/4
      THIS.thermMargin = THIS.thermFormHeight/4
   ENDIF   
   THIS.synchUserInterface() 
ENDIF   

ENDPROC
PROCEDURE thermformwidth_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "N" AND ;
   BETWEEN(m.vNewVal,100,SYSMETRIC( SYSMETRIC_SCREENWIDTH  )-100) AND ;
   INT(m.vNewVal) # THIS.ThermFormWidth 
   THIS.thermFormWidth = INT(m.vNewVal)
   IF THIS.thermMargin > THIS.thermFormWidth/4
      THIS.thermMargin = THIS.thermFormWidth/4
   ENDIF   
   THIS.synchUserInterface() 
ENDIF   

ENDPROC
PROCEDURE thermmargin_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "N" AND ;
   BETWEEN(m.vNewVal,1,MIN(THIS.ThermFormHeight/4,THIS.ThermFormWidth/4)) AND ;
   INT(m.vNewVal) # THIS.thermMargin
   THIS.thermMargin = INT(m.vNewVal)
   THIS.synchUserInterface() 
ENDIF   

ENDPROC
PROCEDURE thermprecision_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "N" 
   THIS.thermPrecision  = ABS(INT(m.vNewVal))
ENDIF 
ENDPROC
PROCEDURE updatestatus
LPARAMETERS m.toListener
IF VARTYPE(m.toListener) = "O" AND THIS.isRunning
   LOCAL m.liRecTotal, m.lnNewPercent, m.llShow
   m.liRecTotal = m.toListener.CommandClauses.RecordTotal 
   IF m.liRecTotal > 0 
      m.lnNewPercent = ROUND(THIS.CurrentRecord/m.liRecTotal,(THIS.ThermPrecision + 2) ) * 100
      IF (THIS.PercentDone # m.lnNewPercent)
         THIS.PercentDone = m.lnNewPercent
         m.llShow = .T.
         #IF OUTPUTCLASS_DEBUGGING 
             ? THIS.PercentDone, THIS.CurrentRecord, m.liRecTotal, m.toListener.PageTotal
             ? REPL(OUTPUTCLASS_STATUSCHAR_PCT_DONE,INT(THIS.PercentDone/100* OUTPUTCLASS_ONE_HUNDRED_PCT_MARK))+ ;
               REPL(OUTPUTCLASS_STATUSCHAR_PCT_NOT_DONE,MAX(FLOOR(OUTPUTCLASS_ONE_HUNDRED_PCT_MARK - ;
                                                            (OUTPUTCLASS_ONE_HUNDRED_PCT_MARK *THIS.PercentDone/100)),0) ) 
         #ENDIF                
      ENDIF
   ELSE
      m.llShow = .T.         
   ENDIF   
   IF m.llShow
      THIS.DoStatus(m.toListener, ;
                    IIF(m.toListener.CurrentPass = LISTENER_PREPASS  AND m.toListener.TwoPassProcess,;
                     THIS.PrepassStatusText, ;
                     THIS.RunStatusText) )
   ENDIF                     
ENDIF   




ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
4[END RESERVED2]
[START RESERVED3]
*applyfx Implements required API for an object included in the FXListener FXs collection.
*clearstatus Delegate for ReportListener ClearStatus method.
*dostatus Delegate for ReportListener DoStatus method.
*getparentwindowref Provides a window reference for the top form in which the user feedback window should appear.
*getreportscopedriver Adjusts the alias driving CommandClauses.RecordTotal at the beginning of a report  when the DrivingAlias is engaged in one-to-many relationships.
*includeseconds_assign 
*initstatustext_assign 
*persistbetweenruns_assign 
*popuserfeedbackglobalsets Handles non-session-specific user feedback SETtings and behavior.
*prepassstatustext_assign 
*pushuserfeedbackglobalsets Handles non-session-specific user feedback SETtings and behavior.
*resetuserfeedback Sets user feedback to an initialized state.
*runstatustext_assign 
*secondstext_assign 
*setthermformcaption Sets the user feedback window title using the ThermFormCaption property.
*setupreport Handles ReportListener's BeforeReport status preparation chores.
*synchstatus Compares driving recno with currrently-saved information to evaluate need to update user feedback.
*synchuserinterface Set up therm form to match latest user specifications.
*thermcaption_assign 
*thermformcaption_assign 
*thermformheight_assign 
*thermformwidth_assign 
*thermmargin_assign 
*thermprecision_assign 
*updatestatus Delegate for ReportListener UpdateStatus method.
_memberdata XML Metadata for customizable properties
currentrecord Holds the current record relative to the recordtotal in scope for the current report run.
designateddriver Original selected alias for the report.
drivingalias Stores the effective driving alias for a report from the point of view of the therm update.
drivingaliascurrentrecno Holds the RECNO() value in the cursor driving the report run, to assist in determining when to trigger a change in the user feedback.
escapereference Holds the name of a public variable used to facilitate interrupting a report run.
frxbandrecno Holds the RECNO() of the band-describing record in the FRX table this class has determined is optimal for triggering a change in user feedback during a report run.
includeseconds Indicates whether the default user feedback message should include timing data.
initstatustext Provides the user message shown when user feedback first appears.
isrunning Indicates whether a report run is in progress.
onescapecommand Saves the user's previous ON ESCAPE command, if any, for restoration after the report run.
percentdone Calculation of the ratio between the number of records, or pages, already generated to the number of records, or pages, in the total report.
persistbetweenruns Allows the therm window to continue to exist (maintaining its end-of-run contents) after the run of the report.  It may potentially show up on the automatic _MWINDOW list if this is turned on.
prepassstatustext User feedback message for use when the report is in a pre-generation pass to calculate _RECORDTOTAL.
reportstartrundatetime A datetime value indicating when the last report generation run began.
reportstoprundatetime A datetime value for use at the conclusion of a report run, empty during a report, storing when the last report generation run ended.
runstatustext Provides a user message shown during the course of a report run.
secondstext Provides the text message included to describe the time value in the default user feedback message during a report, when IncludeSeconds is .T.
setescape Saves the state of SET ESCAPE previous to the report run, for later restoration.
setnotifycursor Saves the state of SET NOTIFY CURSOR previous to the report run, for later restoration.
successorsys2024 Allows UpdateListener to "remember" if it has cancelled a report between the two report passes if it is in a two-pass process report, if it is a Successor.
thermcaption Holds an evaluated expression for use in the user feedback message shown during a report run. If this expression includes "cMessage", the contents of the argument provided to DoStatus will be included in the result of the evaluation.
thermformcaption Holds the value used to set the title of the user feedback form.
thermformheight Holds the height of the user feedback form, in pixels.  
thermformwidth Holds the width of the user feedback form, in pixels.  
thermmargin Holds the value (in pixels) used to determine the difference between the size of the user feedback window and the thermometer bar it displays.
thermprecision The number of places (precision) to use for evaluating and (by default) showing the percentage done.
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED7]
FX interface-conformant object derived from form class, providing user feedback during a report run.[END RESERVED7]
[START RESERVED8]
reportlisteners.h[END RESERVED8]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1L50TVYFO
[CLASS] shape
[BASECLASS] shape
[OBJNAME] THERMBACK
[PARENT] fxtherm
[START PROPERTIES]
BackStyle = 0
DefHeight = 
DefLeft = 
DefTop = 
DefWidth = 
Height = 30
Left = 0
Name = "THERMBACK"
Top = 5
Visible = .T.
Width = 276
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1L50TX61Q
[CLASS] label
[BASECLASS] label
[OBJNAME] THERMLABEL
[PARENT] fxtherm
[START PROPERTIES]
AutoSize = .T.
BackStyle = 1
Caption = ""
DefTop = 
ForeColor = 0,0,0
Left = 8
Name = "THERMLABEL"
Top = ( (THISFORM.Height - THIS.Height) /2)
Visible = .T.
Width = 2
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1L50UUD6E
[CLASS] shape
[BASECLASS] shape
[OBJNAME] THERMSHAPE
[PARENT] fxtherm
[START PROPERTIES]
BackColor = (THISFORM.BackColor)
BorderStyle = 0
DefHeight = 
DefLeft = 
DefTop = 
DrawMode = 14
FillColor = 178,180,191
FillStyle = 0
Height = (THISFORM.ThermBack.Height -2)
Left = (THISFORM.ThermBack.Left + 1)
Name = "THERMSHAPE"
Top = (THISFORM.ThermBack.Top + 1)
Visible = .T.
Width = 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] fxtherm
[START PROPERTIES]
Arial, 0, 9, 5, 15, 12, 32, 3, 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1Q40K9H6C
[CLASS] fxabstract
[CLASSLOC] listener.vcx
[BASECLASS] custom
[OBJNAME] gfxexample
[START PROPERTIES]
Name = "gfxexample"
_memberdata = <VFPData><memberdata name="applyfx" type="property" display="applyFX" favorites="True"/><memberdata name="showdatasessionissue" display="showDataSessionIssue" favorites="True" type="property"/></VFPData>
showdatasessionissue = .T.
[END PROPERTIES]
[START METHODS]
PROCEDURE applyfx
LPARAMETERS m.toListener, m.tcMethodToken,;
            m.tP1, m.tP2, m.tP3, m.tP4, m.tP5, m.tP6,;
            m.tP7, m.tP8, m.tP9, m.tP10, m.tP11, m.tP12
            

IF m.tcMethodToken == "BEFOREREPORT" AND ;
   THIS.showDataSessionIssue AND ;
   (m.toListener.CurrentDataSession = m.toListener.CommandClauses.StartDataSession)
   MESSAGEBOX("This report does not use a private data session," + CHR(13) + ;
              "so you won't see the problem.")                          
ENDIF              
IF m.tcMethodToken == "BEFOREBAND" 
   SET DATASESSION TO (m.toListener.CurrentDataSession)
   m.toListener.doStatus("working here... ")
   IF THIS.showDataSessionIssue 
      * no switch back here.
*!*	   ELSE
*!*	      SET DATASESSION TO (m.toListener.ListenerDataSession)
   ENDIF      
ENDIF               

IF (NOT THIS.showDataSessionIssue) AND ;
   m.tcMethodToken == "AFTERREPORT"
   * if the following is not included,
   * a "stuck" datasession results unless
   * some additional object later in 
   * the collection did the switch back
   m.toListener.removeCollectionMember(THIS.Name,.T.)
   RELEASE THIS
ENDIF

ENDPROC
PROCEDURE showdatasessionissue_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "L"
  THIS.showDataSessionIssue = m.vNewVal
ENDIF  

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*showdatasessionissue_assign 
showdatasessionissue Toggles demonstration of proper datasession handling in this example GFX class.
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED7]
Example GFX class to show technique the object can use to remove itself from FXListener's collection at the conclusion of a report run. This technique is critical to safe use of FX and GFX objects that do not closely monitor their use of datasessions. [END RESERVED7]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] gfxexample

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1QM0BUK5J
[CLASS] fxabstract
[CLASSLOC] listener.vcx
[BASECLASS] custom
[OBJNAME] gfxnorender
[START PROPERTIES]
Height = 17
Name = "gfxnorender"
Width = 98
_memberdata = <VFPData><memberdata name="applyfx" type="property" display="applyFX" favorites="True"/><memberdata name="omitrendering" display="omitRendering" type="method"/><memberdata name="norenderdataalias" display="noRenderDataAlias" type="property"/></VFPData>
listener = (.NULL.)
norenderdataalias = ("GNR"+SYS(2015))
[END PROPERTIES]
[START PROTECTED]
listener
norenderdataalias
omitrendering
[END PROTECTED]
[START METHODS]
PROCEDURE Destroy
THIS.listener = NULL
ENDPROC
PROCEDURE applyfx
LPARAMETERS m.toListener, m.tcMethodToken, ;
            m.tP1, m.tP2, m.tP3, m.tP4, m.tP5, m.tP6, ;
            m.tP7, m.tP8, m.tP9, m.tP10, m.tP11, m.tP12

LOCAL m.liSession, m.liSelect, m.liFRXRecno, m.liReturn, ;
      m.llNoRender, m.llSwap, m.lcConditions, m.err AS Exception 
m.liReturn = OUTPUTFX_DEFAULT_RENDER_BEHAVIOR  

DO CASE
CASE m.tcMethodToken == "RENDER" AND ;
   NOT ISNULL(m.toListener.FFCGraphics)
   TRY
      m.liSession = SET("DATASESSION")
      SET DATASESSION TO m.toListener.FRXDataSession
      m.liSelect = SELECT(0)
      IF USED(THIS.noRenderDataAlias) 
         SELECT (THIS.noRenderDataAlias)
         m.liFRXRecno =  m.toListener.getFRXRecno(m.tcMethodToken,m.tP1, m.tP2)
         LOCATE FOR FrxRecno = m.liFRXRecno AND PreProcess 
         * there won't be any if it's a Sedna-type build, unless it was a built-in report
         * to another app and we couldn't make the swap.                    
         IF FOUND()
            m.llNoRender = THIS.omitRendering(m.toListener, ALLTRIM(Execute))
         ENDIF                          
         IF NOT (m.llNoRender)
            * rendering override for this instance in the report
            LOCATE FOR FrxRecno = m.liFRXRecno AND NOT PreProcess
            IF FOUND()        
               m.llNoRender = THIS.omitRendering(m.toListener, ALLTRIM(Execute))
            ENDIF   
         ENDIF           
         IF m.llNoRender
            m.liReturn = OUTPUTFX_BASERENDER_NORENDER
         ENDIF
      ENDIF
   CATCH TO m.err 
      #IF OUTPUTCLASS_DEBUGGING
         m.toListener.DoMessage(m.err.Message)
      #ELSE
         * could expose this error but won't,
         * we'll just swallow it
         * code line here for suspend capabilities
         m.liReturn = m.liReturn
      #ENDIF
   FINALLY
       SELECT (m.liSelect)
       SET DATASESSION TO (m.liSession)
   ENDTRY            
CASE m.tcMethodToken == "LOADREPORT" AND ;
    VERSION(4) > "09.00.0000.3504" AND ;
   (NOT m.toListener.CommandClauses.IsDesignerLoaded) AND ;
   FILE(m.toListener.CommandClauses.File)
   
    * We can't do this in a design session because
    * of the Designer's lock on the original file.
    * We also can't do this in SP1 or below, 
    * or when the report is built in to a different app.
    * (Note the use of FILE() rather than SYS(2000) here, 
    * it's okay if it's not on disk.)
    * We will still handle this at render time if we can't make the swap;
    * (we just won't get the performance benefits of preprocess-deletion)
   TRY
      m.liSession = SET("DATASESSION")
      SET DATASESSION TO m.toListener.FRXDataSession
      m.liSelect = SELECT(0)
      * nb: this is before memberdata is normally available.
      SELECT 0
        
      USE (m.toListener.CommandClausesFile) ;
          AGAIN NOUPDATE SHARED ALIAS  FRX
      m.toListener.FRXCursor.UnpackFrxMemberData("FRX",;
                   m.toListener.MemberDataAlias, m.toListener.FRXDataSession)
      USE IN FRX
      IF USED(m.toListener.MemberDataAlias) 
         SELECT (m.toListener.MemberDataAlias)
         LOCATE FOR Type = FRX_BLDR_MEMBERDATATYPE AND ;
                    Name == FRX_BLDR_NAMESPACE_ADVANCEDPROPS AND ;
                    ExecWhen == FRX_BLDR_ADVPROP_PREPROCESS_NORENDER AND ;
                    NOT EMPTY(Execute)  
         IF FOUND()           
            * check to see if we are already working on 
            * a temporary report.
            IF (NOT m.toListener.isFRXSwapCopyPresent())
               * must perform the swap, storing
               * CommandClauses.File for later use
               m.llSwap = .T.               
               m.toListener.prepareFRXSwapCopy(,,.T.)
            ENDIF   
            * After creating swap report or ascertaining that
            * we are already working with a temp report, 
            * delete the items in that report as required.
            * BUT FIRST make sure the swap went through as planned.
            IF m.llSwap AND ;
               (EMPTY(m.toListener.CommandClauses.File) OR ;
                EMPTY(SYS(2000,m.toListener.CommandClauses.File)))
               m.llSwap = .F.
               m.toListener.CommandClauses.File = ;
                 m.toListener.commandClausesFile
            ENDIF
            * now if we're positive we're in the right place
            * and that we have possible memberdata content
            * we can start deleting records out of the swap copy:
            IF USED(m.toListener.MemberDataAlias) AND ;
               NOT (m.toListener.CommandClauses.File == ;
                    m.toListener.commandClausesFile)
               USE (m.toListener.CommandClauses.File) IN 0 ;
                      AGAIN EXCLU ALIAS FRX 
                      * can't do a NOUP to do the delete.
                      * since we're in a private copy,  
                      * we switch this to an
                      * EXCLU and PACK although it doesn't appear
                      * to be necessary for the engine's POV.
                      * This means users of this copy of the 
                      * FRX don't have to pay attention to
                      * whether some records are potentially-deleted.

               SELECT (m.toListener.MemberDataAlias)                
               SCAN FOR Type = FRX_BLDR_MEMBERDATATYPE AND ;
                        Name == FRX_BLDR_NAMESPACE_ADVANCEDPROPS AND ;
                        ExecWhen == FRX_BLDR_ADVPROP_PREPROCESS_NORENDER AND ;
                        NOT EMPTY(Execute)  
                  m.liRecno = FRXRecno                    
                  m.llNoRender = THIS.omitRendering(m.toListener,ALLTRIM(Execute))
                  IF m.llNoRender
                     SELECT FRX
                     DELETE ALL FOR RECNO() = m.liRecno
                     SELECT (m.toListener.MemberDataAlias)
                  ENDIF   
               ENDSCAN
               SELECT FRX
               PACK
            ENDIF   
         ENDIF
      ENDIF
   CATCH TO m.err 
      * revert the swap if we did one
      * being careful not to remove the original report
      #IF OUTPUTCLASS_DEBUGGING
      m.toListener.DoMessage(OUTPUTFX_CONDITIONALRENDERING_UNAVAILABLE_LOC + ;
                             CHR(13) + m.err.Message )
      #ENDIF
      IF m.llSwap 
          m.toListener.removeFRXSwapCopy(,OUTPUTCLASS_DEBUGGING )           
      ENDIF   
   FINALLY
       IF USED("FRX")
          USE IN FRX
       ENDIF
       * we must close this early version of the
       * memberdata cursor -- later its frxrecno values
       * will be re-created correctly
       IF USED(m.toListener.MemberDataAlias)
          USE IN (m.toListener.MemberDataAlias)
       ENDIF
       SELECT (m.liSelect)
       SET DATASESSION TO (m.liSession)
   ENDTRY            
CASE m.tcMethodToken == "BEFOREREPORT"
   m.liSession = SET("DATASESSION")
   SET Datasession TO m.toListener.FRXDataSession  
   IF USED(m.toListener.MemberDataAlias)
      m.liSelect = SELECT(0)
      m.lcConditions = "(ExecWhen == '" + FRX_BLDR_ADVPROP_PREPROCESS_NORENDER + "' OR " + ;
                       " ExecWhen == '" + FRX_BLDR_ADVPROP_INSTANCE_NORENDER +"' ) "
      SELECT FrxRecno,ExecWhen,Execute, ;
            IIF(ExecWhen == FRX_BLDR_ADVPROP_PREPROCESS_NORENDER, .T., .F.) AS PreProcess ;
         FROM (m.toListener.MemberDataAlias) ;
         INTO CURSOR (THIS.noRenderDataAlias) ;         
         WHERE Type = FRX_BLDR_MEMBERDATATYPE AND ;
               Name == FRX_BLDR_NAMESPACE_ADVANCEDPROPS AND ;
               (NOT EMPTY(Execute)) AND &lcConditions.           
      IF RECCOUNT(THIS.noRenderDataAlias) = 0
         USE IN (THIS.noRenderDataAlias)
      ELSE
         SELECT (THIS.noRenderDataAlias)
         INDEX ON FrxRecno TAG FrxRecno
      ENDIF                    
      SELECT (m.liSelect)
   ENDIF   
   SET Datasession TO (m.liSession)
CASE m.tcMethodToken == "UNLOADREPORT"
   * if swap was performed, and if the temporary
   * report is still "in place" 
   * as commandClausesFile 
   * get rid of temporary report 
   * if there is one and if it still exists
   * and return CommandClauses.File to its original value
   * it should not matter what order objects handle this
   IF m.toListener.isFRXSwapCopyPresent()
      m.liSession = SET("DATASESSION")
      SET DATASESSION TO m.toListener.FRXDataSession
      IF USED(THIS.noRenderDataAlias)
         USE IN (THIS.noRenderDataAlias)
      ENDIF
      m.liSelect = SELECT(0)
      IF USED("FRX")
         m.llSwap = .T.
         SELECT FRX
         USE
      ENDIF              
      m.toListener.removeFRXSwapCopy(,OUTPUTCLASS_DEBUGGING )           
      IF m.llSwap
        SELECT 0
        USE (m.toListener.CommandClauses.File) ALIAS FRX NOUPDATE
      ENDIF
      SELECT (m.liSelect)
      SET DATASESSION TO (m.liSession)
   ENDIF           
ENDCASE   

RETURN  m.liReturn
ENDPROC
PROCEDURE omitrendering
LPARAMETERS m.toListener, m.tcExpr
LOCAL m.llNoRender, m.liSession
IF VARTYPE(m.tcExpr) = "C"
   m.liSession = SET("DATASESSION")
   THIS.listener = m.toListener               
   SET DATASESSION TO m.toListener.CurrentDataSession
   IF TYPE(m.tcExpr) = "L"
      m.llNoRender = EVALUATE(m.tcExpr)
      SET DATASESSION TO m.toListener.FRXDataSession               
   ELSE
      SET DATASESSION TO m.toListener.FRXDataSession
      IF TYPE(m.tcExpr) = "L"
         m.llNoRender = EVALUATE(m.tcExpr)                 
     ENDIF
   ENDIF
   THIS.listener = NULL
   SET DATASESSION TO (m.liSession)
ENDIF            
RETURN m.llNoRender
ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*omitrendering Evaluates Rendering requirements, returning True or False, in both current and frx data sessions.
listener Holds a ReportListener reference during applyFX processing for use in evaluating "Render When" conditions.
norenderdataalias Alias of private cursor for gfxNoRender subset of memberdata.
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED7]
Conditionally eliminates default rendering behavior for report layout controls by evaluating a ReportListener-referencing expression specified in MemberData.[END RESERVED7]
[START RESERVED8]
reportlisteners.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] gfxnorender

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2220SN8V0
[CLASS] custom
[BASECLASS] custom
[OBJNAME] gfxoutputclip
[START PROPERTIES]

Name = "gfxoutputclip"
_memberdata =     2083<VFPData><memberdata name="forceon" type="property" display="forceOn" favorites="True"/><memberdata name="gdipluslib" type="property" display="gdiPlusLib" favorites="True"/><memberdata name="iimageinstanceimage" type="property" display="iImageInstanceimage"/><memberdata name="mimetype" type="property" display="mimetype" favorites="True"/><memberdata name="aimagecopies" type="property" display="aImageCopies"/><memberdata name="iimageinstanceindex" type="property" display="iImageInstanceIndex"/><memberdata name="margin" type="property" display="margin" favorites="True"/><memberdata name="lonthisrun" type="property" display="lOnThisRun"/><memberdata name="lthisruninpagedmode" type="property" display="lThisRunInPagedMode"/><memberdata name="oimagedest" type="property" display="oImageDest"/><memberdata name="oimagesrc" type="property" display="oImageSrc"/><memberdata name="opoint" type="property" display="oPoint"/><memberdata name="oprivategraphics" type="property" display="oPrivateGraphics"/><memberdata name="orect" type="property" display="oRect"/><memberdata name="snamespace" type="property" display="sNamespace"/><memberdata name="applyfx" type="method" display="applyFX"/><memberdata name="getcurrentclipfilename" type="method" display="getCurrentClipFileName" favorites="True"/><memberdata name="outputpageclip" type="method" display="outputPageClip" favorites="True"/><memberdata name="setupimageclip" type="method" display="setupImageClip" favorites="True"/><memberdata name="saveimageclips" type="method" display="saveImageClips"/><memberdata name="getimageext" type="method" display="getImageExt"/><memberdata name="setup" type="method" display="setup"/><memberdata name="gdipluslibmodule" type="property" display="gdiPlusLibModule" favorites="True"/><memberdata name="listenersupportssaveclip" type="method" display="listenerSupportsSaveClip"/><memberdata name="cleanup" type="method" display="cleanup"/><memberdata name="simagepath" type="property" display="sImagePath"/><memberdata name="simagefullpath" type="property" display="sImageFullPath"/></VFPData>
forceon = .F.
gdipluslib = ("")
gdipluslibmodule = ("")
iimageinstanceindex = 0
lonthisrun = .F.
margin = 10
mimetype = ("image/png")
oimagedest = NULL
oimagesrc = NULL
opoint = NULL
oprivategraphics = NULL
orect = NULL
simagefullpath = ("")
simagepath = ("")
snamespace = ("")
[END PROPERTIES]
[START PROTECTED]
aimagecopies
cleanup
getimageext
iimageinstanceindex
listenersupportssaveclip
lonthisrun
oimagedest
oimagesrc
opoint
oprivategraphics
orect
saveimageclips
setup
simagefullpath
simagepath
snamespace
[END PROTECTED]
[START METHODS]
PROCEDURE Destroy
THIS.Cleanup()
ENDPROC
PROCEDURE Init
       #DEFINE THISNAMESPACE         "Spacefold.LSN.gfxOutputClip"
       
       *&* An appropriate namespace must be defined for cases in which
       *&* you want to use this gfx on its own and share it
       *&* by placing it in the GFXs collection.
       *&* You can set the outputclip behavior to occur only 
       *&* after all other rendering is through, and
       *&* also ensure availability of the clip files and
       *&* clip file names to all Successors, by using this 
       *&* approach.  Simply add memberdata to the layout elements
       *&* you want clipped (no other memberdata property besides 
       *&* the name attribute is needed by this object).
       *&* The layout elements to be clipped
       *&* can be of any report control type.
       
       *&* However, this object can be invoked explicitly, even
       *&* when shared, by a custom rendering extension
       *&* using "ForceOn" behavior, and without
       *&* any memberdata instructions in the report.
       *&* It is also constructed to be 
       *&* well-behaved if multiple custom rendering extensions
       *&* keeps private copies and invoke them explicitly
       *&* rather than putting a shared copy in the GFXs collection.
       
       *&* Now that you have read this note <g>
       *&* and if you want this object to work on its
       *&* own in the GFXs collection as a shared worker object,
       *&* you can :
       *&* override the Init in your subclass with 
       *&* an appropriate namespace value 
       *&* OR         
       *&* uncomment the IF/ENDIF below and set 
       *&* an appropriate default property definition
       *&* in your subclass.     

       *&* IF VARTYPE(THIS.sNamespace) # "C" OR EMPTY(THIS.sNamespace)
          THIS.sNameSpace = THISNAMESPACE 
       *&* ENDIF 

ENDPROC
PROCEDURE applyfx
LPARAMETERS m.toListener, m.tcMethodToken, ;
            m.tP1, m.tP2, m.tP3, m.tP4, m.tP5, m.tP6, ;
            m.tP7, m.tP8, m.tP9, m.tP10, m.tP11, m.tP12
         
LOCAL m.liSession, m.liSelect, m.liFRXRecno, m.lvReturn, ;
      m.liDriver, m.err AS EXCEPTION

m.lvReturn = .T.

IF THIS.listenerSupportsSaveClip(m.toListener)

   TRY

      m.liSession = SET("DATASESSION")

      IF m.toListener.FRXDATASESSION > -1

         SET DATASESSION TO m.toListener.FRXDATASESSION
         m.liSelect = SELECT(0)

         DO CASE

         CASE m.tcMethodToken == "BEFOREREPORT"

            THIS.aImageCopies = .F.
            THIS.iImageInstanceIndex = 0
            IF USED (m.toListener.MemberDataAlias)
               SELECT (m.toListener.MemberDataAlias)
               LOCATE FOR ;
                  NAME == THIS.sNameSpace 
               THIS.lOnThisRun = (FOUND() OR THIS.forceOn)
               IF THIS.lOnThisRun
                  THIS.Setup(m.toListener)
               ENDIF   
            ENDIF

         CASE m.tcMethodToken == "RENDER" AND ;
              NOT ISNULL(m.toListener.FFCGraphics) AND ;
              THIS.lOnThisRun
 
            m.lvReturn = OUTPUTFX_DEFAULT_RENDER_BEHAVIOR
            m.liFRXRecno =  m.toListener.getFRXRecno(m.tcMethodToken,m.tP1, m.tP2)
            GO m.liFRXRecNo IN FRX
            SELECT (m.toListener.MemberDataAlias)
            LOCATE FOR FRXRecno = m.liFRXRecno AND ;
                   NAME == THIS.sNameSpace
            IF FOUND()
               THIS.setupImageClip(m.toListener, ;
                   m.tP2, m.tP3, m.tP4, m.tP5, @m.tP7, ;
                   (FRX.ObjType = FRX_OBJTYP_PICTURE))
            ENDIF    

         CASE m.tcMethodToken == "AFTERREPORT"

            IF THIS.listenerSupportsSaveClip(m.toListener,.F.)
               THIS.saveImageClips(m.toListener)
            ENDIF
            THIS.Cleanup(m.toListener)

         ENDCASE

     ELSE
         THIS.lOnThisRun = .F.   
     ENDIF   
         
  CATCH TO m.err

     #IF OUTPUTCLASS_DEBUGGING
         SUSPEND
     #ENDIF

  FINALLY

     IF VARTYPE(m.err) = "O" 
        *&* this object cleans up after an error --
        *&* doesn't provide a choice, although it could.
        THIS.Cleanup(m.toListener)
     ENDIF

     IF m.toListener.FRXDataSession # -1
        SET DATASESSION TO m.toListener.FrxDataSession
        SELECT (m.liSelect)
        SET DATASESSION TO (m.liSession)
     ENDIF   

  ENDTRY

ENDIF

RETURN  m.lvReturn

      
         
         
ENDPROC
PROCEDURE cleanup
LPARAMETERS m.toListener

IF THIS.lOnThisRun AND VARTYPE(m.toListener) = "O" AND ;
   THIS.listenerSupportsSaveClip(m.toListener,.T.)
   UNBINDEVENTS(THIS)
ENDIF

THIS.lOnThisRun = .F.

STORE "" TO ;
      THIS.sImagePath, ;
      THIS.sImageFullPath

STORE NULL TO  ;
      THIS.oImageSrc, ;
      THIS.oImageDest, THIS.oPrivateGraphics, ;
      THIS.oPoint, THIS.oRect 
ENDPROC
PROCEDURE forceon_assign
LPARAMETERS m.tvValue
IF VARTYPE(m.tvValue) = "L"
   THIS.forceOn = m.tvValue
ENDIF

ENDPROC
PROCEDURE gdipluslib_assign
LPARAMETERS m.tvValue
IF VARTYPE(m.tvValue) = "C"
   m.tvValue = ALLTRIM(m.tvValue)
   DO CASE
   CASE(EMPTY(m.tvValue) OR FILE(m.tvValue))
       THIS.gdiPlusLib = m.tvValue
   CASE FILE(FORCEEXT(m.tvValue,"VCX"))
       THIS.gdiPlusLib = FORCEEXT(m.tvValue,"VCX")
   ENDCASE    
ENDIF   

ENDPROC
PROCEDURE gdipluslibmodule_assign
LPARAMETERS m.tvValue
IF VARTYPE(m.tvValue) = "C"
   m.tvValue = ALLTRIM(m.tvValue)
   IF(EMPTY(m.tvValue) OR (NOT EMPTY(SYS(2000,(m.tvValue)))))
       THIS.gdiPlusLibModule = m.tvValue
   ENDIF
ENDIF   


ENDPROC
PROCEDURE getcurrentclipfilename
IF THIS.iImageInstanceIndex = 0 OR ;
   EMPTY(THIS.aImageCopies[THIS.iImageInstanceIndex,2])
   RETURN ""
ELSE
   RETURN THIS.aImageCopies[THIS.iImageInstanceIndex,2]
ENDIF   

ENDPROC
PROCEDURE getimageext
*&* override as you see fit.
RETURN SUBSTR(THIS.mimetype,RAT("/",THIS.mimetype) + 1)
ENDPROC
PROCEDURE listenersupportssaveclip
LPARAMETERS m.toListener,m.tlActInPagedMode

DO CASE
CASE m.toListener.ListenerType = LISTENER_TYPE_DEF
   RETURN .F.
CASE PCOUNT() < 2
   RETURN m.toListener.ListenerType # LISTENER_TYPE_DEF
CASE tlActInPagedMode
   RETURN INLIST(m.toListener.ListenerType,LISTENER_TYPE_PRN,LISTENER_TYPE_PAGED)
OTHERWISE
   RETURN INLIST(m.toListener.ListenerType,LISTENER_TYPE_PRV,LISTENER_TYPE_ALLPGS)
ENDCASE    

ENDPROC
PROCEDURE margin_assign
LPARAMETERS m.tvNewVal
IF VARTYPE(m.tvNewVal) = "N"
   THIS.margin = INT(m.tvNewVal)
ENDIF   

ENDPROC
PROCEDURE mimetype_assign
LPARAMETERS m.tvValue

IF VARTYPE(m.tvValue) = "C" AND "/" $ m.tvValue
   THIS.mimetype = ALLTRIM(m.tvValue)
ENDIF

ENDPROC
PROCEDURE outputpageclip
LPARAMETERS m.nPageNo, ;
            m.eDevice, ;
            m.nDeviceType, ;
            m.nleft, m.nTop, m.nWidth, m.nHeight, ;
            m.nClipLeft,m.nClipTop, m.nClipWidth, m.nClipHeight

  LOCAL m.laBind[1]
  AEVENTS(m.laBind,0)
  THIS.saveImageClips(laBind[1],m.nPageNo)


ENDPROC
PROCEDURE saveimageclips
LPARAMETERS m.toListener, m.tiPage

IF NOT THIS.listenerSupportsSaveClip(m.toListener)
   RETURN .F.
ENDIF
   
LOCAL m.lcTempfile, m.liPageIndex, m.liImageIndex, m.liStartPage, m.liEndPage

m.lcTempFile = FORCEEXT(FORCEPATH(SYS(2015),SYS(2023)),"EMF") && always goes to temp dir

THIS.oPoint.Set(0,0)

IF THIS.listenerSupportsSaveClip(m.toListener, .T.) 
   m.liStartPage = VAL(TRANSFORM(m.tiPage))
   m.liEndPage  = m.liStartPage
   UNBINDEVENTS(THIS)
   * avoid recursion the easy way.
ELSE
   m.liStartPage = 1
   m.liEndPage = m.toListener.PageTotal
ENDIF

IF EMPTY(THIS.sImageFullPath)
   * should just happen the first time through
   * in paged mode
   IF PEMSTATUS(m.toListener,"targetFileName",5) AND ;
      NOT EMPTY(JUSTPATH(m.toListener.targetFileName))
      THIS.sImageFullPath = FULLPATH(THIS.sImagePath,m.toListener.targetFileName)
   ELSE
      THIS.sImageFullPath = FULLPATH(THIS.sImagePath)
   ENDIF   
ENDIF   


m.liImageIndex = ASCAN(THIS.aImageCopies,m.liStartPage,1,THIS.iImageInstanceIndex,1,8)

IF m.liImageIndex > 0
   FOR m.liPageIndex = m.liStartPage TO m.liEndPage
       m.toListener.OutputPage(m.liPageIndex,m.lcTempFile,100)
       THIS.oImageSrc.CreateFromFile(m.lcTempFile)
       DO WHILE m.liImageIndex <= THIS.iImageInstanceIndex
          IF THIS.aImageCopies[m.liImageIndex,1] > m.liPageIndex
              EXIT
          ENDIF
          THIS.oImageDest.Create(CEILING(THIS.aImageCopies[m.liImageIndex,5]/10) + ;
                                 THIS.margin,;
                                 CEILING(THIS.aImageCopies[liImageIndex,6]/10) + ;
                                 THIS.margin)
          THIS.oPrivateGraphics.CreateFromImage(THIS.oImageDest)
          THIS.oRect.Set(FLOOR(THIS.aImageCopies[m.liImageIndex,3]/10) ,;
                         FLOOR(THIS.aImageCopies[m.liImageIndex,4]/10) ,;
                         CEILING(THIS.aImageCopies[m.liImageIndex,5]/10  + ;
                         THIS.margin),;
                         CEILING(THIS.aImageCopies[liImageIndex,6]/10) + ;
                         THIS.margin)
          THIS.oPrivateGraphics.DrawImagePortionAt(;
                    THIS.oImageSrc, THIS.oPoint, THIS.oRect, 2)
          THIS.oImageDest.SaveToFile(FORCEPATH(THIS.aImageCopies[m.liImageIndex,2], ;
                                               THIS.sImageFullPath), ;
                                     THIS.mimetype) 
          m.liImageIndex = m.liImageIndex + 1 
       ENDDO
    NEXT
    ERASE (m.lcTempFile)
ENDIF   

IF THIS.listenerSupportsSaveClip(m.toListener,.T.) 
   BINDEVENT(m.toListener,"OutputPage",THIS,"outputPageClip")
ENDIF

ENDPROC
PROCEDURE setup
LPARAMETERS m.toListener

IF VARTYPE(m.toListener) # "O" 
   THIS.lOnThisRun = .F.
   * early quit
ENDIF
   
IF THIS.lOnThisRun 
   IF EMPTY(THIS.gdiPlusLib) OR ;
      NOT FILE(THIS.gdiPlusLib)
      IF ISNULL(m.toListener.FFCGraphics)
         THIS.lOnThisRun = .F.
      ELSE
         THIS.gdiPlusLib = m.toListener.FFCGraphics.ClassLibrary
      ENDIF         
   ENDIF
   * test:
   LOCAL loTemp
   TRY
      loTemp = NEWOBJECT("gpPoint",THIS.gdiPlusLib,THIS.gdiPlusLibModule)
   CATCH WHEN .T.
      THIS.gdiPlusLib = "_gdiplus.vcx"
      IF FILE(THIS.gdiPlusLib)
         THIS.gdiPlusLib = ""
      ELSE
         THIS.gdiPlusLib = _REPORTOUTPUT
      ENDIF 
      * one more try  
      TRY
         loTemp = NEWOBJECT("gpPoint",THIS.gdiPlusLib,THIS.gdiPlusLibModule)
      CATCH WHEN .T.
         loTemp = NULL
      ENDTRY
   FINALLY
      IF VARTYPE(loTemp) # "O"
         THIS.lOnThisRun = .F.
      ENDIF
      loTemp = NULL
   ENDTRY      
ENDIF

IF THIS.lOnThisRun   
   IF PEMSTATUS(m.toListener,"externalFileLocation",5) AND ;
      (NOT EMPTY(m.toListener.externalFileLocation)) 
      THIS.sImagePath = ADDBS(m.toListener.externalFileLocation)
   ELSE
      STORE SYS(2023) TO THIS.sImagePath, THIS.sImageFullPath 
   ENDIF
   IF THIS.listenerSupportsSaveClip(m.toListener,.T.)
      * page-at-a-time mode
      * bind to outputpage event
      BINDEVENT(m.toListener,"OutputPage",THIS,"outputPageClip")
   ENDIF
   IF VARTYPE(THIS.oImageSrc) # "O"
      THIS.oImageSrc = NEWOBJECT("gpBitMap",THIS.gdiPlusLib,THIS.gdiPlusLibModule)
   ENDIF                             
   IF VARTYPE(THIS.oImageDest) # "O"
       THIS.oImageDest = NEWOBJECT("gpBitMap",THIS.gdiPlusLib,THIS.gdiPlusLibModule)
   ENDIF                    
   IF VARTYPE(THIS.oPoint) # "O"
      THIS.oPoint = NEWOBJECT("gpPoint",THIS.gdiPlusLib,THIS.gdiPlusLibModule)
   ENDIF         
   IF VARTYPE(THIS.oRect) # "O"
      THIS.oRect = NEWOBJECT("gpRectangle",THIS.gdiPlusLib,THIS.gdiPlusLibModule)
   ENDIF        
   IF VARTYPE(THIS.oPrivateGraphics) # "O"
      THIS.oPrivateGraphics = NEWOBJECT("gpGraphics",THIS.gdiPlusLib,THIS.gdiPlusLibModule)
   ENDIF
 ENDIF   

ENDPROC
PROCEDURE setupimageclip
LPARAMETERS m.toListener, ;
            m.tnLeft, m.tnTop, m.tnWidth, m.tnHeight, ;
            m.tvContentsToBeRendered, m.tlImageControl

LOCAL m.lcFileName

THIS.iImageInstanceIndex = THIS.iImageInstanceIndex + 1

DIME THIS.aImageCopies[THIS.iImageInstanceIndex,6]
       
* create a file name based on THIS.Name and THIS.iImageInstanceIndex
* unless the name of the object is the name of the class, which
* may happen if it is a privately-owned object

IF UPPER(THIS.Name) == UPPER(THIS.Class)
   m.lcFileName = "C"+SYS(2015)
ELSE
   m.lcFileName = THIS.Name   
ENDIF

m.lcFileName = FORCEPATH(FORCEEXT(;
               m.lcFileName + "_"+TRANSFORM(THIS.iImageInstanceIndex), ;
              THIS.getImageExt()),THIS.sImagePath)                    

IF m.tlImageControl  
   m.tvContentsToBeRendered = m.lcFileName
ELSE
   #IF OUTPUTCLASS_DEBUGGING
       m.tvContentsToBeRendered = STRCONV(m.lcFileName,STRCONV_DBCS_UNICODE)
   #ENDIF 
ENDIF   
     
THIS.aImageCopies[THIS.iImageInstanceIndex,1] = m.toListener.PageNo
THIS.aImageCopies[THIS.iImageInstanceIndex,2] = m.lcFileName
THIS.aImageCopies[THIS.iImageInstanceIndex,3] = m.tnLeft
THIS.aImageCopies[THIS.iImageInstanceIndex,4] = m.tnTop
THIS.aImageCopies[THIS.iImageInstanceIndex,5] = m.tnWidth
THIS.aImageCopies[THIS.iImageInstanceIndex,6] = m.tnHeight     
ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*applyfx Implementation of required method for the FX interface.
*cleanup Cleanup code for each report run specific to this object.
*forceon_assign 
*gdipluslib_assign 
*gdipluslibmodule_assign 
*getcurrentclipfilename Provides generated output image copy filename for the current copy action.
*getimageext Derive file extension from current mimetype value.
*listenersupportssaveclip Evaluates whether the object can handle image copy processing in the current ReportListener output mode and during the current ReportListener event.
*margin_assign 
*mimetype_assign 
*outputpageclip Bindable procedure to save image copy files at the correct moment (the OutputPage event) during a paged report run.
*saveimageclips Performs image copy procedures on the page regions requested for one or more pages.
*setup Setup code for each report run specific to this object.
*setupimageclip Saves a row to the aImageCopies array during rendering procedures when a page region is marked for an image copy, for later use in image copy procedures.
^aimagecopies[1,6] Collection of values about each image copy the object makes during a report run (each row contains PageNo, output filename, and Left,Top,Width,Height values for the copy).
_memberdata XML Metadata for customizable properties
forceon Require this object to turn itself on for a report run, even if it does not see any objects tagged for its attention with the Memberdata values it expects. 
gdipluslib Class library to use for instantation of point, rect, and other helper objects.
gdipluslibmodule Optional APP or EXE file (module) from which to instantiate helper objects in the gdiPlusLib class library.
iimageinstanceindex Index of the current image copy file.
lonthisrun Logical value determining whether the object should take action during this run.
margin Integer value of frame margin to add to both width and height when determining the clip coordinates for the current portion of the page to be copied.
mimetype Mimetype to use for image-copy files the object creates.
oimagedest Helper object for image-copy process.
oimagesrc Helper object for image-copy process.
opoint Helper object for image-copy process.
oprivategraphics Helper object for image-copy process.
orect Helper object for image-copy process.
simagefullpath Full path to which image copy files are saved, determined by ReportListener's externalFileLocation and targetFileName properties if they exist and are in use.
simagepath Potentially relative path to which image copy files are saved, determined by ReportListener's externalFileLocation property (which may be relative) if it exists and is in use.
snamespace Reporting Memberdata namespace for which the object will look when determining whether a layout control's page region has been  explicitly tagged for copy to an image file.
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED7]
Provides copy-to-image file for designated page regions during a report run, so you can export the rendered regions for embedding in output targets. Alternative to xmlDisplayListener.copyImageFilesToExternalFileLocation handling custom-rendered content.[END RESERVED7]
[START RESERVED8]
reportlisteners.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] gfxoutputclip

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1Q210400D
[CLASS] fxabstract
[CLASSLOC] listener.vcx
[BASECLASS] custom
[OBJNAME] gfxrotate
[START PROPERTIES]
Name = "gfxrotate"
[END PROPERTIES]
[START METHODS]
PROCEDURE applyfx
LPARAMETERS m.toListener, m.tcMethodToken, ;
            m.tP1, m.tP2, m.tP3, m.tP4, m.tP5, m.tP6, ;
            m.tP7, m.tP8, m.tP9, m.tP10, m.tP11, m.tP12

LOCAL liSession, liAngle, liSelect, liFRXRecno, liReturn 

m.liReturn = OUTPUTFX_DEFAULT_RENDER_BEHAVIOR  

IF m.tcMethodToken == "RENDER" AND ;
   NOT ISNULL(m.toListener.FFCGraphics)
            
   TRY
      m.liSession = SET("DATASESSION")
      IF m.toListener.FRXDataSession > -1
         SET DATASESSION TO m.toListener.FRXDataSession
      ENDIF         
      m.liSelect = SELECT(0)
      IF USED(m.toListener.MemberDataAlias) 
         SELECT (m.toListener.MemberDataAlias)
         m.liFRXRecno =  m.toListener.getFRXRecno(m.tcMethodToken,m.tP1, m.tP2)
         LOCATE FOR FrxRecno = m.liFRXRecno AND ;
                    Type = FRX_BLDR_MEMBERDATATYPE AND ;
                    Name == FRX_BLDR_NAMESPACE_ROTATE AND ;
                    NOT EMPTY(Execute)  
                    
         IF FOUND() AND NOT EMPTY(INT(VAL(Execute))) 
            m.liAngle = INT(VAL(Execute))
            m.toListener.FFCGraphics.TranslateTransform(tP2, tP3)
            m.toListener.FFCGraphics.RotateTransform(m.liAngle)
            m.liReturn = OUTPUTFX_BASERENDER_RENDER_BEFORE_RESTORE 
            m.toListener.FFCGraphics.TranslateTransform(-tP2, -tP3)
         ENDIF
      ENDIF
   CATCH TO err
      * could expose the error but won't,
      * we'll just swallow it
   FINALLY
       SELECT (m.liSelect)
       SET DATASESSION TO (m.liSession)
   ENDTRY            
   
ENDIF   

RETURN  m.liReturn
ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED7]
Changes default rendering behavior for report layout controls by rotating them according to a MemberData-specified number of degrees.[END RESERVED7]
[START RESERVED8]
reportlisteners.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] gfxrotate

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _19G1CFR95
[CLASS] xmldisplaylistener
[CLASSLOC] listener.vcx
[BASECLASS] reportlistener
[OBJNAME] htmllistener
[START PROPERTIES]
FRXDataSession = -1
ListenerType = 2
Name = "htmllistener"
_memberdata =     1855<VFPData> <memberdata name="imagefieldinstance" type="property" display="imageFieldInstance" favorites="False" /> <memberdata name="imagefieldtofile" type="property" display="imageFieldToFile" favorites="False" /> <memberdata name="imagefilebasename" type="property" display="imageFileBaseName" favorites="True" /> <memberdata name="imagesrcattr" type="property" display="imageSrcAttr" favorites="True" /> <memberdata name="jpgclsid" type="property" display="JPGclsid" favorites="False" /> <memberdata name="oldexternalfilelocation" type="property" display="oldExternalFileLocation" favorites="False" /> <memberdata name="oldsendgdiplusimage" type="property" display="oldSendGDIPlusImage" favorites="False" /> <memberdata name="checkreportforgeneralfields" type="method" display="checkReportForGeneralFields" favorites="False" /><memberdata name="getdefaultuserxsltasstring" type="method" display="getDefaultUserXsltAsString" favorites="False" /><memberdata name="initializefilecopysettings" type="method" display="initializeFileCopySettings" favorites="False"/><memberdata name="titleattr" display="titleAttr" type="property" favorites="True"/><memberdata name="linkattr" display="linkAttr" type="property" favorites="True"/><memberdata name="cssclassattr" display="cssClassAttr" type="property" favorites="True"/><memberdata name="cssclassoverrideattr" display="cssClassOverrideAttr" type="property" favorites="True"/><memberdata name="anchorattr" display="anchorAttr" type="property" favorites="True"/><memberdata name="oldpageimagetype" display="oldPageImageType" type="property"/><memberdata name="oldtextareasetting" display="oldTextAreaSetting" type="property"/><memberdata name="urlstringencode" type="method" favorites="True" display="urlStringEncode"/><memberdata name="pathencode" type="method" favorites="True" display="pathEncode"/></VFPData>
anchorattr = ("anchor")
applyusertransform = .T.
cssclassattr = ("css")
cssclassoverrideattr = ("CSS")
linkattr = ("hlink")
oldpageimagetype = -1
oldtextareasetting = -1
targetfileext = ("HTM")
titleattr = ("title")
[END PROPERTIES]
[START PROTECTED]
getdefaultuserxsltasstring
oldpageimagetype
oldtextareasetting
[END PROTECTED]
[START METHODS]
PROCEDURE AfterReport
LPARAMETERS tlCalledEarly
DODEFAULT(tlCalledEarly)
IF THIS.oldPageImageType <> -1
   THIS.pageImageType = THIS.oldPageImageType 
ENDIF
THIS.resetDataSession()
ENDPROC
PROCEDURE BeforeReport
DODEFAULT()

THIS.oldPageImageType = -1

IF THIS.XMLMode # OUTPUTXML_RDL_ONLY
   LOCAL llSetting, liSelect
   THIS.setFRXDataSession()
   IF USED(THIS.memberDataAlias)
      m.liSelect = SELECT(0)
      SELECT (THIS.memberDataAlias)
      LOCATE FOR Type == FRX_BLDR_MEMBERDATATYPE AND ;
                 Name == FRX_BLDR_NAMESPACE_ADVANCEDPROPS AND ;
                 ExecWhen == FRX_BLDR_ADVPROP_HTML_PAGEIMAGEHREF AND ;
                 THIS.evaluateStringToBoolean(Execute)         
      IF FOUND() AND THIS.pageImageType = 0
         THIS.oldPageImageType = 0
         THIS.pageImageType =  OUTPUTHTML_DEFAULT_PAGEIMAGE_TYPE
         IF THIS.ListenerType = LISTENER_TYPE_DEF
            THIS.ListenerType = LISTENER_TYPE_PAGED
         ENDIF
         IF THIS.supportsPageImages()  
            THIS.makeExternalFileLocationReachable() 
         ELSE
            IF NOT THIS.IsSuccessor
               THIS.pageImageType =  0      
            ENDIF
         ENDIF   
      ENDIF
      IF NOT THIS.CommandClauses.NoPageEject
         * we can only make this adjustment once per chain, 
         * since it can only be applied once per chain.
         * Last one wins.
         LOCATE FOR Type == FRX_BLDR_MEMBERDATATYPE AND ;
                    Name == FRX_BLDR_NAMESPACE_ADVANCEDPROPS AND ;
                    ExecWhen == FRX_BLDR_ADVPROP_HTML_TEXTAREAS_OFF 
         IF FOUND()
            llSetting = THIS.evaluateStringToBoolean(Execute)         
            IF VARTYPE(THIS.xsltParameters) = "O" AND ;
               THIS.xsltParameters.GetKey("useTextAreaForStretchingText") > 0
               THIS.oldTextAreaSetting = THIS.xsltParameters["useTextAreaForStretchingText"]
            ELSE
               THIS.oldTextAreaSetting = 1               
            ENDIF   
            THIS.adjustXSLTParameter( ;
                 IIF(llSetting,0,1),"useTextAreaForStretchingText")                     
         ENDIF                    
      ENDIF         
   ENDIF
ENDIF   
THIS.resetDataSession()
ENDPROC
PROCEDURE Init
IF DODEFAULT()
   THIS.AppName = OUTPUTHTML_APPNAME_LOC
ELSE
   RETURN .F.   
ENDIF

RETURN NOT THIS.HadError
ENDPROC
PROCEDURE anchorattr_assign
LPARAMETERS m.vNewVal
IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal) ;
   AND NOT (m.vNewVal == THIS.anchorAttr)
   THIS.anchorAttr = m.vNewVal
   THIS.SynchXSLTProcessorUser()
ENDIF   





ENDPROC
PROCEDURE applyusertransformtooutput
DODEFAULT()
IF THIS.oldTextAreaSetting <> -1
   THIS.adjustXSLTParameter( THIS.oldTextAreaSetting,"useTextAreaForStretchingText")                     
   THIS.oldTextAreaSetting = -1
ENDIF

ENDPROC
PROCEDURE cssclassattr_assign
LPARAMETERS m.vNewVal
IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal) ;
   AND NOT (m.vNewVal == THIS.cssClassAttr)
   THIS.cssClassAttr = m.vNewVal
   THIS.SynchXSLTProcessorUser()
ENDIF   






ENDPROC
PROCEDURE cssclassoverrideattr_assign
LPARAMETERS m.vNewVal
IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal) ;
   AND NOT (m.vNewVal == THIS.cssClassOverrideAttr)
   THIS.cssClassOverrideAttr = m.vNewVal
   THIS.SynchXSLTProcessorUser()
ENDIF   






ENDPROC
PROCEDURE fillruncollector
DODEFAULT()
IF NOT ISNULL(THIS.runCollector)
   * should have been taken care of by superclass
   THIS.setFRXDataSession()
   IF USED(THIS.memberDataAlias) 
      LOCAL m.lvValue, m.lcExpr, m.liSelect, m.loXML, m.loXMLTemp, m.loNode
      IF USED("FRX") 
         GO (THIS.frxHeaderRecno) IN FRX
         #IF OUTPUTXML = OUTPUTXML_DOM
            m.loXML = CREATEOBJECT(OUTPUTXML_DOMFREETHREADED_DOCUMENTOBJECT)
            m.loXMLTemp = CREATEOBJECT(OUTPUTXML_DOMFREETHREADED_DOCUMENTOBJECT)
         #ELSE
            m.loXML = CREATEOBJECT("Microsoft.XMLDOM")
            m.loXMLTemp = CREATEOBJECT("Microsoft.XMLDOM")
         #ENDIF      
         IF NOT m.loXML.LoadXML(FRX.Style)
            m.loXML = NULL
         ENDIF
      ENDIF      
      IF NOT ISNULL(m.loXML)
         m.liSelect = SELECT(0)
         SELECT (THIS.memberDataAlias)
         LOCATE FOR FRXRecno = THIS.frxHeaderRecno AND ;
                 Type = FRX_BLDR_MEMBERDATATYPE  ;
                 AND Name == FRX_BLDR_NAMESPACE_ADVANCEDPROPS ;
                 AND ExecWhen == FRX_BLDR_ADVPROP_HTML_HTTPEQUIV ;
                 AND VAL(DeClass) = ADVPROP_EDITMODE_TEXT ;
                 AND NOT EMPTY(Execute)
         IF FOUND()                 
            m.lvValue = ;
                      m.loXML.SelectSingleNode("/VFPData/reportdata" + ;
                      "[@name='" + Name + "' and @execwhen='" + ;
                      FRX_BLDR_ADVPROP_HTML_HTTPEQUIV + "']/@execute")
            IF (NOT ISNULL(m.lvValue)) AND ;
                 m.loXMLTemp.LoadXML(m.lvValue.Text)
                 m.loXML = m.loXMLTemp.SelectNodes("//meta")
                 FOR EACH m.loNode IN m.loXML
                    m.lcExpr = m.loNode.getAttribute("name")
                    m.lvValue = m.loNode.getAttribute("content")
                    IF NOT (ISNULL(m.lcExpr) OR ISNULL(m.lvValue) OR ;
                           EMPTY(m.lcExpr) OR EMPTY(m.lvValue))
                       IF VAL(m.loNode.getAttribute("type")) = ADVPROP_EDITMODE_GETEXPR
                          m.lvValue = THIS.evaluateUserExpression(m.lvValue)
                       ENDIF
                      IF THIS.runCollector.getKey(FRX_BLDR_ADVPROP_HTML_HTTPEQUIV+"." + m.lcExpr) = 0
                         THIS.runCollector.add(m.lvValue,FRX_BLDR_ADVPROP_HTML_HTTPEQUIV+"." + m.lcExpr)
                      ENDIF   
                   ENDIF  
                NEXT
            ENDIF                      
         ENDIF
         STORE NULL  TO m.loXML, m.loXMLTemp, m.loNode
         SELECT (liSelect)         
      ENDIF        
   ENDIF      
ENDIF

ENDPROC
PROCEDURE getdefaultuserxslt
LOCAL m.lcResult
m.lcResult = THIS.getDefaultUserXSLTAsString()

* document properties, general
m.lcResult = STRTRAN(m.lcResult,"@id='description'","@id='"+FRX_BLDR_ADVPROP_DESCRIPTION+"'")
m.lcResult = STRTRAN(m.lcResult,"@id='author'","@id='"+FRX_BLDR_ADVPROP_AUTHOR+"'")
m.lcResult = STRTRAN(m.lcResult,"@id='keywords'","@id='"+FRX_BLDR_ADVPROP_KEYWORDS+"'")
m.lcResult = STRTRAN(m.lcResult,"@id='title'","@id='"+FRX_BLDR_ADVPROP_TITLE+"'")
m.lcResult = STRTRAN(m.lcResult,"@id='copyright'","@id='"+FRX_BLDR_ADVPROP_COPYRIGHT+"'")
m.lcResult = STRTRAN(m.lcResult,"@id='date'","@id='"+FRX_BLDR_ADVPROP_DATE+"'")

* document properties, HTML-specific
m.lcResult = STRTRAN(m.lcResult,"@id='css_sheet'","@id='"+FRX_BLDR_ADVPROP_HTML_CSS_FILE +"'")
m.lcResult = STRTRAN(m.lcResult,"@id='http-equiv'","@id='"+FRX_BLDR_ADVPROP_HTML_HTTPEQUIV  +"'")

* base VFP-RDL XML characteristics set
m.lcResult = STRTRAN(m.lcResult,"@h","@"+ THIS.HeightAttr)
m.lcResult = STRTRAN(m.lcResult,"@w","@"+ THIS.WidthAttr)
m.lcResult = STRTRAN(m.lcResult,"@l","@"+ THIS.LeftAttr)
m.lcResult = STRTRAN(m.lcResult,"@t","@"+ THIS.TopAttr)
m.lcResult = STRTRAN(m.lcResult,"@c","@"+ THIS.ContAttr)
m.lcResult = STRTRAN(m.lcResult,"@idref","@"+ THIS.IdRefAttribute)
m.lcResult = STRTRAN(m.lcResult,"@id","@"+THIS.IdAttribute)
m.lcResult = STRTRAN(m.lcResult,"@img","@"+THIS.imageSrcAttr )

* dynamic data and page-image extension set implemented in XMLListener
m.lcResult = STRTRAN(m.lcResult,"@DTEXT","@"+THIS.dataTextAttr  )
m.lcResult = STRTRAN(m.lcResult,"@DTYPE","@"+THIS.dataTypeAttr  )
m.lcResult = STRTRAN(m.lcResult,"@PLINK","@"+THIS.pageImageAttr  )

* dynamic formatting extension set implemented in XMLDisplayListener
m.lcResult = STRTRAN(m.lcResult,"@PA","@"+THIS.penAlphaAttr  )
m.lcResult = STRTRAN(m.lcResult,"@PR","@"+THIS.penRedAttr  )
m.lcResult = STRTRAN(m.lcResult,"@PG","@"+THIS.penGreenAttr  )
m.lcResult = STRTRAN(m.lcResult,"@PB","@"+THIS.penBlueAttr  )
m.lcResult = STRTRAN(m.lcResult,"@FA","@"+THIS.fillAlphaAttr  )
m.lcResult = STRTRAN(m.lcResult,"@FR","@"+THIS.fillRedAttr  )
m.lcResult = STRTRAN(m.lcResult,"@FG","@"+THIS.fillGreenAttr  )
m.lcResult = STRTRAN(m.lcResult,"@FB","@"+THIS.fillBlueAttr  )
m.lcResult = STRTRAN(m.lcResult,"@FNAME","@"+THIS.fontNameAttr  )
m.lcResult = STRTRAN(m.lcResult,"@FSIZE","@"+THIS.fontSizeAttr  )
m.lcResult = STRTRAN(m.lcResult,"@FSTYLE","@"+THIS.fontStyleAttr  )

* dynamic HTML extension set implemented in this class
m.lcResult = STRTRAN(m.lcResult,"@title","@"+THIS.titleAttr )
m.lcResult = STRTRAN(m.lcResult,"@alt","@"+THIS.titleAttr )
m.lcResult = STRTRAN(m.lcResult,"@css","@"+THIS.cssClassAttr )
m.lcResult = STRTRAN(m.lcResult,"@CSS","@"+THIS.cssClassOverrideAttr )
m.lcResult = STRTRAN(m.lcResult,"@anchor","@"+THIS.anchorAttr )
m.lcResult = STRTRAN(m.lcResult,"@hlink","@"+THIS.linkAttr )

THIS.XSLTProcessorUser = m.lcResult



ENDPROC
PROCEDURE getdefaultuserxsltasstring
LOCAL m.lcResult
SET TEXTMERGE TO MEMVAR m.lcResult NOSHOW
SET TEXTMERGE ON 
TEXT
<?xml version="1.0"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
  <xsl:output method="html" version="1.0" encoding="UTF-8" indent="no" doctype-public="-//W3C//DTD HTML 4.0//EN" doctype-system="http://www.w3.org/TR/REC-html40/strict.dtd"/>

  <xsl:param name="externalFileLocation"/>
  <!--select="'./whatever/'" or 'http://something/myimages/' or "'./'" or... -->
  <xsl:param name="copyImageFiles" select="0"/>
  <xsl:param name="generalFieldDPI" select="96"/>
  <xsl:param name="fillPatternShade" select="180*3"/>
  <xsl:param name="fillPatternOffset" select="128"/>
  <xsl:param name="numberPrecision" select="5"/>
  <xsl:param name="fieldAlphaOpacityOffset" select="75"/>
  <xsl:param name="fieldAlphaOpacityShade" select="180*3"/>
  <xsl:param name="useTextAreaForStretchingText" select="1"/>
  <xsl:param name="hideScrollbarsForTextAreas" select="0"/>
  <xsl:param name="PageTitlePrefix_LOC" select="''"/>
<!--    <xsl:param name="unpagedModeIncludesOnePageHeader" select="0"/> -->
  <xsl:param name="unpagedModeIncludesTitle" select="1"/>
  <xsl:param name="noBody" select="0"/>
  <xsl:param name="useDynamicTextAttributes" select="1"/>
  <xsl:param name="anchorAttrName" select="1"/>   
  <!-- id is theoretically better if you wanted to write
   script against this element, or in case name is 
   deprecated in a future version of the standard, 
   but a value of 1 forces name to be used instead. 
   Current-newer browsers will be okay with this, and older 
   browsers might prefer it. -->
  <xsl:variable name="FRUs" select="10000"/>
  <xsl:variable name="printDPI" select="960"/>
  <xsl:variable name="FRUsInPixelsat96DPI" select="104.167"/>
  <xsl:variable name="imagePixelRatio" select="$generalFieldDPI div $printDPI"/>
  <xsl:variable name="zeros" select="substring('0000000000000000000000000',1,$numberPrecision)"/>
  <xsl:variable name="thisPageHeight">
    <xsl:value-of select="number(/Reports/VFP-Report/VFP-RDL/VFPDataSet/VFPFRXPrintJob/@pageheight  div $printDPI)"/>
  </xsl:variable>
  <xsl:variable name="lineNodeName" select="/Reports/VFP-Report/VFP-RDL/VFPDataSet/VFPFRXLayoutNode[type=6]/name"/>
  <xsl:variable name="labelNodeName" select="/Reports/VFP-Report/VFP-RDL/VFPDataSet/VFPFRXLayoutNode[type=5]/name"/>
  <xsl:variable name="fieldNodeName" select="/Reports/VFP-Report/VFP-RDL/VFPDataSet/VFPFRXLayoutNode[type=8]/name"/>
  <xsl:variable name="shapeNodeName" select="/Reports/VFP-Report/VFP-RDL/VFPDataSet/VFPFRXLayoutNode[type=7]/name"/>
  <xsl:variable name="pictureNodeName" select="/Reports/VFP-Report/VFP-RDL/VFPDataSet/VFPFRXLayoutNode[type=17]/name"/>
  <xsl:variable name="detailNodeName" select="/Reports/VFP-Report/VFP-RDL/VFPDataSet/VFPFRXLayoutNode[code=4]/name"/>
  <xsl:variable name="detailHeaderNodeName" select="/Reports/VFP-Report/VFP-RDL/VFPDataSet/VFPFRXLayoutNode[code=9]/name"/>
  <xsl:variable name="detailFooterNodeName" select="/Reports/VFP-Report/VFP-RDL/VFPDataSet/VFPFRXLayoutNode[code=10]/name"/>
  <xsl:variable name="pageHeaderNodeName" select="/Reports/VFP-Report/VFP-RDL/VFPDataSet/VFPFRXLayoutNode[code=1]/name"/>
  <xsl:variable name="pageFooterNodeName" select="/Reports/VFP-Report/VFP-RDL/VFPDataSet/VFPFRXLayoutNode[code=7]/name"/>
  <xsl:variable name="columnHeaderNodeName" select="/Reports/VFP-Report/VFP-RDL/VFPDataSet/VFPFRXLayoutNode[code=2]/name"/>
  <xsl:variable name="columnFooterNodeName" select="/Reports/VFP-Report/VFP-RDL/VFPDataSet/VFPFRXLayoutNode[code=6]/name"/>
  <xsl:variable name="groupHeaderNodeName" select="/Reports/VFP-Report/VFP-RDL/VFPDataSet/VFPFRXLayoutNode[code=3]/name"/>
  <xsl:variable name="groupFooterNodeName" select="/Reports/VFP-Report/VFP-RDL/VFPDataSet/VFPFRXLayoutNode[code=5]/name"/>
  <xsl:variable name="titleNodeName" select="/Reports/VFP-Report/VFP-RDL/VFPDataSet/VFPFRXLayoutNode[code=0]/name"/>
  <xsl:variable name="summaryNodeName" select="/Reports/VFP-Report/VFP-RDL/VFPDataSet/VFPFRXLayoutNode[code=8]/name"/>
  <xsl:variable name="anchorAttr">
  <xsl:choose>
  <xsl:when test="$anchorAttrName=1">name</xsl:when>
  <xsl:otherwise>id</xsl:otherwise>
  </xsl:choose> 
  </xsl:variable>


  <xsl:key name="Layout" match="/Reports/VFP-Report/VFP-RDL/VFPDataSet/VFPFRXLayoutObject[platform='WINDOWS']" use="concat(frxrecno,../../@id)"/>


  <xsl:template match="/">
      <xsl:choose>
        <xsl:when test="number($noBody)=1">
        <div>
         <meta http-equiv="Content-Type"  content="text/html; charset=UTF-8"/>        
          <xsl:call-template name="renderStyles"/>
          <xsl:call-template name="body"/>
         </div>
        </xsl:when>
        <xsl:otherwise>
          <xsl:apply-templates select="/" mode="full"/>
        </xsl:otherwise>
      </xsl:choose>
  </xsl:template>
  <xsl:template match="/" mode="full">
    <html>
       <xsl:if test="/Reports/VFP-Report[1]/VFP-RDL/VFPDataSet/VFPFRXLayoutObject[objtype=1 and (fontcharset=177 or fontcharset=178)]">
       <xsl:attribute name="dir">rtl</xsl:attribute>
       </xsl:if>
      <head>
        <meta  http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<xsl:comment> 
the above repeated-explicit declaration is necessary because 
some versions of MSXML xslt processing don't include the 
charset as required by the XSLT standard when method="html".  
Explicitly including the META creates a doubled meta content-type tag, 
but we do need the encoding to be specified properly and the doubled tag is okay. 
</xsl:comment>
        <meta name="description" 
content="{/Reports/VFP-Report[1]/Run/property[@id='description']/.}"/>
        <meta name="author" 
content="{/Reports/VFP-Report[1]/Run/property[@id='author']/.}"/>
        <meta name="copyright" 
content="{/Reports/VFP-Report[1]/Run/property[@id='copyright']/.}"/>
        <meta name="date" 
content="{/Reports/VFP-Report[1]/Run/property[@id='date']/.}"/>
        <xsl:if test="/Reports/VFP-Report/Run/property[@id='keywords']">
        <meta name="keywords">
        <xsl:attribute name="content">
         <xsl:for-each select="/Reports/VFP-Report/Run/property[@id='keywords']">
         <xsl:value-of select="."/><xsl:if test="not(position()=last())">,</xsl:if>
        </xsl:for-each>
        </xsl:attribute>
        </meta> 
        </xsl:if>
        <xsl:if test="/Reports/VFP-Report/Run/property[@id='http-equiv']">
            <xsl:for-each select="/Reports/VFP-Report/Run/property[@id='http-equiv']//meta">
          <xsl:variable name="thisMeta" select="concat(ancestor-or-self::*[@id='http-equiv']/@id ,'.',@name)"/>
          <!-- the extra Run nodes being looked up are potentially evaluated, not original values of the property, 
          so we can account for expressions -->
          <meta  http-equiv="{@name}" content="{/Reports/VFP-Report/Run/property[@id=$thisMeta]}"/>
          </xsl:for-each>
        </xsl:if>

        <title>
          <xsl:choose>
          <xsl:when test="/Reports/VFP-Report[1]/Run/property[@id='title']">
            <xsl:value-of select="/Reports/VFP-Report[1]/Run/property[@id='title']/."/>
          </xsl:when>
          <xsl:otherwise>
            <!-- default/VFP 9.0 RTM handling -->
             <xsl:value-of select="$PageTitlePrefix_LOC"/>
             <xsl:if test="string-length(/Reports/VFP-Report[1]/VFP-RDL/VFPDataSet/VFPFRXPrintJob/@name) = 0">
               <xsl:value-of select="/Reports/VFP-Report[1]/VFP-RDL/@id"/>
             </xsl:if>
             <xsl:value-of select="/Reports/VFP-Report[1]/VFP-RDL/VFPDataSet/VFPFRXPrintJob/@name"/>
          </xsl:otherwise>
          </xsl:choose>
        </title>
        <xsl:call-template name="renderStyles"/>
      </head>
      <body>
        <xsl:call-template name="body"/>
      </body>
    </html>
  </xsl:template>
  <xsl:template name="renderStyles">
     <xsl:call-template name="DocumentStyles"/>
    <xsl:for-each select="/Reports/VFP-Report">
      <xsl:call-template name="Styles">
        <xsl:with-param name="thisReport" select="position()"/>
        <xsl:with-param name="thisReportID" select="./VFP-RDL/@id"/>
      </xsl:call-template>
      <!--        <xsl:call-template name="Script"/> avoid security problems: no script, not even a lone comment indicating TBD -->
    </xsl:for-each>
  </xsl:template>
  <xsl:template name="body">
    <xsl:for-each select="/Reports/VFP-Report">
      <xsl:variable name="thisReport" select="position()"/>
      <xsl:variable name="thisReportID" select="./VFP-RDL/@id"/>
      <xsl:variable name="thisReportRangeFrom" select="number(./VFP-RDL/VFPDataSet/VFPFRXCommand/@RANGEFROM)"/>
      <xsl:variable name="separateTitlePage" select="./Data/*[name()=$titleNodeName] and ./VFP-RDL/VFPDataSet/VFPFRXLayoutObject[bandtype='0' and pagebreak='true']"/>
      <xsl:variable name="separateSummaryPage" select="./Data/*[name()=$summaryNodeName] and ./VFP-RDL/VFPDataSet/VFPFRXLayoutObject[bandtype='8' and pagebreak='true' and ejectbefor='false']"/>
      <xsl:variable name="reportPages" select="count(./Data/*[(name()=$pageHeaderNodeName) or (name()=$titleNodeName and $separateTitlePage=true()) or  (name()=$summaryNodeName and $separateSummaryPage=true())])"/>
      <div>
        <xsl:if test="number($noBody)=1">
          <xsl:attribute name="style">
               position=relative;height=<xsl:value-of select="$reportPages * $thisPageHeight"/>in;
               </xsl:attribute>
        </xsl:if>
        <xsl:choose>
          <xsl:when test="./Data/*[name() = $pageHeaderNodeName]">
            <xsl:if test="$separateTitlePage">
              <xsl:apply-templates select="./Data/*[name()=$titleNodeName]" mode="titlesummarypage">
                <xsl:with-param name="thisReport" select="$thisReport"/>
                <xsl:with-param name="thisReportID" select="$thisReportID"/>
              </xsl:apply-templates>
            </xsl:if>
            <xsl:apply-templates select="./Data/*[name()=$pageHeaderNodeName]" mode="page">
              <xsl:with-param name="thisReport" select="$thisReport"/>
              <xsl:with-param name="thisReportID" select="$thisReportID"/>
              <xsl:with-param name="thisReportRangeFrom" select="$thisReportRangeFrom"/>
            </xsl:apply-templates>
            <xsl:if test="$separateSummaryPage">
              <xsl:apply-templates select="./Data/*[name()=$summaryNodeName]" mode="titlesummarypage">
                <xsl:with-param name="thisReport" select="$thisReport"/>
                <xsl:with-param name="thisReportID" select="$thisReportID"/>
              </xsl:apply-templates>
            </xsl:if>
          </xsl:when>
          <xsl:otherwise>
            <!-- unpaginated-->
            <xsl:variable name="thisPageHeaderHeight" select="/Reports/VFP-Report[$thisReport]/VFP-RDL/VFPDataSet/VFPFRXLayoutObject[bandlabel='Page Header'][1]/height  div $FRUs"/>
            <xsl:variable name="thisReportPageHeight" select="number($thisPageHeight - ( $thisPageHeaderHeight +  (/Reports/VFP-Report[$thisReport]/VFP-RDL/VFPDataSet/VFPFRXLayoutObject[bandlabel='Page Footer'][1]/height div $FRUs)) )"/>
            <xsl:if test="./Data/Pages/*[name() = $pageHeaderNodeName]"> <!-- $unpagedModeIncludesOnePageHeader=1" -->
              <!-- show the contents of the first page header -->
              <xsl:apply-templates mode="formattingBand" select="./Data/Pages/*[@idref = /Reports/VFP-Report[$thisReport]/VFP-RDL/VFPDataSet/VFPFRXLayoutObject[bandlabel='Page Header']/frxrecno][1]">
                <xsl:with-param name="thisReport" select="$thisReport"/>
                <xsl:with-param name="thisReportID" select="$thisReportID"/>
                <xsl:with-param name="thisReportPageHeight" select="$thisReportPageHeight"/>
                <xsl:with-param name="thisPageHeight" select="$thisPageHeight"/>
              </xsl:apply-templates>
            </xsl:if>
            
            <!-- the @id criteria below leaves out the Pages and Columns collections, if any -->
            <!-- we could add in an initial page header but then we'd have to do the additional work to handle any title, etc; all the height offsets will change -->
            <xsl:apply-templates select="./Data/*[@idref and ($unpagedModeIncludesTitle=1 or not(name() = $titleNodeName))]" mode="unpagedBand">
              <xsl:with-param name="thisReport" select="$thisReport"/>
              <xsl:with-param name="thisReportID" select="$thisReportID"/>
              <xsl:with-param name="thisPageHeight" select="$thisPageHeight"/>
              <xsl:with-param name="thisReportPageHeight" select="$thisReportPageHeight"/>
              <xsl:with-param name="thisPageHeaderHeight" select="$thisPageHeaderHeight"/>
            </xsl:apply-templates>
          </xsl:otherwise>
        </xsl:choose>
      </div>
    </xsl:for-each>
  </xsl:template>
  <xsl:template match="/Reports/VFP-Report/Data/*" mode="titlesummarypage">
    <xsl:param name="thisReport" select="1"/>
    <xsl:param name="thisReportID"/>
    <xsl:param name="thisReportRangeFrom" select="1"/>
    <xsl:variable name="thisBand" select="@id"/>
    <div>
      <xsl:attribute name="style"> width:100%;top:<xsl:value-of select="$thisPageHeight * (number( ./@idref) -$thisReportRangeFrom)"/>in; position:absolute; </xsl:attribute>
      <xsl:apply-templates select="." mode="band">
        <xsl:with-param name="thisReport" select="$thisReport"/>
        <xsl:with-param name="thisReportID" select="$thisReportID"/>
      </xsl:apply-templates>
      <xsl:if test="/Reports/VFP-Report[$thisReport]/VFP-RDL/VFPDataSet/VFPFRXLayoutObject[frxrecno=$thisBand and ejectafter='true']">
        <!-- page footer for this summary page -->
        <xsl:apply-templates select="/Reports/VFP-Report[$thisReport]/Data/*[name()=$pageFooterNodeName][position()=last()]" mode="band">
          <xsl:with-param name="thisReport" select="$thisReport"/>
          <xsl:with-param name="thisReportID" select="$thisReportID"/>
        </xsl:apply-templates>
      </xsl:if>
    </div>
  </xsl:template>
  <xsl:template match="/Reports/VFP-Report/Data/*" mode="page">
    <xsl:param name="thisReport" select="1"/>
    <xsl:param name="thisReportID"/>
    <xsl:param name="thisReportRangeFrom" select="1"/>
    <xsl:variable name="thisPage" select="@id"/>
    <div>
      <xsl:attribute name="style"> width:100%;top:<xsl:value-of select="$thisPageHeight * ($thisPage -$thisReportRangeFrom)"/>in;position:absolute; </xsl:attribute>
      <xsl:apply-templates select="." mode="band">
        <xsl:with-param name="thisReport" select="$thisReport"/>
        <xsl:with-param name="thisReportID" select="$thisReportID"/>
      </xsl:apply-templates>
      <xsl:if test="$thisPage = 1 and /Reports/VFP-Report[$thisReport]/Data/*[name()=$titleNodeName] and /Reports/VFP-Report[$thisReport]/VFP-RDL/VFPDataSet/VFPFRXLayoutObject[bandtype='0' and pagebreak='false']">
        <xsl:apply-templates select="/Reports/VFP-Report[$thisReport]/Data/*[name()=$titleNodeName]" mode="band">
          <xsl:with-param name="thisReport" select="$thisReport"/>
          <xsl:with-param name="thisReportID" select="$thisReportID"/>
        </xsl:apply-templates>
      </xsl:if>
      <xsl:apply-templates select="/Reports/VFP-Report/Data/*[( (@id=$thisPage and contains(concat('|',$pageFooterNodeName,'|',$columnHeaderNodeName,'|',$columnFooterNodeName,'|'),concat('|',name(),'|'))) or (@idref=$thisPage and contains(concat('|',$detailHeaderNodeName,'|',$detailFooterNodeName,'|',$detailNodeName,'|',$groupHeaderNodeName,'|',$groupFooterNodeName,'|',$summaryNodeName,'|'),concat('|',name(),'|'))) )]" mode="band">
        <xsl:with-param name="thisReport" select="$thisReport"/>
        <xsl:with-param name="thisReportID" select="$thisReportID"/>
      </xsl:apply-templates>
    </div>
  </xsl:template>
  <xsl:template match="/Reports/VFP-Report/Data/Pages/*" mode="formattingBand">
    <xsl:param name="thisReport" select="1"/>
    <xsl:param name="thisReportID"/>
    <xsl:param name="thisPageHeight"/>
    <xsl:param name="thisReportPageHeight"/>
    <xsl:variable name="thisPage" select="@id"/>
    <xsl:variable name="thisPageRenderOffset" select="(($thisPage - 1) * $thisReportPageHeight)  + sum((/Reports/VFP-Report[position() &lt; $thisReport]/VFP-RDL/VFPDataSet/VFPFRXLayoutObject[bandlabel='Page Header']/height) ) "/>
    <xsl:for-each select="./*">
      <xsl:variable name="thisID" select="translate(@id,'+','')"/>
      <xsl:call-template name="Render">
        <xsl:with-param name="thisID" select="$thisID"/>
        <xsl:with-param name="thisZ" select="position()"/>
        <xsl:with-param name="thisPage" select="../@idref"/>
        <xsl:with-param name="thisReport" select="$thisReport"/>
        <xsl:with-param name="thisReportID" select="$thisReportID"/>
        <xsl:with-param name="topOffset" select="number($thisPageRenderOffset) * $printDPI"/>
      </xsl:call-template>
    </xsl:for-each>
  </xsl:template>
  <xsl:template match="/Reports/VFP-Report/Data/*" mode="unpagedBand">
      <xsl:param name="thisReport" select="1"/>
    <xsl:param name="thisReportID"/>
    <xsl:param name="thisPageHeight"/>
    <xsl:param name="thisReportPageHeight"/>
    <xsl:param name="thisPageHeaderHeight"/>
    <xsl:variable name="thisPage" select="@idref"/>
    <xsl:variable name="thisPageRenderOffset">
      <xsl:choose>
        <xsl:when test="../Pages/*[name() = $pageHeaderNodeName]"> <!-- $unpagedModeIncludesOnePageHeader=1" -->
          <xsl:value-of select="(($thisPage - 1) * $thisReportPageHeight) + (sum(/Reports/VFP-Report[position() &lt; $thisReport]/VFP-RDL/VFPDataSet/VFPFRXLayoutObject[bandlabel='Page Header'][1]/height)div $FRUs)  + $thisPageHeaderHeight "/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="(($thisPage - 1) * $thisReportPageHeight) -($thisPageHeaderHeight*$thisPage)  "/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:call-template name="addAnchor"/>
    <xsl:for-each select="./*">
      <xsl:variable name="thisID" select="translate(@id,'+','')"/>
      <xsl:call-template name="Render">
        <xsl:with-param name="thisID" select="$thisID"/>
        <xsl:with-param name="thisZ" select="position()"/>
        <xsl:with-param name="thisPage" select="../@idref"/>
        <xsl:with-param name="thisReport" select="$thisReport"/>
        <xsl:with-param name="thisReportID" select="$thisReportID"/>
        <xsl:with-param name="topOffset" select="number($thisPageRenderOffset) * $printDPI"/>
      </xsl:call-template>
    </xsl:for-each>
  </xsl:template>

  <xsl:template match="/Reports/VFP-Report/Data/*" mode="band">
    <xsl:param name="thisReport" select="1"/>
    <xsl:param name="thisReportID"/>
    <xsl:call-template name="addAnchor"/>
    <xsl:for-each select="./*">
      <xsl:variable name="thisID" select="translate(@id,'+','')"/>
      <!--        <xsl:if test="key('Layout',concat($thisID, $thisReportID))/vpos &gt; key('Layout',preceding-sibling::*/concat(@id,$thisReportID))/vpos"><div style="position=absolute;"/></xsl:if>  -->
      <xsl:call-template name="Render">
        <xsl:with-param name="thisID" select="$thisID"/>
        <xsl:with-param name="thisZ" select="position()"/>
        <xsl:with-param name="thisPage" select="../@idref"/>
        <xsl:with-param name="thisReport" select="$thisReport"/>
        <xsl:with-param name="thisReportID" select="$thisReportID"/>
      </xsl:call-template>
    </xsl:for-each>
  </xsl:template>
  <xsl:template name="Render">
    <xsl:param name="thisID"/>
    <xsl:param name="thisZ"/>
    <xsl:param name="thisPage"/>
    <xsl:param name="thisReport" select="1"/>
    <xsl:param name="thisReportID" select="1"/>
    <xsl:param name="topOffset" select="0"/>
    <xsl:call-template name="addAnchor"/>
    <xsl:choose>
      <xsl:when test="name()=$lineNodeName and key('Layout',concat($thisID, $thisReportID))/height &lt;  key('Layout',concat($thisID, $thisReportID))/width">
        <hr>
          <xsl:call-template name="addClassAttribute">
        <xsl:with-param name="default" select="concat('FRX',$thisReport,'_',$thisID)"/> 
        </xsl:call-template>
        <xsl:call-template name="addTitleAttribute"/>
          <xsl:call-template name="addStyleAttribute">
            <xsl:with-param name="topOffset" select="$topOffset"/>
            <xsl:with-param name="thisZ" select="$thisZ"/>
            <xsl:with-param name="thisReportID" select="$thisReportID"/>
           <xsl:with-param name="thisID" select="$thisID"/>
           <xsl:with-param name="styleType" select="'HR'"/>
          </xsl:call-template>
        </hr>
      </xsl:when>
      <xsl:when test="name()=$lineNodeName">
        <!-- vertical line -->
        <span>
          <xsl:call-template name="addClassAttribute">
            <xsl:with-param name="default" select="concat('FRX',$thisReport,'_',$thisID)"/> 
        </xsl:call-template>
          <xsl:call-template name="addTitleAttribute"/>
          <xsl:call-template name="addStyleAttribute">
            <xsl:with-param name="topOffset" select="$topOffset"/>
            <xsl:with-param name="thisZ" select="$thisZ"/>
            <xsl:with-param name="thisReportID" select="$thisReportID"/>
           <xsl:with-param name="thisID" select="$thisID"/>
              <xsl:with-param name="styleType" select="'VR'"/>
          </xsl:call-template>
        </span>
      </xsl:when>
      <xsl:when test="$useTextAreaForStretchingText=1 and string-length(@hlink) = 0  and name()=$fieldNodeName and key('Layout',concat($thisID, $thisReportID))[stretch='true']">
        <textarea readonly="readonly" rows="0" cols="0">
          <xsl:call-template name="addClassAttribute">
             <xsl:with-param name="default" select="concat('FRX',$thisReport,'_',$thisID)"/> 
        </xsl:call-template>
          <xsl:call-template name="addTitleAttribute"/>
          <xsl:call-template name="addStyleAttribute">
            <xsl:with-param name="topOffset" select="$topOffset"/>
            <xsl:with-param name="thisZ" select="$thisZ"/>
            <xsl:with-param name="thisReportID" select="$thisReportID"/>
          <xsl:with-param name="thisID" select="$thisID"/>
          <xsl:with-param name="styleType" select="'TextArea'"/>
          </xsl:call-template>
          <xsl:value-of select="."/>
        </textarea>
      </xsl:when>
      <xsl:otherwise>
        <div>
          <xsl:call-template name="addClassAttribute">
            <xsl:with-param name="default" select="concat('FRX',$thisReport,'_',$thisID)"/> 
        </xsl:call-template>
          <xsl:call-template name="addTitleAttribute"/>
          <xsl:call-template name="addStyleAttribute">
            <xsl:with-param name="topOffset" select="$topOffset"/>
            <xsl:with-param name="thisZ" select="$thisZ"/>
            <xsl:with-param name="thisReportID" select="$thisReportID"/>
          <xsl:with-param name="thisID" select="$thisID"/>
          <xsl:with-param name="styleType" select="'Div'"/>
          </xsl:call-template>
          <xsl:choose>
            <xsl:when test="name()=$shapeNodeName or name()=$lineNodeName">
              <!-- nothing -->
            </xsl:when>
            <xsl:when test="name()=$pictureNodeName and string-length(@hlink) &gt; 0">
              <a href="{@hlink}">
                <xsl:call-template name="renderPicture">
            <xsl:with-param name="thisReportID" select="$thisReportID"/>
            <xsl:with-param name="thisID" select="$thisID"/>
                </xsl:call-template>
              </a>
            </xsl:when>
            <xsl:when test="name()=$pictureNodeName and string-length(@PLINK) &gt; 0">
              <a href="{translate(@PLINK,'\','/')}"  target="blank">
                <xsl:call-template name="renderPicture">
            <xsl:with-param name="thisReportID" select="$thisReportID"/>
            <xsl:with-param name="thisID" select="$thisID"/>
                </xsl:call-template>
              </a>
            </xsl:when>
            <xsl:when test="name()=$pictureNodeName">
              <xsl:call-template name="renderPicture">
            <xsl:with-param name="thisReportID" select="$thisReportID"/>
            <xsl:with-param name="thisID" select="$thisID"/>
              </xsl:call-template>
            </xsl:when>
            <xsl:when test="string-length(@hlink) &gt; 0">
              <a href="{@hlink}">
                <xsl:call-template name="replaceText"/>
              </a>
            </xsl:when>
            <xsl:when test="string-length(@PLINK) &gt; 0">
              <a href="{translate(@PLINK,'\','/')}" target="blank">
                <xsl:call-template name="replaceText"/>
              </a>
            </xsl:when>
            <xsl:otherwise>
              <xsl:call-template name="replaceText"/>
            </xsl:otherwise>
          </xsl:choose>
        </div>
      </xsl:otherwise>
    </xsl:choose>
    <!-- /xsl:if -->
  </xsl:template>
  <xsl:template name="getCSSName">
  <xsl:param name="thisReport" select="1"/>
  <xsl:param name="thisItem" select="0"/>
  <xsl:param name="firstPass" select="1"/>
  <xsl:variable name="subst" select="/Reports/VFP-Report[$thisReport]/Data/*/*[@id=$thisItem]/@css"/>
    <xsl:choose>
     <xsl:when test="number($firstPass)=1 or string-length($subst) = 0"><xsl:value-of select="concat('.FRX',$thisReport,'_',$thisItem)"/></xsl:when>
     <xsl:otherwise>.<xsl:value-of select="$subst"/></xsl:otherwise>
     </xsl:choose>
  </xsl:template>
  <xsl:template match="VFPFRXLayoutObject" mode="imagestyles">
    <xsl:param name="thisReport" select="1"/>
    <xsl:param name="firstPass" select="1"/>
     <xsl:call-template name="getCSSName">
     <xsl:with-param name="thisReport" select="$thisReport"/>
     <xsl:with-param name="thisItem" select="frxrecno"/>
     <xsl:with-param name="firstPass" select="$firstPass"/>
     </xsl:call-template>{
  position: absolute;overflow: hidden;width: <xsl:call-template name="setPrecision"><xsl:with-param name="theNumber" select="width div $FRUs"/></xsl:call-template>in;height: <xsl:call-template name="setPrecision"><xsl:with-param name="theNumber" select="height div $FRUs"/></xsl:call-template>in;
  }
  <!-- <xsl:if test="offset=0">
left: <xsl:value-of select="hpos div $FRUs"/>in; 
</xsl:if>
<xsl:if test="offset=2">
left: <xsl:value-of select="hpos div $FRUs"/>in; 
</xsl:if> -->
 </xsl:template>
  <xsl:template match="VFPFRXLayoutObject" mode="shapestyles">
    <xsl:param name="thisReport" select="1"/>
   <xsl:param name="firstPass" select="1"/>
     <xsl:call-template name="getCSSName">
     <xsl:with-param name="thisReport" select="$thisReport"/>
     <xsl:with-param name="thisItem" select="frxrecno"/>
     <xsl:with-param name="firstPass" select="$firstPass"/>
     </xsl:call-template>{
   position: absolute ;font-size:1pt; border: <xsl:value-of select="pensize"/>px <xsl:call-template name="pattern"/><xsl:call-template name="pencolor"/>;<xsl:if test="(mode=0 and not(fillpat=0)) or (mode=1 and fillpat=1)">background-color:<xsl:call-template name="fillcolor"/>;</xsl:if>width: <xsl:call-template name="setPrecision"> <xsl:with-param name="theNumber" select="width div $FRUs"/></xsl:call-template>in;left: <xsl:call-template name="setPrecision"><xsl:with-param name="theNumber" select="hpos div $FRUs"/></xsl:call-template>in;
      }
      <!--    <xsl:if test="stretch='true'">
overflow: auto;
   </xsl:if> -->
  </xsl:template>
  <xsl:template match="VFPFRXLayoutObject" mode="textstyles">
    <xsl:param name="thisReport" select="1"/>
    <xsl:param name="firstPass" select="1"/>
     <xsl:call-template name="getCSSName">
     <xsl:with-param name="thisReport" select="$thisReport"/>
     <xsl:with-param name="thisItem" select="frxrecno"/>
     <xsl:with-param name="firstPass" select="$firstPass"/>
     </xsl:call-template>{
  <xsl:call-template name="getTextAlignment"/>vertical-align: top; font-family: "<xsl:value-of select="fontface"/>"; font-size: <xsl:value-of select="fontsize"/>pt; border: 0px none; padding: 0px; margin: 0px;<xsl:call-template name="getFontAttributes"/>color:<xsl:call-template name="pencolor"/>;<xsl:choose>
      <xsl:when test="mode mod 2 = 1">background-color:transparent;</xsl:when>
      <xsl:otherwise>background-color: <xsl:call-template name="fillcolor"/>;</xsl:otherwise>
    </xsl:choose><xsl:choose>
      <xsl:when test="stretch='true' and objtype=8 and $useTextAreaForStretchingText=1 and $hideScrollbarsForTextAreas=1"> overflow:hidden;margin-top:4px;</xsl:when>
      <xsl:when test="stretch='true' and objtype=8 and $useTextAreaForStretchingText=1"> overflow: auto;margin-top:4px;</xsl:when>
      <xsl:otherwise>overflow:hidden;</xsl:otherwise>
    </xsl:choose> position: absolute;
   }   
    <!-- tbd, make vertical-align more dynamic -->  
  </xsl:template>
  <xsl:template match="VFPFRXLayoutObject" mode="linestyles">
    <xsl:param name="thisReport" select="1"/>
   <xsl:param name="firstPass" select="1"/>
     <xsl:call-template name="getCSSName">
     <xsl:with-param name="thisReport" select="$thisReport"/>
     <xsl:with-param name="thisItem" select="frxrecno"/>
      <xsl:with-param name="firstPass" select="$firstPass"/>
     </xsl:call-template>{
   position:absolute;font-size:1pt;border: <xsl:value-of select="pensize"/>px <xsl:call-template name="pattern"/><xsl:call-template name="pencolor"/>;left: <xsl:value-of select="hpos div $FRUs"/>in;
      <xsl:choose>
      <xsl:when test="height &lt; width"> width: <xsl:value-of select="width div $FRUs"/>in;
  height: <xsl:value-of select="floor(height div $FRUsInPixelsat96DPI)"/>px; margin: 0px;</xsl:when>
      <xsl:otherwise>  height: <xsl:value-of select="height div $FRUs"/>in;
  width: <xsl:value-of select="floor(width div $FRUsInPixelsat96DPI)"/>px;  </xsl:otherwise>
    </xsl:choose>
   }
  </xsl:template>
  <xsl:template name="pattern">
    <xsl:choose>
      <xsl:when test="penpat=0"> none </xsl:when>
      <xsl:when test="penpat=1"> dotted </xsl:when>
      <xsl:when test="penpat=2"> dashed </xsl:when>
      <xsl:otherwise> solid </xsl:otherwise>
    </xsl:choose>
  </xsl:template>
  <xsl:template name="pencolor">#<xsl:call-template name="getHexColorValue">
      <xsl:with-param name="theNumber" select="penred"/>
    </xsl:call-template>
    <xsl:call-template name="getHexColorValue">
      <xsl:with-param name="theNumber" select="pengreen"/>
    </xsl:call-template>
    <xsl:call-template name="getHexColorValue">
      <xsl:with-param name="theNumber" select="penblue"/>
    </xsl:call-template>
  </xsl:template>
  <xsl:template name="fillcolor">#<xsl:call-template name="getHexColorValue">
      <xsl:with-param name="theNumber" select="fillred"/>
      <xsl:with-param name="fill" select="1"/>
    </xsl:call-template>
    <xsl:call-template name="getHexColorValue">
      <xsl:with-param name="theNumber" select="fillgreen"/>
      <xsl:with-param name="fill" select="1"/>
    </xsl:call-template>
    <xsl:call-template name="getHexColorValue">
      <xsl:with-param name="theNumber" select="fillblue"/>
      <xsl:with-param name="fill" select="1"/>
    </xsl:call-template>
  </xsl:template>
  <xsl:template name="getFontAttributes">
    <xsl:param name="theStyles" select="0"/>
    <xsl:choose>
      <xsl:when test="fontbold='true'">font-weight: bold;</xsl:when>
      <xsl:otherwise>font-weight: normal;</xsl:otherwise>
    </xsl:choose>
    <xsl:if test="fontstrikethrough='true' or fontunderline='true'">text-decoration: <xsl:if test="fontstrikethrough='true'">line-through </xsl:if>
      <xsl:if test="fontunderline='true'">underline</xsl:if>;</xsl:if>
    <xsl:if test="fontitalic='true'">font-style: italic;</xsl:if>
  </xsl:template>
  <xsl:template name="getHexColorValue">
    <xsl:param name="theNumber" select="-1"/>
    <xsl:param name="fill" select="0"/>
    <xsl:variable name="useNumber">
      <xsl:choose>
        <xsl:when test="$fill=1 and fillpat &gt; 1 and ((fillred+fillblue+fillgreen) &lt; $fillPatternShade)">
          <xsl:choose>
            <xsl:when test="($fillPatternOffset + $theNumber) &gt; 254">255</xsl:when>
            <xsl:otherwise>
              <xsl:value-of select="$fillPatternOffset + $theNumber"/>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="$theNumber"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:choose>
      <xsl:when test="$useNumber=-1 and $fill=1">FF</xsl:when>
      <xsl:when test="$useNumber=-1">00</xsl:when>
      <xsl:otherwise>
        <xsl:call-template name="getHexForNumber">
          <xsl:with-param name="theNumber" select="floor($useNumber div 16)"/>
        </xsl:call-template>
        <xsl:call-template name="getHexForNumber">
          <xsl:with-param name="theNumber" select="round($useNumber mod 16)"/>
        </xsl:call-template>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>
  <xsl:template name="setPrecision">
    <xsl:param name="theNumber" select="-1"/>
    <xsl:choose>
      <xsl:when test="$numberPrecision = -1 or not(contains(string($theNumber),'.'))">
        <xsl:value-of select="$theNumber"/>
      </xsl:when>
      <xsl:when test="$numberPrecision &gt; 0">
        <!--        <xsl:value-of select="concat(string(floor($theNumber)),'.',substring(substring-after(string($theNumber),'.'),1,$numberPrecision))"/>  -->
        <xsl:value-of select="format-number($theNumber,concat('##0.',$zeros))"/>
      </xsl:when>
      <xsl:when test="$numberPrecision=0">
        <xsl:value-of select="round($theNumber)"/>
      </xsl:when>
      <xsl:otherwise>
        <!-- shouldn't happen-->
        <xsl:value-of select="$theNumber"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>
  <xsl:template name="getHexForNumber">
    <xsl:param name="theNumber" select="-1"/>
    <xsl:choose>
      <xsl:when test="$theNumber=-1">00</xsl:when>
      <xsl:when test="$theNumber &lt; 10">
        <xsl:value-of select="$theNumber"/>
      </xsl:when>
      <xsl:when test="$theNumber = 10">A</xsl:when>
      <xsl:when test="$theNumber = 11">B</xsl:when>
      <xsl:when test="$theNumber = 12">C</xsl:when>
      <xsl:when test="$theNumber = 13">D</xsl:when>
      <xsl:when test="$theNumber = 14">E</xsl:when>
      <xsl:when test="$theNumber = 15">F</xsl:when>
    </xsl:choose>
  </xsl:template>
  <xsl:template name="getTextAlignment">text-align:<xsl:choose>
      <xsl:when test="objtype=5"><!-- picture field empty for left (default), @I for centered and @J right -->
        <xsl:choose>
          <xsl:when test="string-length(picture) = 0">left;</xsl:when>
          <xsl:when test="contains(picture,'@J')">right;</xsl:when>
          <xsl:otherwise>center;</xsl:otherwise>
        </xsl:choose>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="offset=0">left;</xsl:when>
          <xsl:when test="offset=1">right;</xsl:when>
          <xsl:otherwise>center;</xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
    <!-- don't include direction at all if you want context -->
    <xsl:if test="mode &lt; 4">direction:<xsl:choose>
        <xsl:when test="mode &gt; 1">rtl;</xsl:when>
        <xsl:otherwise>ltr;</xsl:otherwise>
      </xsl:choose>
    </xsl:if>
  </xsl:template>
  <xsl:template name="ExternalStyleSheets">
    <xsl:param name="thisReportNode" select="/Reports/VFP-Report[1]"/>
    <xsl:param name="thisReportID" select="'this report'"/>
   <xsl:if test="count($thisReportNode/Run/property[@id='css_sheet']) &gt; 0">
   <xsl:comment>
   External stylesheet(s) for <xsl:value-of select="$thisReportID"/>
   </xsl:comment>
   <xsl:for-each select="$thisReportNode/Run/property[@id='css_sheet']">
      <link type="text/css" href="{./text()}" rel="stylesheet"/>
   </xsl:for-each>
   </xsl:if>   
  </xsl:template>
  <xsl:template name="DocumentStyles">
  <xsl:comment>Global document styles, if any</xsl:comment>
    <style type="text/css">
     <xsl:comment><xsl:if test="/Reports/VFP-Report[1]/VFP-RDL/VFPDataSet/VFPFRXLayoutObject[objtype=1 and (fontcharset=177 or fontcharset=178)]">
     <xsl:if test="number($noBody)!=1">html{direction:rtl;} 
     body{direction:rtl;}</xsl:if>
     div{direction:rtl;} 
     span{direction:rtl;}
     </xsl:if>
     </xsl:comment>
    </style>
  
  </xsl:template>
  <xsl:template name="Styles">
    <xsl:param name="thisReport" select="1"/>
    <xsl:param name="thisReportID"/>
    <xsl:comment>
    Styles for report # <xsl:value-of select="$thisReport"/>  in this run, 
    <xsl:value-of select="$thisReportID"/>
    </xsl:comment>
    
    <style type="text/css">
    
      <xsl:comment>
    
        <xsl:apply-templates select="./VFP-RDL/VFPDataSet/VFPFRXLayoutObject[objtype=6]" mode="linestyles">
          <xsl:with-param name="thisReport" select="$thisReport"/>
        </xsl:apply-templates>
      
      <xsl:for-each select="./VFP-RDL/VFPDataSet/VFPFRXLayoutObject[objtype=6]">
        <xsl:variable name="frxrecno" select="frxrecno"/>
        <xsl:if test="/Reports/VFP-Report[$thisReport]/Data/*/*[@id=$frxrecno]/@css">
              <xsl:apply-templates select="." mode="linestyles">
              <xsl:with-param name="thisReport" select="$thisReport"/>
                 <xsl:with-param name="firstPass" select="0"/>
              </xsl:apply-templates>
        </xsl:if>
      </xsl:for-each>
        
        <xsl:apply-templates select="./VFP-RDL/VFPDataSet/VFPFRXLayoutObject[objtype=7]" mode="shapestyles">
          <xsl:with-param name="thisReport" select="$thisReport"/>
        </xsl:apply-templates>

      <xsl:for-each select="./VFP-RDL/VFPDataSet/VFPFRXLayoutObject[objtype=7]">
         <xsl:variable name="frxrecno" select="frxrecno"/>
        <xsl:if test="/Reports/VFP-Report[$thisReport]/Data/*/*[@id=$frxrecno]/@css">
              <xsl:apply-templates select="." mode="shapestyles">
              <xsl:with-param name="thisReport" select="$thisReport"/>
                 <xsl:with-param name="firstPass" select="0"/>
              </xsl:apply-templates>
        </xsl:if>
      </xsl:for-each>

        <xsl:apply-templates select="./VFP-RDL/VFPDataSet/VFPFRXLayoutObject[contains('|5|8|',concat('|',./objtype,'|'))]" mode="textstyles">
          <xsl:with-param name="thisReport" select="$thisReport"/>
        </xsl:apply-templates>

      <xsl:for-each select="./VFP-RDL/VFPDataSet/VFPFRXLayoutObject[contains('|5|8|',concat('|',./objtype,'|'))]">
        <xsl:variable name="frxrecno" select="frxrecno"/>
        <xsl:if test="/Reports/VFP-Report[$thisReport]/Data/*/*[@id=$frxrecno]/@css">
              <xsl:apply-templates select="." mode="textstyles">
              <xsl:with-param name="thisReport" select="$thisReport"/>
                 <xsl:with-param name="firstPass" select="0"/>
              </xsl:apply-templates>
        </xsl:if>
      </xsl:for-each>
        
        <xsl:apply-templates select="./VFP-RDL/VFPDataSet/VFPFRXLayoutObject[objtype=17]" mode="imagestyles">
          <xsl:with-param name="thisReport" select="$thisReport"/>
        </xsl:apply-templates>

      <xsl:for-each select="./VFP-RDL/VFPDataSet/VFPFRXLayoutObject[objtype=17]">
        <xsl:variable name="frxrecno" select="frxrecno"/>
        <xsl:if test="/Reports/VFP-Report[$thisReport]/Data/*/*[@id=$frxrecno]/@css">
              <xsl:apply-templates select="." mode="imagestyles">
              <xsl:with-param name="thisReport" select="$thisReport"/>
                 <xsl:with-param name="firstPass" select="0"/>
              </xsl:apply-templates>
        </xsl:if>
      </xsl:for-each>

    
      </xsl:comment>
    
    </style>

   <xsl:call-template name="ExternalStyleSheets">
   <xsl:with-param name="thisReportNode" select="/Reports/VFP-Report[$thisReport]"/> 
   <xsl:with-param name="thisReportID" select="$thisReportID"/>
   </xsl:call-template>

  </xsl:template>
  <xsl:template name="replaceText">
    <xsl:choose>
      <xsl:when test="$useTextAreaForStretchingText=1">
        <xsl:value-of select="."/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:call-template name="replaceWhiteSpace">
          <xsl:with-param name="string" select="."/>
        </xsl:call-template>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>
  <xsl:template name="renderPicture">
  <xsl:param name="thisReportID"/>
  <xsl:param name="thisID"/>
    <img>
      <xsl:attribute name="alt"><xsl:choose><xsl:when test="@alt"><xsl:value-of select="@alt"/></xsl:when><xsl:otherwise><xsl:value-of select="key('Layout',concat($thisID, $thisReportID))/unpathedimg"/></xsl:otherwise></xsl:choose></xsl:attribute>
      <xsl:variable name="srcImage">
   <xsl:choose>
          <xsl:when test="@img and $externalFileLocation">
            <xsl:value-of select="translate(concat($externalFileLocation,@img),'\','/')"/>
          </xsl:when>
          <xsl:when test="@img and not(contains(./@img,':'))">
               <xsl:value-of select="translate(@img,'\','/')"/>
          </xsl:when>
          <xsl:when test="@img">
            <xsl:value-of select="concat('file://',translate(@img,'\','/'))"/>
          </xsl:when>
          <xsl:when test="$copyImageFiles = '1'">
            <xsl:value-of select="translate(concat($externalFileLocation,key('Layout',concat($thisID, $thisReportID))/unpathedimg),'\','/')"/>
          </xsl:when>
          <xsl:when test="string-length(./text()) &gt; 0 and not(contains(./text(),':')) ">
            <xsl:value-of select="translate(./text(),'\','/')"/>
          </xsl:when>
          <xsl:when test="string-length(./text()) &gt; 0">
            <xsl:value-of select="concat('file://',translate(./text(),'\','/'))"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:value-of select="concat('file://',translate(key('Layout',concat($thisID, $thisReportID))/pathedimg,'\','/'))"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:variable>
      <xsl:attribute name="src"><xsl:value-of select="$srcImage"/></xsl:attribute>
      <xsl:attribute name="style"><xsl:variable name="imgGeneral" select="key('Layout',concat($thisID, $thisReportID))"/><xsl:choose><xsl:when test="$imgGeneral/general='0' "><!-- clip top, right, bottom, left -->
 clip: rect(0in,<xsl:call-template name="setPrecision"><xsl:with-param name="theNumber" select="@w div $printDPI"/></xsl:call-template>in,<xsl:value-of select="@h div $printDPI"/>in,0in);
 </xsl:when><xsl:when test="$imgGeneral/general='1'"><!-- scale and retain --><xsl:choose><xsl:when test="@h &gt; @w">
 width:100%;
 </xsl:when><xsl:otherwise>
 height:100%;
 </xsl:otherwise></xsl:choose></xsl:when><xsl:otherwise><!-- stretch to fill frame -->
 height: <xsl:call-template name="setPrecision"><xsl:with-param name="theNumber" select="@h div $printDPI"/></xsl:call-template>in;    
width: <xsl:call-template name="setPrecision"><xsl:with-param name="theNumber" select="@w div $printDPI"/></xsl:call-template>in;    
 </xsl:otherwise></xsl:choose></xsl:attribute>
    </img>
  </xsl:template>
  <xsl:template name="addClassAttribute">
  <xsl:param name="item" select="."/>
  <xsl:param name="default" select="''"/>
  <xsl:attribute name="class"><xsl:choose>
  <xsl:when test="string-length($item/@CSS) &gt; 0">
  <xsl:value-of select="$item/@CSS"/>
  </xsl:when>
  <xsl:when test="string-length($item/@css) = 0">
  <xsl:value-of select="$default"/>
  </xsl:when>
  <xsl:otherwise>
  <xsl:value-of select="$item/@css"/>
  </xsl:otherwise>
  </xsl:choose></xsl:attribute>
  </xsl:template>
  <xsl:template name="addTitleAttribute">
    <xsl:param name="item" select="."/>
    <xsl:if test="string-length($item/@title) &gt; 0">
      <xsl:attribute name="title"><xsl:value-of select="$item/@title"/></xsl:attribute>
    </xsl:if>
  </xsl:template>
  <xsl:template name="addAnchor">
    <xsl:param name="item" select="."/>
    <xsl:if test="string-length($item/@anchor) &gt; 0">
      <a>
     <xsl:attribute name="{$anchorAttr}"><xsl:value-of select="$item/@anchor"/></xsl:attribute> 
        <xsl:text disable-output-escaping="yes">&amp;nbsp;</xsl:text>
      </a>
    </xsl:if>
  </xsl:template>
  <xsl:template name="addStyleAttribute">
    <xsl:param name="topOffset" select="0"/>
    <xsl:param name="thisZ" select="1"/>
    <xsl:param name="thisReportID"/>
    <xsl:param name="thisID"/>
    <xsl:param name="styleType" select="'Div'"/>
<!-- do NOT mess around with the white space in here, even though it 
looks ugly the way it is!! -->
<xsl:attribute name="style">z-Index:<xsl:value-of select="$thisZ"/>;left:<xsl:call-template name="setPrecision"><xsl:with-param name="theNumber" select="@l div $printDPI"/></xsl:call-template>in;
top:<xsl:choose>
  <xsl:when test="styleType='TextArea'"><xsl:call-template name="setPrecision"><xsl:with-param name="theNumber" select="((@t  + $topOffset) div $printDPI) - .1"/></xsl:call-template></xsl:when>
  <xsl:otherwise><xsl:call-template name="setPrecision"><xsl:with-param name="theNumber" select="(@t +$topOffset) div $printDPI"/></xsl:call-template></xsl:otherwise>
</xsl:choose>in;<xsl:choose>
  <xsl:when test="$styleType='VR'">width:0in;</xsl:when>
  <xsl:when test="$styleType='TextArea'">width:<xsl:call-template name="setPrecision"><xsl:with-param name="theNumber" select="@w div $printDPI"/></xsl:call-template>in;</xsl:when>
<xsl:when test="$styleType='Div'">width:<xsl:call-template name="setPrecision"><xsl:with-param name="theNumber" select="@w div $printDPI"/></xsl:call-template>in;height:<xsl:call-template name="setPrecision"><xsl:with-param name="theNumber" select="@h div $printDPI"/></xsl:call-template>in;</xsl:when></xsl:choose><xsl:if test="not($styleType='Div')">height:<xsl:call-template name="setPrecision"><xsl:with-param name="theNumber" select="@h div $printDPI"/></xsl:call-template>in;</xsl:if>
<xsl:if test="$useDynamicTextAttributes=1 and key('Layout',concat($thisID,$thisReportID))[objtype=5 or objtype=8]">
<xsl:call-template name="addDynamicTextStyleAttributes"/>
</xsl:if>
</xsl:attribute>
    </xsl:template>
    <xsl:template name="addDynamicTextStyleAttributes">
  <!-- dynamic values for font, omit these attributes if they don't appear on each object-->
  <xsl:if test="@FNAME">
    font-family:'<xsl:value-of select="@FNAME"/>';font-size:<xsl:value-of select="@FSIZE"/>pt;
    <xsl:if test="((@FSTYLE div 128) mod 2 = 1) or ( (@FSTYLE div 4) mod 2 = 1)">text-decoration:<xsl:if test="((@FSTYLE div 128) mod 2 = 1)">line-through</xsl:if><xsl:if test="( (@FSTYLE div 8) mod 2 = 1)">underline</xsl:if>;</xsl:if>
    font-weight:<xsl:choose><xsl:when test="@FSTYLE mod 2 = 1">bold</xsl:when><xsl:otherwise>normal</xsl:otherwise></xsl:choose>;
    font-style:<xsl:choose><xsl:when test="(@FSTYLE div 2) mod 2 =1">italic</xsl:when><xsl:otherwise>normal</xsl:otherwise></xsl:choose>;
   background-color:<xsl:call-template name="getAlphaColor">
   <xsl:with-param name="alpha" select="@FA"/>
   <xsl:with-param name="r" select="@FR"/>
   <xsl:with-param name="g" select="@FG"/>
   <xsl:with-param name="b" select="@FB"/>
   </xsl:call-template>;color:<xsl:call-template name="getAlphaColor"/>;
    </xsl:if>
    </xsl:template>

   <xsl:template name="getAlphaColor">
   <xsl:param name="alpha" select="@PA"/>
   <xsl:param name="r" select="@PR"/>
   <xsl:param name="g" select="@PG"/>
   <xsl:param name="b" select="@PB"/>
   <xsl:choose>
   <xsl:when test="$alpha=0">transparent</xsl:when>
   <xsl:when test="$alpha=255 or ($r+$g+$b &gt; $fieldAlphaOpacityShade)"><xsl:value-of select="concat('rgb(',$r,',',$g,',',$b,')')"/></xsl:when>
   <xsl:otherwise><xsl:value-of select="concat('rgb(',$r+$fieldAlphaOpacityOffset,',',$g+$fieldAlphaOpacityOffset,',',$b+$fieldAlphaOpacityOffset,')')"/></xsl:otherwise>
   </xsl:choose>


   </xsl:template>
  
    <xsl:template name="replaceWhiteSpace">
    <xsl:param name="string" select="."/>
    <xsl:choose>
      <xsl:when test="contains($string,'&#xA;')">
        <xsl:call-template name="replaceWhiteSpace">
          <xsl:with-param name="string" select="substring-before($string, '&#xA;')"/>
        </xsl:call-template>
        <br/>
        <xsl:call-template name="replaceWhiteSpace">
          <xsl:with-param name="string" select="substring-after($string, '&#xA;')"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$string"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>
  <xsl:template name="Script">
    <script language="JavaScript">
      <xsl:comment>
     //TBD
      </xsl:comment>
    </script>
  </xsl:template>
  <xsl:template match="*|@*" mode="debug">
   <xsl:copy-of select="."/>
  </xsl:template> 
</xsl:stylesheet>


ENDTEXT
SET TEXTMERGE OFF
SET TEXTMERGE TO

RETURN m.lcResult
ENDPROC
PROCEDURE getrawformattinginfo
LPARAMETERS m.tnLeft, m.tnTop, m.tnWidth, m.tnHeight, m.tnObjectContinuationType
LOCAL m.lcInfo, m.lcVal, m.liRecno
m.lcInfo = DODEFAULT(m.tnLeft, m.tnTop, m.tnWidth, m.tnHeight, m.tnObjectContinuationType)
THIS.setFRXDataSession()
m.liRecno = RECNO("FRX")
IF USED(THIS.MemberDataAlias) AND ;
   SEEK(m.liRecno,THIS.MemberDataAlias,"FRXRecno")          
   SELECT (THIS.MemberDataAlias)
   m.lcVal = ""
   LOCATE FOR FRXRecno = m.liRecno AND ;
          Type = FRX_BLDR_MEMBERDATATYPE  AND  ;
          Name = FRX_BLDR_NAMESPACE_ADVANCEDPROPS AND ;
          ExecWhen =  FRX_BLDR_ADVPROP_HTML_CSS_CLASSOVERRIDE
   IF FOUND()
      IF VAL(DeClass) = ADVPROP_EDITMODE_GETEXPR 
         m.lcVal = TRANSFORM(THIS.evaluateUserExpression(Execute))
      ELSE
         m.lcVal = Execute
      ENDIF         
   ENDIF      
   SELECT (THIS.MemberDataAlias)         
   IF NOT EMPTY(m.lcVal)
      m.lcInfo = m.lcInfo + " "+THIS.cssClassOverrideAttr+"='"+m.lcVal+"'"      
   ELSE
      * try again with other css class attribute
      LOCATE FOR FRXRecno = m.liRecno AND ;
             Type = FRX_BLDR_MEMBERDATATYPE  AND  ;
             Name = FRX_BLDR_NAMESPACE_ADVANCEDPROPS AND ;
             ExecWhen =  FRX_BLDR_ADVPROP_HTML_CSS_CLASSEXTEND
      IF FOUND()
         IF VAL(DeClass) = ADVPROP_EDITMODE_GETEXPR 
            m.lcVal = TRANSFORM(THIS.evaluateUserExpression(Execute))
         ELSE
            m.lcVal = Execute
         ENDIF         
      ENDIF
      IF NOT EMPTY(m.lcVal)
         m.lcInfo = m.lcInfo + " "+THIS.cssClassAttr+"='"+m.lcVal+"'"            
      ENDIF   
   ENDIF
   SELECT (THIS.MemberDataAlias)         
   m.lcVal = ""
   LOCATE FOR FRXRecno = m.liRecno AND ;
          Type = FRX_BLDR_MEMBERDATATYPE  AND  ;
          Name = FRX_BLDR_NAMESPACE_ADVANCEDPROPS AND ;
          ExecWhen =  FRX_BLDR_ADVPROP_HTML_ITEMHREF
   IF FOUND()
      IF VAL(DeClass) = ADVPROP_EDITMODE_GETEXPR 
         m.lcVal = TRANSFORM(THIS.evaluateUserExpression(Execute))
      ELSE
         m.lcVal = Execute
      ENDIF         
   ENDIF      
   IF NOT EMPTY(m.lcVal)
      m.lcInfo = m.lcInfo + " "+ ;
        THIS.linkAttr +"='"+ ;
        THIS.pathEncode(m.lcVal, .T.)+"'"      
   ENDIF
   SELECT (THIS.MemberDataAlias)         
   m.lcVal = ""
   LOCATE FOR FRXRecno = m.liRecno AND ;
          Type = FRX_BLDR_MEMBERDATATYPE  AND  ;
          Name = FRX_BLDR_NAMESPACE_ADVANCEDPROPS AND ;
          ExecWhen =  FRX_BLDR_ADVPROP_HTML_ITEMTITLE
   IF FOUND()
      IF VAL(DeClass) = ADVPROP_EDITMODE_GETEXPR 
         m.lcVal = TRANSFORM(THIS.evaluateUserExpression(Execute))
      ELSE
         m.lcVal = Execute
      ENDIF         
   ENDIF      
   IF NOT EMPTY(m.lcVal)
      m.lcInfo = m.lcInfo + " "+THIS.titleAttr +"='"+m.lcVal+"'"      
   ENDIF
   SELECT (THIS.MemberDataAlias)         
   m.lcVal = ""
   LOCATE FOR FRXRecno = m.liRecno AND ;
          Type = FRX_BLDR_MEMBERDATATYPE  AND  ;
          Name = FRX_BLDR_NAMESPACE_ADVANCEDPROPS AND ;
          ExecWhen =  FRX_BLDR_ADVPROP_HTML_ITEMANCHOR       
   IF FOUND()
      IF VAL(DeClass) = ADVPROP_EDITMODE_GETEXPR 
         m.lcVal = TRANSFORM(THIS.evaluateUserExpression(Execute))
      ELSE
         m.lcVal = Execute
      ENDIF         
   ENDIF      
   IF NOT EMPTY(m.lcVal)
      m.lcInfo = m.lcInfo + " "+ ;
                 THIS.anchorAttr +"='"+ ;
                 THIS.pathEncode(m.lcVal, .T.)+"'"
   ENDIF
   SELECT FRX
ENDIF

RETURN m.lcInfo
ENDPROC
PROCEDURE linkattr_assign
LPARAMETERS m.vNewVal
IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal) ;
   AND NOT (m.vNewVal == THIS.linkAttr)
   THIS.linkAttr = m.vNewVal
   THIS.SynchXSLTProcessorUser()
ENDIF   





ENDPROC
PROCEDURE pathencode
LPARAMETERS m.tcVal, m.tlXMLEncode
LOCAL m.lcVal, m.lcTempVal, m.laVals[1], m.liIndex, m.liSeparators
m.lcVal = ALLTRIM(CHRTRAN(m.tcVal,"\","/"))
* default XSLT would take care of the above anyway, but 
* no harm in doing it here
DO CASE
CASE LEN(m.lcVal) = 0
   * nothing
CASE AT("/",m.lcVal) > 0
   m.lcTempVal = ""
   m.liSeparators = ALINES(m.laVals,m.lcVal,0,"/")
   FOR m.liIndex = 1 TO m.liSeparators
      IF ":" $ m.laVals[m.liIndex]
         m.lcTempVal = m.lcTempVal + m.laVals[m.liIndex]
      ELSE   
         m.lcTempVal = m.lcTempVal + ;
                       THIS.urlStringEncode(m.laVals[m.liIndex])
      ENDIF                 
      IF m.liIndex < m.liSeparators
         m.lcTempVal = m.lcTempVal + "/"  
      ENDIF
   ENDFOR
   IF RIGHT(m.lcVal,1) = "/"
      m.lcTempVal = m.lcTempVal + "/"  
   ENDIF
   m.lcVal = m.lcTempVal
OTHERWISE
   m.lcVal = THIS.urlStringEncode(m.lcVal)
ENDCASE

#IF OUTPUTXML = OUTPUTXML_RAW
   IF m.tlXMLEncode
      * the result is going to an XML document
      m.lcVal = THIS.xmlRawConv(m.lcVal) 
   ENDIF   
#ENDIF   

RETURN m.lcVal

ENDPROC
PROCEDURE setdomformattinginfo
LPARAMETERS m.toNode, m.tnLeft, m.tnTop, m.tnWidth, m.tnHeight, m.tnObjectContinuationType
LOCAL  m.lcVal, m.liRecno
DODEFAULT( m.toNode, m.tnLeft, m.tnTop, m.tnWidth,m.tnHeight, m.tnObjectContinuationType)
THIS.setFRXDataSession()
m.liRecno = RECNO("FRX")
IF USED(THIS.MemberDataAlias) AND ;
   SEEK(m.liRecno,THIS.MemberDataAlias,"FRXRecno")          
   SELECT (THIS.MemberDataAlias)
   m.lcVal = ""
   LOCATE FOR FRXRecno = m.liRecno AND ;
          Type = FRX_BLDR_MEMBERDATATYPE  AND  ;
          Name = FRX_BLDR_NAMESPACE_ADVANCEDPROPS AND ;
          ExecWhen =  FRX_BLDR_ADVPROP_HTML_CSS_CLASSOVERRIDE
   IF FOUND()
      IF VAL(DeClass) = ADVPROP_EDITMODE_GETEXPR 
         m.lcVal = TRANSFORM(THIS.evaluateUserExpression(Execute))
      ELSE
         m.lcVal = Execute
      ENDIF         
   ENDIF      
   SELECT (THIS.MemberDataAlias)         
   IF NOT EMPTY(m.lcVal)
      m.toNode.SetAttribute(THIS.cssClassOverrideAttr,m.lcVal )                  
   ELSE
      * try again with other css class attribute
      LOCATE FOR FRXRecno = m.liRecno AND ;
             Type = FRX_BLDR_MEMBERDATATYPE  AND  ;
             Name = FRX_BLDR_NAMESPACE_ADVANCEDPROPS AND ;
             ExecWhen =  FRX_BLDR_ADVPROP_HTML_CSS_CLASSEXTEND
      IF FOUND()
         IF VAL(DeClass) = ADVPROP_EDITMODE_GETEXPR 
            m.lcVal = TRANSFORM(THIS.evaluateUserExpression(Execute))
         ELSE
            m.lcVal = Execute
         ENDIF         
      ENDIF
      IF NOT EMPTY(m.lcVal)
         m.toNode.SetAttribute(THIS.cssClassAttr,m.lcVal )                  
      ENDIF   
   ENDIF
   SELECT (THIS.MemberDataAlias)         
   m.lcVal = ""
   LOCATE FOR FRXRecno = m.liRecno AND ;
          Type = FRX_BLDR_MEMBERDATATYPE  AND  ;
          Name = FRX_BLDR_NAMESPACE_ADVANCEDPROPS AND ;
          ExecWhen =  FRX_BLDR_ADVPROP_HTML_ITEMHREF
   IF FOUND()
      IF VAL(DeClass) = ADVPROP_EDITMODE_GETEXPR 
         m.lcVal = TRANSFORM(THIS.evaluateUserExpression(Execute))
      ELSE
         m.lcVal = Execute
      ENDIF         
   ENDIF      
   IF NOT EMPTY(m.lcVal)
      m.toNode.SetAttribute(THIS.linkAttr,THIS.pathEncode(m.lcVal))
   ENDIF
   SELECT (THIS.MemberDataAlias)         
   m.lcVal = ""
   LOCATE FOR FRXRecno = m.liRecno AND ;
          Type = FRX_BLDR_MEMBERDATATYPE  AND  ;
          Name = FRX_BLDR_NAMESPACE_ADVANCEDPROPS AND ;
          ExecWhen =  FRX_BLDR_ADVPROP_HTML_ITEMTITLE
   IF FOUND()
      IF VAL(DeClass) = ADVPROP_EDITMODE_GETEXPR 
         m.lcVal = TRANSFORM(THIS.evaluateUserExpression(Execute))
      ELSE
         m.lcVal = Execute
      ENDIF         
   ENDIF      
   IF NOT EMPTY(m.lcVal)
      m.toNode.SetAttribute(THIS.titleAttr,m.lcVal )                  
   ENDIF
   SELECT (THIS.MemberDataAlias)         
   m.lcVal = ""
   LOCATE FOR FRXRecno = m.liRecno AND ;
          Type = FRX_BLDR_MEMBERDATATYPE  AND  ;
          Name = FRX_BLDR_NAMESPACE_ADVANCEDPROPS AND ;
          ExecWhen =  FRX_BLDR_ADVPROP_HTML_ITEMANCHOR       
   IF FOUND()
      IF VAL(DeClass) = ADVPROP_EDITMODE_GETEXPR 
         m.lcVal = TRANSFORM(THIS.evaluateUserExpression(Execute))
      ELSE
         m.lcVal = Execute
      ENDIF         
   ENDIF      
   IF NOT EMPTY(m.lcVal)
      m.toNode.SetAttribute(THIS.anchorAttr,THIS.pathEncode(m.lcVal) )                  
   ENDIF
   SELECT FRX
ENDIF


ENDPROC
PROCEDURE titleattr_assign
LPARAMETERS m.vNewVal
IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal) ;
   AND NOT (m.vNewVal == THIS.titleAttr )
   THIS.titleAttr  = m.vNewVal
   THIS.SynchXSLTProcessorUser()
ENDIF   





ENDPROC
PROCEDURE urlstringencode
LPARAMETER m.tcValue, m.tlEncodeURLControlChars, m.tlEncodeSpace
* Thanks to Rick Strahl and West Wind for help and advice!
IF VARTYPE(m.tcValue) # "C" 
   RETURN ""
ENDIF   
LOCAL m.lcResult, m.lcChar, m.ii, m.lcOKChars

m.lcResult=""
m.lcOKChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"

IF NOT m.tlEncodeURLControlChars
   * by default, we also exempt chars that might
   * indicate an anchor or a query string element
   m.lcOKChars = m.lcOKChars + ".?=&#"
ENDIF

FOR m.ii=1 TO LEN(m.tcValue)
   m.lcChar = SUBSTR(m.tcValue,m.ii,1)
   IF ATC(m.lcChar,m.lcOKChars) > 0
      m.lcResult=m.lcResult + m.lcChar
      LOOP
   ENDIF
   IF m.lcChar=" " AND NOT m.tlEncodeSpace
      m.lcResult = m.lcResult + "+"
      LOOP
   ENDIF
   m.lcResult = m.lcResult + "%" + RIGHT(TRANSFORM(ASC(m.lcChar),"@0"),2)
ENDFOR 

RETURN m.lcResult



ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*anchorattr_assign 
*cssclassattr_assign 
*cssclassoverrideattr_assign 
*getdefaultuserxsltasstring Supplies default User XSLT document o the getDefaultUserXslt method as a string.
*linkattr_assign 
*pathencode Encodes sections of a URL path re-creates the URL from the elements, and optionally re-encodes suitable for including in well-formed XML.
*titleattr_assign 
*urlstringencode Encode string for purposes of using it as part of a link in an HTML page.
anchorattr Supplies the name of the XML attribute used to supply HTML anchor instructions to the node representing an FRX layout control or band.
cssclassattr Supplies the name of the XML attribute used to supply HTML CSS class information to the node representing a layout control, supplementing FRX design instructions.
cssclassoverrideattr Supplies the name of the XML attribute used to supply HTML CSS class information to the node representing a layout control, overriding FRX design instructions.
linkattr Supplies the name of the XML attribute used to supply HTML link information to the node representing a layout control containing an image or non-TEXTAREA text.
oldpageimagetype Saves the user's preferred PageImageType settings during a run, if the Listener adjusts it to match HTML Page Link memberdata contents it finds in this report.
oldtextareasetting Saves the user's pre-report XSLTParameters useTextAreaForStretchingText value, if the Listener adjusts the value to match memberdata settings it finds in the current report.
titleattr Supplies the name of the XML attribute used to supply alternate text or tooltip information to a node representing an FRX layout control.
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED7]
Applies custom specifications, tuned to HTML production, to its parent class' XML generation process.[END RESERVED7]
[START RESERVED8]
reportlisteners.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] htmllistener

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1530WWJY4
[CLASS] _reportlistener
[CLASSLOC] listener.vcx
[BASECLASS] reportlistener
[OBJNAME] updatelistener
[START PROPERTIES]
FRXDataSession = -1
Name = "updatelistener"
_memberdata =     2919<VFPData><memberdata name="percentdone" type="property" display="percentDone" favorites="False" /> <memberdata name="createtherm" type="method" display="createTherm" favorites="False" /> <memberdata name="currentrecord" type="property" display="currentRecord" favorites="False" /><memberdata name="designateddriver" type="property" display="designatedDriver" favorites="False" /> <memberdata name="drivingaliascurrentrecno" type="property" display="drivingAliasCurrentRecno" favorites="False" /> <memberdata name="escapereference" type="property" display="escapeReference" favorites="False" /> <memberdata name="frxbandrecno" type="property" display="frxBandRecno" favorites="False" /> <memberdata name="getparentwindowref" type="method" display="getParentWindowRef" favorites="False" /> <memberdata name="getreportscopedriver" type="method" display="getReportScopeDriver" favorites="False"/><memberdata name="includeseconds" type="property" display="includeSeconds" favorites="True" /> <memberdata name="initstatustext" type="property" display="initStatusText" favorites="True" /> <memberdata name="onescapecommand" type="property" display="onEscapeCommand" favorites="False" /> <memberdata name="prepassstatustext" type="property" display="prepassStatusText" favorites="True" /> <memberdata name="reportstartrundatetime" type="property" display="reportStartRunDatetime" favorites="True" /> <memberdata name="reportstoprundatetime" type="property" display="reportStopRunDatetime" favorites="True" /> <memberdata name="resetuserfeedback" type="method" display="resetUserFeedback" favorites="False" /> <memberdata name="runstatustext" type="property" display="runStatusText" favorites="True" /> <memberdata name="secondstext" type="property" display="secondsText" favorites="True" /> <memberdata name="setescape" type="property" display="setEscape" favorites="False" /> <memberdata name="setnotifycursor" type="property" display="setNotifyCursor" favorites="False" /> <memberdata name="setthermformcaption" type="method" display="setThermformCaption" favorites="False" /> <memberdata name="thermcaption" type="property" display="thermCaption" favorites="True" /> <memberdata name="thermprecision" type="property" display="thermPrecision" favorites="True" /> <memberdata name="thermform" type="property" display="thermForm" favorites="False" /> <memberdata name="thermformcaption" type="property" display="thermFormCaption" favorites="True" /> <memberdata name="thermformheight" type="property" display="thermFormHeight" favorites="True" /> <memberdata name="thermformwidth" type="property" display="thermFormWidth" favorites="True" /> <memberdata name="thermmargin" type="property" display="thermMargin" favorites="True" /> <memberdata name="synchstatus" type="method" display="synchStatus" favorites="False" /><memberdata name="successorsys2024" type="property" display="successorSys2024" favorites="False" /></VFPData>
currentrecord = (0)
designateddriver = ("")
drivingaliascurrentrecno = (0)
escapereference = ("")
frxbandrecno = (0)
includeseconds = .T.
initstatustext = ("")
onescapecommand = ("")
percentdone = (0)
prepassstatustext = ("")
reportstartrundatetime = (DTOT({}))
reportstoprundatetime = (DTOT({}))
runstatustext = ("")
secondstext = ("secs")
successorsys2024 = ("N")
thermcaption =      284[m.cMessage+ " "+ TRANSFORM(THIS.PercentDone,"999"+IIF(THIS.ThermPrecision=0,"","."+REPL("9",THIS.ThermPrecision))) + "%" + IIF(NOT THIS.IncludeSeconds, "" , " "+TRANSFORM(IIF(THIS.IsRunning,DATETIME(), THIS.ReportStopRunDateTime)-THIS.ReportStartRunDateTime)+" " + THIS.SecondsText)]
thermform = .NULL.
thermformcaption = ("")
thermformheight = 40
thermformwidth = 356
thermmargin = 5
thermprecision = (0)
[END PROPERTIES]
[START PROTECTED]
createtherm
currentrecord
designateddriver
drivingaliascurrentrecno
escapereference
frxbandrecno
getparentwindowref
getreportscopedriver
onescapecommand
percentdone
resetuserfeedback
setescape
setnotifycursor
setthermformcaption
successorsys2024
synchstatus
thermform
[END PROTECTED]
[START METHODS]
PROCEDURE AfterBand
LPARAMETERS m.nBandObjCode, m.nFRXRecNo
DODEFAULT(m.nBandObjCode, m.nFRXRecNo)
THIS.synchStatus(m.nBandObjCode,m.nFRXRecNo)
THIS.resetDataSession()

ENDPROC
PROCEDURE AfterReport
IF SYS(2024) # "Y" 
   IF THIS.IsRunning OR TYPE("THIS.CommandClauses.RecordTotal") = "N"
      THIS.CurrentRecord = THIS.CommandClauses.RecordTotal
   ENDIF   
   THIS.UpdateStatus() 
ENDIF
THIS.IsRunning = .F.
THIS.ClearStatus() 
THIS.designatedDriver = ""
THIS.successorSys2024 = "N"
THIS.ThermForm = NULL  
THIS.ReportStopRunDateTime = DATETIME()
THIS.PopGlobalSets()
DODEFAULT()



ENDPROC
PROCEDURE BeforeBand
LPARAMETERS m.nBandObjCode, m.nFRXRecNo
DODEFAULT(m.nBandObjCode, m.nFRXRecNo)
IF THIS.successorSys2024 = "Y" AND ;
   THIS.CurrentPass = LISTENER_FULLPASS
   * user cancelled during the prepass,
   * we need to re-cancel.
   THIS.setCurrentDataSession()
   IF USED(THIS.designatedDriver)
      GO BOTTOM IN (THIS.designatedDriver)
   ENDIF   
ENDIF   

THIS.synchStatus(m.nBandObjCode,m.nFRXRecNo)
THIS.resetDataSession()
ENDPROC
PROCEDURE BeforeReport
DODEFAULT()
* THIS.ResetUserFeedback(.T.)
THIS.DrivingAliasCurrentRecno = 0
THIS.IsRunning = .T.
THIS.resetDataSession()



ENDPROC
PROCEDURE CancelReport
IF THIS.IsRunning AND ;
   (THIS.QuietMode OR ;
   (THIS.pageLimit > 0 AND THIS.PageNo > THIS.pageLimit) OR ;
    (NOT THIS.AllowModalMessages) OR ;
    THIS.DoMessage(OUTPUTCLASS_REPORT_CANCELQUERY_LOC,;
                   MB_ICONQUESTION+MB_YESNO) =  IDYES )

   IF THIS.isSuccessor AND NOT EMPTY(THIS.designatedDriver)
      * make an exception for this Listener
      * to the rule that Successors don't 
      * handle cancelling the report, because
      * this guy's job is to handle user intervention:
      THIS.successorSys2024 = "Y"
      LOCAL m.liSession
      m.liSession = SET("DATASESSION")
      THIS.setCurrentDataSession()
      IF USED(THIS.designatedDriver)
         GO BOTTOM IN (THIS.designatedDriver)
      ENDIF   
      SET DATASESSION TO (m.liSession)
   ENDIF
      
   DODEFAULT() 
   IF SYS(2024) = "Y"  OR THIS.IsSuccessor
      THIS.ThermForm = NULL
      IF (THIS.pageLimit = -1 OR THIS.PageNo <= THIS.pageLimit)
         THIS.DoMessage(OUTPUTCLASS_REPORT_INCOMPLETE_LOC, ;
                        MB_ICONEXCLAMATION)
         THIS.lastErrorMessage = OUTPUTCLASS_REPORT_INCOMPLETE_LOC                        
      ENDIF                        
   ENDIF
ELSE
   NODEFAULT   
ENDIF

ENDPROC
PROCEDURE ClearStatus
NODEFAULT
IF NOT ISNULL(THIS.ThermForm) 
   IF THIS.ThermForm.Visible
      THIS.ThermForm.Visible = .F.
   ENDIF
ENDIF

IF NOT ISNULL(THIS.Successor)
   THIS.Successor.ClearStatus()
ENDIF
ENDPROC
PROCEDURE Destroy
STORE NULL TO THIS.thermForm 

DODEFAULT()
ENDPROC
PROCEDURE DoStatus
LPARAMETERS m.cMessage
LOCAL m.loParentForm, m.lcCaption, m.lcParentFormName
NODEFAULT

IF (NOT (THIS.QuietMode or ;
   (THIS.IsRunning AND THIS.CommandClauses.NoDialog)))

   IF EMPTY(m.cMessage) OR ISNULL(m.cMessage)
      m.cMessage = ""
   ENDIF

   m.lcCaption = EVALUATE(THIS.ThermCaption)
   IF ((NOT ISNULL(THIS.ThermForm)) OR (THIS.CreateTherm()) )

      WITH THIS.ThermForm
      
         IF THIS.IsRunning
            .Closable = .F.
            .Movable = .F.
         ENDIF
      
        .ThermShape.Width = MAX( (((THIS.PercentDone/100) * .ThermBack.Width)-2) ,0)
      
        IF NOT .Visible
        
           m.loParentForm = THIS.GetParentWindowRef()
           
           DO CASE
           CASE VARTYPE(m.loParentForm) # "O" AND (NOT _SCREEN.Visible)
              m.lcParentFormName = "MACDESKTOP"
           CASE VARTYPE(m.loParentForm) # "O"
              m.lcParentFormName = "SCREEN"              
           CASE (NOT m.loParentForm.Visible) AND ;
              (m.loParentForm.DeskTop OR NOT EMPTY(m.loParentForm.MacDesktop) OR ;
              m.loParentForm.ShowWindow = 2 OR (NOT _SCREEN.Visible))
              * in many cases, 
              * they've probably made a programming error,
              * the parent should be visible according to
              * the requirements of REPORT FORM ... IN WINDOW
              * if it's a WINDOW clause they
              * have no need to show it, might not be an error
              * Either way, they should see the therm
              * to know that the report is progressing                
              m.lcParentFormName = "MACDESKTOP"
           CASE (NOT m.loParentForm.Visible) 
              * same comment as above
              m.lcParentFormName = "SCREEN"
           OTHERWISE
              m.lcParentFormName = m.loParentForm.Name
           ENDCASE
           
           SHOW WINDOW (.Name) IN WINDOW (m.lcParentFormName) 
           .AlwaysOnTop = .T.
           .AutoCenter = .T.
           .Visible = .T.
        
        ENDIF
        .ThermLabel.Visible = .F.
        .ThermLabel.Caption = m.lcCaption     
        .ThermLabel.Left = (.Width - .ThermLabel.Width) /2  && must be after visible        
        .ThermLabel.Visible = .T.     
      
      ENDWITH

   
   ENDIF
  
ENDIF   



ENDPROC
PROCEDURE Init
IF DODEFAULT() 
   THIS.InitStatusText = OUTPUTCLASS_INITSTATUS_LOC
   THIS.PrepassStatusText = OUTPUTCLASS_PREPSTATUS_LOC
   THIS.RunStatusText =  OUTPUTCLASS_RUNSTATUS_LOC
   THIS.SecondsText = OUTPUTCLASS_TIME_SECONDS_LOC
   THIS.thermCaption = OUTPUTCLASS_THERMCAPTION_LOC 
   RETURN (NOT THIS.HadError)
ELSE
   RETURN .F.
ENDIF
   
ENDPROC
PROCEDURE LoadReport
IF DODEFAULT()
   THIS.ResetUserFeedback(.T.)
   IF NOT (THIS.QuietMode OR ;
           (TYPE("THIS.CommandClauses.NoDialog") = "L" AND ;
           THIS.CommandClauses.NoDialog) )
      THIS.DoStatus(THIS.initStatusText) 
      * NB: a user can call LoadReport manually,
      * hence the need for a TYPE() check here.
   ENDIF   
   THIS.PushGlobalSets()
ELSE
   THIS.ClearStatus()
   RETURN .F.
ENDIF
ENDPROC
PROCEDURE UnloadReport
IF THIS.IsRunning
   THIS.IsRunning = .F.
   THIS.PopGlobalSets()
ENDIF   

THIS.ReportStopRunDateTime = DATETIME()
THIS.ClearStatus() 
THIS.ThermForm = NULL  

DODEFAULT()

THIS.resetDataSession()

ENDPROC
PROCEDURE UpdateStatus
NODEFAULT
* the THIS.IsRunning check here
* make sure that this code doesn't
* run if the Engine calls UpdateStatus
* after we're through

IF THIS.isRunning
   LOCAL m.liRecTotal, m.lnNewPercent, m.llShow
   m.liRecTotal = THIS.CommandClauses.RecordTotal 
   IF m.liRecTotal > 0 
      m.lnNewPercent = ROUND(THIS.CurrentRecord/m.liRecTotal,(THIS.ThermPrecision + 2) ) * 100
      IF (THIS.PercentDone # m.lnNewPercent)
         THIS.PercentDone = m.lnNewPercent
         m.llShow = .T.
         #IF OUTPUTCLASS_DEBUGGING 
             ? THIS.PercentDone, THIS.CurrentRecord, m.liRecTotal, THIS.PageTotal
             ? REPL(OUTPUTCLASS_STATUSCHAR_PCT_DONE,INT(THIS.PercentDone/100* OUTPUTCLASS_ONE_HUNDRED_PCT_MARK))+ ;
               REPL(OUTPUTCLASS_STATUSCHAR_PCT_NOT_DONE,MAX(FLOOR(OUTPUTCLASS_ONE_HUNDRED_PCT_MARK - ;
                                                            (OUTPUTCLASS_ONE_HUNDRED_PCT_MARK *THIS.PercentDone/100)),0) ) 
         #ENDIF                
      ENDIF
   ELSE
      m.llShow = .T.         
   ENDIF   
   IF m.llShow
      THIS.DoStatus( IIF(THIS.CurrentPass = LISTENER_PREPASS  AND THIS.TwoPassProcess,;
                     THIS.PrepassStatusText, ;
                     THIS.RunStatusText) )
   ENDIF                     
ENDIF   



ENDPROC
PROCEDURE createtherm
#define CTLCOLOR_MSGBOX             0
#define CTLCOLOR_EDIT               1
#define CTLCOLOR_LISTBOX            2
#define CTLCOLOR_BTN                3
#define CTLCOLOR_DLG                4
#define CTLCOLOR_SCROLLBAR          5
#define CTLCOLOR_STATIC             6
#define CTLCOLOR_MAX                7
#define COLOR_SCROLLBAR             0
#define COLOR_BACKGROUND            1
#define COLOR_ACTIVECAPTION         2
#define COLOR_INACTIVECAPTION       3
#define COLOR_MENU                  4
#define COLOR_WINDOW                5
#define COLOR_WINDOWFRAME           6
#define COLOR_MENUTEXT              7
#define COLOR_WINDOWTEXT            8
#define COLOR_CAPTIONTEXT           9
#define COLOR_ACTIVEBORDER         10
#define COLOR_INACTIVEBORDER       11
#define COLOR_APPWORKSPACE         12
#define COLOR_HIGHLIGHT            13
#define COLOR_HIGHLIGHTTEXT        14
#define COLOR_BTNFACE              15
#define COLOR_BTNSHADOW            16
#define COLOR_GRAYTEXT             17
#define COLOR_BTNTEXT              18
#define COLOR_INACTIVECAPTIONTEXT  19
#define COLOR_BTNHIGHLIGHT         20
#if("4" $ OS())
#define COLOR_3DDKSHADOW           21
#define COLOR_3DLIGHT              22
#define COLOR_INFOTEXT             23
#define COLOR_INFOBK               24
#define COLOR_DESKTOP           COLOR_BACKGROUND
#define COLOR_3DFACE            COLOR_BTNFACE
#define COLOR_3DSHADOW          COLOR_BTNSHADOW
#define COLOR_3DHIGHLIGHT       COLOR_BTNHIGHLIGHT
#define COLOR_3DHILIGHT         COLOR_BTNHIGHLIGHT
#define COLOR_BTNHILIGHT        COLOR_BTNHIGHLIGHT
#endif

IF ISNULL(THIS.ThermForm)

  DECLARE INTEGER GetSysColor IN Win32API INTEGER  

  LOCAL m.liThermTop, m.liThermLeft, m.liThermWidth, m.liThermHeight, m.liSession
  m.liSession = SET("DATASESSION")  
  THIS.resetDataSession()
  THIS.ThermForm = CREATEOBJECT("FORM")
  
  WITH THIS.ThermForm
  
     .ScaleMode = SCALEMODE_PIXELS   
     .Height = THIS.ThermFormHeight
     .HalfHeightCaption = .T.
     .Width = THIS.ThermFormWidth
     .AutoCenter = .T.
     .BorderStyle = BORDER_DOUBLE  && fixed dialog
     .ControlBox = .F.
     .Closable = (NOT THIS.IsRunning)
     .MaxButton = .F.
     .MinButton = .F.
     .Movable = (NOT THIS.IsRunning)
     .AlwaysOnTop = .T.
     .AllowOutput = .F.
     .AddObject("ThermBack","shape")
     .AddObject("ThermLabel","label")
     .AddObject("ThermShape","shape")
     m.liThermHeight = .Height - (THIS.ThermMargin* 2)
     m.liThermWidth =  .Width - (THIS.ThermMargin*2)
  ENDWITH
  
  THIS.setCurrentDataSession()
  
  THIS.SetThermFormCaption()    
  
  m.liThermTop = THIS.ThermMargin
  m.liThermLeft = THIS.ThermMargin  

  WITH THIS.ThermForm.ThermBack
     .Top = m.liThermTop     
     .Left = m.liThermLeft
     .Height = m.liThermHeight
     .Width = m.liThermWidth
     .Visible = .T.
     .BorderStyle = BORDER_SINGLE
     .BackStyle = 0     
  ENDWITH
  
  WITH THIS.ThermForm.ThermLabel
     .Top = (.Parent.Height - .Height) /2
     .Autosize = .T.
     .BackStyle = FILLSTYLE_SOLID      
     .Caption = ""
     .Visible = .T.
     .ForeColor = GetSysColor( COLOR_MENUTEXT )
  ENDWITH
  
  WITH THIS.ThermForm.ThermShape
     .Top = m.liThermTop +1    
     .Left = m.liThermLeft+1
     .Height = m.liThermHeight -2
     .Width = 0
     .Visible = .T.
     .BorderStyle = BORDER_NONE
     .BackStyle = FILLSTYLE_SOLID         
     .FillStyle = FILLSTYLE_SOLID    
     .BackColor = .Parent.BackColor
     .FillColor = GetSysColor(COLOR_HIGHLIGHT)
     .DrawMode = DRAWMODE_MERGE_PEN_NOT 
  ENDWITH
  
  SET DATASESSION TO (m.liSession)
 
ENDIF

RETURN NOT ISNULL(THIS.ThermForm)
ENDPROC
PROCEDURE getfrxstartupinfo
DODEFAULT()

LOCAL m.llFRXAvailable, m.lcAlias

m.llFRXAvailable = THIS.getReportScopeDriver() 

IF m.llFRXAvailable
   THIS.SetFRXDataSession()
   THIS.FRXBandRecno = 0

   SELECT FRX
   
   IF THIS.CommandClauses.Summary
      * don't use groups unless
      * we're forced to by Summary.
      * Group usage will not work if
      * there's a group on .T. or some
      * other nonsensical expression that
      * doesn't change.
    
      LOCATE FOR ObjType = FRX_OBJTYP_BAND AND ;
          Objcode = FRX_OBJCOD_GROUPHEADER AND ;
          Platform = FRX_PLATFORM_WINDOWS AND ;
          NOT DELETED()
      DO WHILE NOT EOF()
         * find the innermost group
         THIS.FRXBandRecno = RECNO()
         CONTINUE
      ENDDO        
      
      IF THIS.frxBandRecno = 0
         * no groups in a Summary report
         * doesn't make a lot of sense, but
         * can happen.
          LOCATE FOR ObjType = FRX_OBJTYP_BAND AND ;
             Objcode = FRX_OBJCOD_PAGEHEADER AND ;
             Platform = FRX_PLATFORM_WINDOWS AND ;
             NOT DELETED()
          IF NOT EOF()
             THIS.FRXBandRecno = RECNO()
          ENDIF     
      ENDIF
   
   ENDIF
      
   IF THIS.FRXBandRecno = 0
      * not a Summary report.
      * look for the appropriate detail
      * using the report driver
      LOCATE FOR ObjType = FRX_OBJTYP_BAND AND ;
                 Objcode = FRX_OBJCOD_DETAIL AND ;
                 Platform = FRX_PLATFORM_WINDOWS AND ;
                 TYPE(Expr) = "C" AND ;
                 NOT (EMPTY(Expr) OR DELETED())
       DO WHILE NOT EOF()
          m.lcAlias = ALLTRIM(Expr)
          THIS.SetCurrentDataSession()             
          m.lcAlias = UPPER(EVALUATE(m.lcAlias))
          THIS.SetFRXDataSession()                          
          IF m.lcAlias == UPPER(THIS.DrivingAlias)             
             THIS.FRXBandRecno = RECNO()
          ENDIF   
          CONTINUE && try not to use the first detail band
       ENDDO
   ENDIF   
   
   IF THIS.frxBandRecno = 0
      * couldn't match up a band with
      * the known driver
      LOCATE FOR ObjType = FRX_OBJTYP_BAND AND ;
           Objcode = FRX_OBJCOD_DETAIL AND ;
           Platform = FRX_PLATFORM_WINDOWS AND ;
           EMPTY(Expr) AND NOT DELETED()
      IF NOT EOF()
         THIS.FRXBandRecno = RECNO()      
      ELSE
         IF THIS.FRXBandRecno = 0 
            LOCATE FOR ObjType = FRX_OBJTYP_BAND AND ;
                 Platform = FRX_PLATFORM_WINDOWS AND ;
                 Objcode = FRX_OBJCOD_DETAIL AND ;
                 NOT DELETED()
            IF NOT EOF()
               THIS.FRXBandRecno = RECNO()
            ENDIF  
         ENDIF               
      ENDIF        
   ENDIF   

ENDIF

THIS.setCurrentDataSession()

ENDPROC
PROCEDURE getparentwindowref
LOCAL m.loForm, m.loTopForm, m.lcInWindow

* first top form in the list
* will be the current top form.

ASSERT TYPE("_SCREEN.ActiveForm") # "O"  OR ;
       INLIST(_SCREEN.ActiveForm.ShowWindow, 0,1,2)

m.loTopForm = NULL

IF TYPE("THIS.CommandClauses.InWindow") = "C"
   m.lcInWindow = UPPER(ALLTRIM(THIS.CommandClauses.InWindow))
ENDIF   

IF EMPTY(lcInWindow) AND TYPE("THIS.CommandClauses.Window") = "C"
   m.lcInWindow = UPPER(ALLTRIM(THIS.CommandClauses.Window))
ENDIF   


IF NOT EMPTY(m.lcInWindow) 

     FOR EACH m.loForm IN _SCREEN.Forms  FOXOBJECT
        IF m.loForm.ShowWindow = 2  AND ;
           UPPER(m.loForm.Name) == m.lcInWindow
           m.loTopForm = m.loForm
           EXIT
        ENDIF
     ENDFOR
     
ENDIF

DO CASE

CASE VARTYPE(m.loTopForm) = "O"
    * already found
CASE _SCREEN.FormCount = 0 OR ;
     (TYPE("_SCREEN.ActiveForm") = "O" AND ;
     _SCREEN.ActiveForm.ShowWindow = 0 )     && ShowWindow In Screen
		     
     m.loTopForm = _SCREEN

CASE (TYPE("_SCREEN.ActiveForm") = "O" AND ;
      _SCREEN.ActiveForm.ShowWindow = 2 )    && ShowWindow As Top Form

     m.loTopForm = _SCREEN.ActiveForm
		     
OTHERWISE 
		                                       
     FOR EACH m.loForm IN _SCREEN.Forms  FOXOBJECT
        IF m.loForm.ShowWindow = 2 
           m.loTopForm = m.loForm
           EXIT
        ENDIF
     ENDFOR
		     
     IF VARTYPE(m.loTopForm) # "O"
        m.loTopForm = _SCREEN
     ENDIF
		          
ENDCASE

IF VARTYPE(m.loTopForm) # "O" OR ;
   EMPTY(m.loTopForm.Name)
   m.loTopForm = NULL
ENDIF

RETURN m.loTopForm     

ENDPROC
PROCEDURE getreportscopedriver
LOCAL m.liSelect, m.lcAlias, ;
      m.liSkips,  laSkips[1]

THIS.designatedDriver = THIS.drivingAlias
* used later if we have to cancel report as
* a Successor

THIS.setFRXDataSession()

IF USED("frx")

   m.liSelect = SELECT(0)
   m.lcAlias = ""
   
   SELECT FRX
   * first look for any target alias that
   * is the same as the driver
   
   SCAN ALL FOR ObjType = FRX_OBJTYP_BAND AND ;
           Objcode = FRX_OBJCOD_DETAIL AND ;
           TYPE(Expr) = "C" AND ;
           NOT (EMPTY(Expr)  OR DELETED())

       m.lcAlias = ALLTRIM(Expr)
       THIS.setCurrentDataSession()
       m.lcAlias = UPPER(EVALUATE(m.lcAlias)) 
       THIS.setFRXDataSession()
       IF m.lcAlias == UPPER(THIS.drivingAlias)
          EXIT
       ENDIF
   ENDSCAN

   IF m.lcAlias == UPPER(THIS.drivingAlias)
      SELECT (m.liSelect)
      * if the driver is also a target alias,
      * don't touch.
      * otherwise:
   ELSE 

      LOCATE FOR ObjType = FRX_OBJTYP_BAND AND ;
              Objcode = FRX_OBJCOD_DETAIL AND ;
              Platform = FRX_PLATFORM_WINDOWS AND ;
              NOT (EMPTY(Expr) OR DELETED())
      IF FOUND()
         * use the first detail band, on the theory
         * that people are going to put pre-processing 
         * calculations before other bands, 
         * so an early band has the best chance to be
         * the right driver.
         m.lcAlias = ALLTRIM(Expr)
         THIS.setCurrentDataSession()
         THIS.drivingAlias = UPPER(EVALUATE(m.lcAlias))
         THIS.setFRXDataSession()
         SELECT (m.liSelect)

      ELSE   
   
         * adjust the driver based on any
         * one to many relationships we can find.
  
         SELECT (m.liSelect)
   
         THIS.setCurrentDataSession()

         m.lcAlias = THIS.drivingAlias

         m.liSelect = SELECT(0)

         DO WHILE NOT EMPTY(m.lcAlias)

            SELECT (m.lcAlias)
            m.liSkips = ALINES(laSkips,SET("SKIP"),",")
            IF m.liSkips = 0 OR EMPTY(laSkips[1])
               THIS.drivingAlias = m.lcAlias
               m.lcAlias = ""
            ELSE
               m.lcAlias = laSkips[1]
               * it doesn't really matter how many lines there
               * are in the array; this is not going to be perfect
               * but we can't predict which child 
               * has the most records.
            ENDIF
         ENDDO

         SELECT (m.liSelect)
   
      ENDIF   
    
   ENDIF  
ELSE
   RETURN .F.    
ENDIF
ENDPROC
PROCEDURE includeseconds_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "L"
   THIS.includeseconds = m.vNewVal
ENDIF   

ENDPROC
PROCEDURE initstatustext_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "C"
   THIS.InitStatusText = m.vNewVal
ENDIF   
ENDPROC
PROCEDURE popglobalsets
DODEFAULT()
IF (NOT INLIST(_VFP.StartMode,2,3,5))
   LOCAL m.lcRef
   m.lcRef = THIS.EscapeReference
   IF (NOT EMPTY(m.lcRef)) AND ;
       TYPE(m.lcRef) = "O"
      * push occurred earlier
      STORE NULL TO (m.lcRef)
      RELEASE &lcRef.
      THIS.escapeReference = ""
      m.lcRef = THIS.OnEscapeCommand
      ON ESCAPE &lcRef
      POP KEY
      IF THIS.SetNotifyCursor
         SET NOTIFY CURSOR ON
      ENDIF   
      IF THIS.SetEscape 
         SET ESCAPE OFF
      ENDIF   
   ENDIF   
ENDIF   
   
   
ENDPROC
PROCEDURE prepassstatustext_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "C"
   THIS.PrepassStatusText = m.vNewVal
ENDIF   

ENDPROC
PROCEDURE pushglobalsets
DODEFAULT()
IF (NOT INLIST(_VFP.StartMode,2,3,5))
   PUSH KEY CLEAR
   LOCAL m.lcRef
   SET MESSAGE TO ""
   THIS.SetNotifyCursor = (SET("Notify",2) = "ON")
   IF THIS.SetNotifyCursor
      SET NOTIFY CURSOR OFF
   ENDIF   
   THIS.OnEscapeCommand = ON("ESCAPE")   
   m.lcRef = SYS(2015)   
   PUBLIC &lcRef.   
   STORE THIS TO (m.lcRef)
   ON ESCAPE &lcRef..CancelReport()      
   THIS.EscapeReference = m.lcRef   
   THIS.SetEscape = (SET("ESCAPE")="OFF") 
   IF THIS.SetEscape
      SET ESCAPE ON
   ENDIF   
ENDIF   
   
   
ENDPROC
PROCEDURE resetuserfeedback
LPARAMETERS m.tlResetTimes
THIS.CurrentRecord = 0
THIS.PercentDone = 0
IF m.tlResetTimes
   THIS.ReportStartRunDateTime= DATETIME()
   THIS.ReportStopRunDateTime= DTOT({})
ENDIF   

ENDPROC
PROCEDURE runstatustext_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "C"
   THIS.RunStatusText = m.vNewVal
ENDIF   


ENDPROC
PROCEDURE secondstext_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "C"
   THIS.SecondsText = m.vNewVal
ENDIF   

ENDPROC
PROCEDURE setfrxrunstartupconditions
DODEFAULT()
IF TYPE("THIS.CommandClauses.Summary") # "L"
   ADDPROPERTY(THIS.CommandClauses,"Summary",.F.)
ENDIF   
IF TYPE("THIS.CommandClauses.RecordTotal") # "N"
   ADDPROPERTY(THIS.CommandClauses,"RecordTotal",0)
ENDIF   

ENDPROC
PROCEDURE setthermformcaption
IF NOT ISNULL(THIS.ThermForm)
   IF EMPTY(THIS.ThermFormCaption)
      
      IF TYPE("THIS.CommandClauses.File") = "C"
         LOCAL m.cName
         IF EMPTY(THIS.PrintJobName)
            m.cName = PROPER(JUSTFNAME(THIS.CommandClauses.File))
         ELSE
            m.cName = THIS.PrintJobName
         ENDIF   
         THIS.ThermForm.Caption = ;
            m.cName + ": " + OUTPUTCLASS_CANCEL_INSTRUCTIONS_LOC
      ELSE
         THIS.ThermForm.Caption = ""
      ENDIF
   ELSE   
      THIS.ThermForm.Caption = THIS.ThermFormCaption
   ENDIF
ENDIF   





ENDPROC
PROCEDURE synchstatus
LPARAMETERS m.nBandObjCode, m.nFRXRecNo
IF THIS.isRunning AND (NOT THIS.hadError) AND ;
   THIS.frxBandRecno = m.nFRXRecNo
   THIS.setCurrentDataSession() 
   IF THIS.drivingAliasCurrentRecno  # RECNO(THIS.drivingAlias)
      THIS.currentRecord = THIS.CurrentRecord + 1
      THIS.drivingAliasCurrentRecno = RECNO(THIS.drivingAlias)
   ENDIF   
   IF THIS.currentRecord >= THIS.CommandClauses.RecordTotal
      IF THIS.CurrentPass = 0 AND THIS.TwoPassProcess
         THIS.resetUserFeedback() 
      ELSE
         THIS.currentRecord = THIS.CommandClauses.RecordTotal
      ENDIF
   ENDIF
   THIS.UpdateStatus()
   THIS.resetDataSession()
ENDIF  


ENDPROC
PROCEDURE thermcaption_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "C"
   LOCAL m.lcType, m.cMessage
   m.cMessage = ""
   TRY 
    m.lcType = VARTYPE(EVALUATE(m.vNewVal))
      IF m.lcType = "C"
        THIS.ThermCaption = m.vNewVal
    ENDIF
   CATCH 
   ENDTRY     
ENDIF   

ENDPROC
PROCEDURE thermformcaption_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "C"
   THIS.ThermFormCaption = m.vNewVal
   THIS.SetThermFormCaption()
ENDIF   

ENDPROC
PROCEDURE thermformheight_assign
LPARAMETERS m.vNewVal
IF (NOT THIS.IsRunning) AND VARTYPE(m.vNewVal) = "N" AND ;
   BETWEEN(m.vNewVal,30,SYSMETRIC(SYSMETRIC_SCREENHEIGHT )-30)  AND ;
   INT(m.vNewVal) # THIS.ThermFormHeight
   THIS.thermformheight = INT(m.vNewVal)
   IF THIS.ThermMargin > THIS.ThermFormHeight/4
      THIS.ThermMargin = THIS.ThermFormHeight/4
   ENDIF   
   THIS.thermForm = NULL
ENDIF   

ENDPROC
PROCEDURE thermformwidth_assign
LPARAMETERS m.vNewVal
IF (NOT THIS.IsRunning) AND VARTYPE(m.vNewVal) = "N" AND ;
   BETWEEN(m.vNewVal,100,SYSMETRIC( SYSMETRIC_SCREENWIDTH  )-100) AND ;
   INT(m.vNewVal) # THIS.ThermFormWidth 
   THIS.thermformwidth = INT(m.vNewVal)
   IF THIS.ThermMargin > THIS.ThermFormWidth/4
      THIS.ThermMargin = THIS.ThermFormWidth/4
   ENDIF   
   THIS.ThermForm = NULL
ENDIF   

ENDPROC
PROCEDURE thermmargin_assign
LPARAMETERS m.vNewVal
IF (NOT THIS.IsRunning) AND VARTYPE(m.vNewVal) = "N" AND ;
   BETWEEN(m.vNewVal,1,MIN(THIS.ThermFormHeight/4,THIS.ThermFormWidth/4)) AND ;
   INT(m.vNewVal) # THIS.ThermMargin
   THIS.thermmargin = INT(m.vNewVal)
   THIS.thermForm = NULL
ENDIF   

ENDPROC
PROCEDURE thermprecision_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "N" 
   THIS.thermPrecision  = ABS(INT(m.vNewVal))
ENDIF 
ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*createtherm Creates and configures the "update" feedback window.
*getparentwindowref Provides a window reference for the top form in which the user feedback window should appear.
*getreportscopedriver Adjusts the alias driving CommandClauses.RecordTotal at the beginning of a report  when the DrivingAlias is engaged in one-to-many relationships.
*includeseconds_assign 
*initstatustext_assign 
*prepassstatustext_assign 
*resetuserfeedback Sets user feedback to an initialized state.
*runstatustext_assign 
*secondstext_assign 
*setthermformcaption Sets the user feedback window title using the ThermFormCaption property.
*synchstatus Compares driving recno with currrently-saved information to evaluate need to update user feedback.
*thermcaption_assign 
*thermformcaption_assign 
*thermformheight_assign 
*thermformwidth_assign 
*thermmargin_assign 
*thermprecision_assign 
currentrecord Holds the current record relative to the recordtotal in scope for the current report run.
designateddriver Original selected alias for the report.
drivingaliascurrentrecno Holds the RECNO() value in the cursor driving the report run, to assist in determining when to trigger a change in the user feedback.
escapereference Holds the name of a public variable used to facilitate interrupting a report run.
frxbandrecno Holds the RECNO() of the band-describing record in the FRX table this class has determined is optimal for triggering a change in user feedback during a report run.
includeseconds Indicates whether the default user feedback message should include timing data.
initstatustext Provides the user message shown when user feedback first appears.
onescapecommand Saves the user's previous ON ESCAPE command, if any, for restoration after the report run.
percentdone Calculation of the ratio between the number of records, or pages, already generated to the number of records, or pages, in the total report.
prepassstatustext User feedback message for use when the report is in a pre-generation pass to calculate _RECORDTOTAL.
reportstartrundatetime A datetime value indicating when the last report generation run began.
reportstoprundatetime A datetime value for use at the conclusion of a report run, empty during a report, storing when the last report generation run ended.
runstatustext Provides a user message shown during the course of a report run.
secondstext Provides the text message included to describe the time value in the default user feedback message during a report, when IncludeSeconds is .T.
setescape Saves the state of SET ESCAPE previous to the report run, for later restoration.
setnotifycursor Saves the state of SET NOTIFY CURSOR previous to the report run, for later restoration.
successorsys2024 Allows UpdateListener to "remember" if it has cancelled a report between the two report passes if it is in a two-pass process report, if it is a Successor.
thermcaption Holds an evaluated expression for use in the user feedback message shown during a report run. If this expression includes "cMessage", the contents of the argument provided to DoStatus will be included in the result of the evaluation.
thermform Holds an object reference to the user feedback form.
thermformcaption Holds the value used to set the title of the user feedback form.
thermformheight Holds the height of the user feedback form, in pixels.  
thermformwidth Holds the width of the user feedback form, in pixels.  
thermmargin Holds the value (in pixels) used to determine the difference between the size of the user feedback window and the thermometer bar it displays.
thermprecision The number of places (precision) to use for evaluating and (by default) showing the percentage done.
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED7]
Provides user feedback while report output is generated.[END RESERVED7]
[START RESERVED8]
reportlisteners.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] updatelistener

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _13T0OHG0F
[CLASS] fxlistener
[CLASSLOC] listener.vcx
[BASECLASS] reportlistener
[OBJNAME] utilityreportlistener
[START PROPERTIES]

 <memberdata name="closetargetfile" type="method" display="closeTargetFile" favorites="False" />
 <memberdata name="configurationobjtype" type="property" display="configurationObjtype" favorites="True" />
 <memberdata name="configurationtable" type="property" display="configurationTable" favorites="False" />
 <memberdata name="createconfigtable" type="method" display="createConfigTable" favorites="True" />
 <memberdata name="getconfigtable" type="method" display="getConfigTable" favorites="True" />
 <memberdata name="opentargetfile" type="method" display="openTargetFile" favorites="False" />
 <memberdata name="readconfiguration" type="property" display="readConfiguration" favorites="True" />
 <memberdata name="setconfiguration" type="method" display="setConfiguration" favorites="True" />
 <memberdata name="targetfileext" type="property" display="targetFileExt" favorites="True" />
 <memberdata name="targetfilename" type="property" display="targetFileName" favorites="True" />
 <memberdata name="targethandle" type="property" display="targetHandle" favorites="True" />
 <memberdata name="verifyconfigtable" type="property" display="verifyConfigTable" favorites="True" />
 <memberdata name="verifytargetfile" type="method" display="verifyTargetFile" favorites="True" />
</VFPData>
<memberdata name="currentpageimagefilename" display="currentPageImageFilename" type="property"/>
<memberdata name="externalfilelocation" type="property" display="externalFileLocation" favorites="True" />
<memberdata name="generatepageimagefilename" type="method" 
<memberdata name="getpageimageextension" type="method" display="getPageImageExtension"/>
<memberdata name="makeexternalfilelocationreachable" display="makeExternalFileLocationReachable" type="method"/>
<memberdata name="outputpageimage" type="method" display="outputPageImage"/>
<memberdata name="pageimageextension" type="property" display="pageImageExtension"/>
<memberdata name="pageimagetype" type="property" display="pageImageType" favorites="True"/>
<memberdata name="supportspageimages" type="method" display="supportsPageImages"/>
FRXDataSession = -1
Name = "utilityreportlistener"
_memberdata =     2143<VFPData>
configurationobjtype = 1000
configurationtable = ("")
currentpageimagefilename = ("")
display="generatePageImageFileName"/>
externalfilelocation = ("")
pageimageextension = ("")
pageimagetype = 0
readconfiguration = (0)
targetfileext = ("TXT")
targetfilename = (FORCEPATH(SYS(2015),SYS(2023)))
targethandle = -1
[END PROPERTIES]
[START PROTECTED]
closetargetfile
configurationtable
generatepageimagefilename
getpageimageextension
makeexternalfilelocationreachable
opentargetfile
outputpageimage
pageimageextension
supportspageimages
[END PROTECTED]
[START METHODS]
PROCEDURE AfterReport
DODEFAULT()
IF (NOT THIS.CommandClauses.NOPAGEEJECT) AND ;
   THIS.supportsPageImages("AFTERREPORT")
   LOCAL m.lcFileLocation, m.liPage,  m.lcFile
   m.lcFileLocation = THIS.ExternalFileLocation
   THIS.makeExternalFileLocationReachable()
   FOR m.liPage = 1 TO THIS.OutputPageCount 
      IF NOT THIS.outputPageImage(m.liPage)
         EXIT
      ENDIF
   NEXT   
   THIS.externalFileLocation = m.lcFileLocation
ENDIF

ENDPROC
PROCEDURE BeforeBand
LPARAMETERS m.nBandObjCode, m.nFRXRecNo

IF (m.nBandObjCode = FRX_OBJCOD_PAGEHEADER OR ;
    m.nBandObjCode = FRX_OBJCOD_TITLE) AND ;
   THIS.supportsPageImages() 
   * Note: this assignment does not occur in 
   * OutputPageImage, because we don't know
   * what listener mode (PRN vs cached) we're in.
   * The point of this property is to make the value
   * available either way, as it will eventually be
   * used by OutputPageImage no matter when that occurs,
   * during the run of the report.
   LOCAL lcFile, liPageNo
   m.lcFile = ""
   DO CASE
   CASE THIS.pageImageType = LISTENER_DEVICE_TYPE_MTIF 
      m.liPageNo = 1
   CASE THIS.CommandClauses.RangeFrom < 2 
      IF THIS.isSuccessor
         m.liPageNo = THIS.sharedPageNo
      ELSE
         m.liPageNo = THIS.PageNo      
      ENDIF   
   OTHERWISE      
      IF THIS.isSuccessor
         m.liPageNo = (THIS.sharedPageNo - THIS.CommandClauses.RangeFrom) + 1       
      ELSE
         m.liPageNo = (THIS.PageNo - THIS.CommandClauses.RangeFrom) + 1 
      ENDIF   
   ENDCASE
   m.lcFile = THIS.generatePageImageFileName(m.liPageNo)
   THIS.currentPageImageFilename = m.lcFile
   IF NOT ISNULL(THIS.successor)
      THIS.successor.currentPageImageFilename = m.lcFile
   ENDIF   
ENDIF

IF THIS.sharedPageNo  = 1 AND ;
   m.nBandObjCode = FRX_OBJCOD_PAGEHEADER AND ;   
   (NOT EMPTY(THIS.pageImageType)) AND ;
   (EMPTY(THIS.currentPageImageFilename)) AND ;
   ((NOT THIS.TwoPassProcess) OR THIS.CurrentPass = LISTENER_FULLPASS)
   THIS.DoMessage(OUTPUTFILE_NOIMAGEFILES_LOC,MB_ICONEXCLAMATION)     
ENDIF   

DODEFAULT(m.nBandObjCode, m.nFRXRecNo)




ENDPROC
PROCEDURE BeforeReport
THIS.currentPageImageFilename =""

IF (NOT EMPTY(THIS.pageImageType)) AND ;
   (NOT THIS.supportsPageImages()) 
   IF (NOT THIS.isSuccessor)
     THIS.ListenerType = LISTENER_TYPE_PAGED
   ENDIF 
ENDIF

IF THIS.supportsPageImages()
   THIS.makeExternalFileLocationReachable()
ENDIF   

IF NOT ISNULL(THIS.successor)
   THIS.successor.AddProperty("currentPageImageFilename","")
ENDIF

DODEFAULT()

 IF INLIST(THIS.ReadConfiguration,;
                  OUTPUTCLASS_READCONFIG_REPORT,;
                  OUTPUTCLASS_READCONFIG_BOTH)
     THIS.SetConfiguration()
ENDIF   

THIS.resetDataSession()
ENDPROC
PROCEDURE Destroy
THIS.CloseTargetFile()
DODEFAULT()
ENDPROC
PROCEDURE Init
IF DODEFAULT()
   * NB: this one doesn't necessarily need its
   * own AppName LOC'd value, because
   * it is basically an abstract layer 
   * and should not be instantiated directly.
   * Doesn't hurt, though.
   THIS.appName = OUTPUTFILE_APPNAME_LOC

   IF INLIST(THIS.ReadConfiguration,;
                  OUTPUTCLASS_READCONFIG_INIT,;
                  OUTPUTCLASS_READCONFIG_BOTH)
     THIS.SetConfiguration(.T.)
   ENDIF   

ELSE

   RETURN .F.   

ENDIF

RETURN NOT THIS.HadError
ENDPROC
PROCEDURE OutputPage
LPARAMETERS nPageNo, eDevice, nDeviceType, nLeft, nTop, nWidth, nHeight, nClipLeft, nClipTop, nClipWidth, nClipHeight

IF THIS.supportsPageImages("OUTPUTPAGE")
   IF m.nDeviceType < 100
      * ascertain that this is the native call; have to make
      * sure it's not recursive... 
      THIS.OutputPageImage(m.nPageNo)
   ENDIF
ELSE
   IF m.nDeviceType > 99
      DODEFAULT(nPageNo, eDevice, nDeviceType)   
   ENDIF
ENDIF

ENDPROC
PROCEDURE closetargetfile
   LOCAL laDummy[1]
     
   IF THIS.TargetHandle > -1    

      =FCLOSE(THIS.TargetHandle)
      THIS.TargetHandle = -1
     
      IF ADIR(laDummy,THIS.TargetFileName) = 1 AND ;
         laDummy[1,2] > 0
         * NB: have to check this as well as
         * error because some COM errors may not
         * end up in THIS.HadError.
          * if continuation, update status rather than
          * modal message
         IF THIS.HadError
            THIS.DoMessage(OUTPUTCLASS_CREATEERRORS_LOC,MB_ICONEXCLAMATION  )
            THIS.lastErrorMessage = OUTPUTCLASS_CREATEERRORS_LOC
        ELSE
            IF THIS.DoMessage( OUTPUTCLASS_SUCCESS_LOC + ;
                            IIF(SYS(2024)="Y",CHR(13)+OUTPUTCLASS_REPORT_INCOMPLETE_LOC,""),;
                            MB_ICONINFORMATION + MB_YESNO ) = IDYES
               _CLIPTEXT = THIS.TargetFileName
            ENDIF
         ENDIF
      ELSE
         THIS.DoMessage(OUTPUTCLASS_NOCREATE_LOC,MB_ICONSTOP )
         THIS.lastErrorMessage = OUTPUTCLASS_NOCREATE_LOC
       
      ENDIF                 
     
   ENDIF

ENDPROC
PROCEDURE configurationobjtype_access
* readonly property
   
RETURN OUTPUTCLASS_OBJTYPE_CONFIG

ENDPROC
PROCEDURE createconfigtable
LPARAMETERS m.tcDBF, m.tlOverWrite
LOCAL m.liSelect, m.lcFile

m.lcFile = FORCEEXT(m.tcDBF,"DBF")

IF (NOT EMPTY(SYS(2000,m.lcFile))) AND m.tlOverWrite
   ERASE (m.lcFile) RECYCLE
   ERASE (FORCEEXT(m.lcFile,"FPT")) RECYCLE
   ERASE (FORCEEXT(m.lcFile,"CDX")) RECYCLE   
ENDIF   

m.liSelect = SELECT(0)

SELECT 0

CREATE TABLE (m.lcFile) FREE ;
   (objtype i, ;
    objcode i, ;
    objname v(60), ;
    objvalue v(60), ;
    objinfo m)

IF NOT EMPTY(ALIAS()) && can happen if SAFETY ON and they decide not to overwrite    

   INDEX ON Objtype TAG ObjType
   INDEX ON ObjCode TAG ObjCode
   INDEX ON ObjName TAG ObjName
   INDEX ON ObjValue TAG ObjValue
   INDEX ON DELETED() TAG OnDeleted    
   
   INSERT INTO (ALIAS()) VALUES ;
      (OUTPUTCLASS_OBJTYPE_CONFIG,0,'DoMessage','"Welcome to the demo run!",64','Sample initialization/config method call')
   DELETE NEXT 1

   INSERT INTO (ALIAS()) VALUES ;
     (OUTPUTCLASS_OBJTYPE_CONFIG,0,'TargetFileName','"xxx"','Sample initialization/config property')
   DELETE NEXT 1
   USE
   
ENDIF   

SELECT (m.liSelect)   
ENDPROC
PROCEDURE currentpageimagefilename_assign
LPARAMETERS m.tvNewVal
IF VARTYPE(m.tvNewVal) # "C"
   THIS.currentPageImageFilename = ""
ELSE
   THIS.currentPageImageFilename = m.tvNewVal
ENDIF   
   

ENDPROC
PROCEDURE externalfilelocation_assign
LPARAMETERS m.vNewVal
IF THIS.isRunning AND NOT EMPTY(THIS.externalFileLocation)
   RETURN
ENDIF   
IF VARTYPE(m.vNewVal) = "C"
   THIS.externalFileLocation = ALLTRIM(m.vNewVal)
   IF NOT EMPTY(THIS.externalFileLocation)
         THIS.externalFileLocation = ADDBS(THIS.externalFileLocation)
   ENDIF 
ENDIF   

ENDPROC
PROCEDURE generatepageimagefilename
LPARAMETERS m.tiPage, m.tlFullPath
LOCAL lcFileName

m.lcFileName = FORCEEXT(JUSTSTEM(THIS.targetFileName) + ;
                        "_" + ;
                        PADL(TRANSFORM(m.tiPage),;
                             OUTPUTFILE_MAX_FILEPLACES ,"0"), ;
                        THIS.pageImageExtension)
IF m.tlFullPath
   RETURN  FULLPATH(FORCEPATH( m.lcFileName,THIS.ExternalFileLocation),;
                    ADDBS(JUSTPATH(THIS.TargetFileName)))
ELSE
   RETURN FORCEPATH(m.lcFileName,THIS.externalFileLocation)
ENDIF          
       
        
ENDPROC
PROCEDURE getconfigtable
LPARAMETERS m.tlForceExternal

LOCAL m.lcDBF, m.lcPath

m.lcDBF = ""

IF m.tlForceExternal OR (NOT EMPTY(SYS(2000,FULLPATH(FORCEEXT(OUTPUTCLASS_EXTERNALDBF,"DBF")))))
   m.lcDBF = FULLPATH(FORCEEXT(OUTPUTCLASS_EXTERNALDBF,"DBF"))
ELSE
   m.lcDBF = FORCEEXT(OUTPUTCLASS_INTERNALDBF,"DBF")
ENDIF
   
IF NOT (FILE(m.lcDBF) OR THIS.IsRunning)

      m.lcPath = THIS.GetPathForExternals()
      * this may be the internal *or* external dbf name;
      * we could be testing and not yet built into an app,
      * so accept either, before the next test:
      m.lcDBF = FORCEPATH(m.lcDBF,m.lcPath) 
      
      IF NOT FILE(m.lcDBF)
         * now force to the external name:
         m.lcDBF = FORCEEXT(FORCEPATH(OUTPUTCLASS_EXTERNALDBF,m.lcPath),"DBF")
         * now check again
         IF NOT FILE(m.lcDBF)
            THIS.CreateConfigTable(m.lcDBF)
            IF FILE(m.lcDBF)
               THIS.DoMessage(OUTPUTCLASS_CONFIGTABLECREATED_LOC)
            ENDIF
         ENDIF
      ENDIF

ENDIF 

IF NOT FILE(m.lcDBF)
   m.lcDBF = ""
ENDIF  

THIS.ConfigurationTable = m.lcDBF

RETURN m.lcDBF
ENDPROC
PROCEDURE getpageimageextension
LOCAL lcExt
m.lcExt = ""
DO CASE
CASE INLIST(THIS.pageImageType,;
            LISTENER_DEVICE_TYPE_TIF,;
            LISTENER_DEVICE_TYPE_MTIF)
   m.lcExt = "TIF"            
CASE THIS.pageImageType = LISTENER_DEVICE_TYPE_JPG
   m.lcExt = "JPG"
CASE THIS.pageImageType = LISTENER_DEVICE_TYPE_GIF
   m.lcExt = "GIF"
CASE THIS.pageImageType = LISTENER_DEVICE_TYPE_PNG
   m.lcExt = "PNG"
CASE THIS.pageImageType = LISTENER_DEVICE_TYPE_BMP
   m.lcExt = "BMP"
ENDCASE

RETURN m.lcExt
ENDPROC
PROCEDURE makeexternalfilelocationreachable
IF EMPTY(THIS.externalFileLocation) 
   THIS.externalFileLocation = "."
ENDIF
IF NOT DIRECTORY(FULLPATH(THIS.ExternalFileLocation,ADDBS(JUSTPATH(THIS.TargetFileName))))     
   TRY
     MD (FULLPATH(THIS.ExternalFileLocation,ADDBS(JUSTPATH(THIS.TargetFileName))))     
   CATCH
     LOCAL m.llRunning 
     m.llRunning = THIS.isRunning
     THIS.isRunning = .F.
     THIS.externalFileLocation = "."
     THIS.isRunning = m.llRunning
   ENDTRY
ENDIF

ENDPROC
PROCEDURE opentargetfile
   THIS.VerifyTargetFile() 

   THIS.TargetHandle = FCREATE(THIS.TargetFileName)
 
   IF THIS.TargetHandle < 0 OR THIS.HadError
      THIS.HadError = .T.
      THIS.DoMessage(OUTPUTCLASS_NOFILECREATE_LOC,MB_ICONSTOP )
      THIS.lastErrorMessage = OUTPUTCLASS_NOFILECREATE_LOC
   ENDIF

RETURN (NOT THIS.HadError)
     
ENDPROC
PROCEDURE outputpageimage
LPARAMETERS m.tiPage

LOCAL m.lcFile, m.llError

TRY
   IF THIS.pageImageType = LISTENER_DEVICE_TYPE_MTIF 
      m.lcFile = THIS.generatePageImageFilename(1, .T.) 
      IF m.tiPage = 1 
         IF NOT EMPTY(SYS(2000,m.lcFile))
            ERASE (m.lcFile) NORECYCLE
         ENDIF
         THIS.OutputPage(m.tiPage,m.lcFile,LISTENER_DEVICE_TYPE_TIF )
      ELSE
         THIS.OutputPage(m.tiPage,m.lcFile,LISTENER_DEVICE_TYPE_MTIF )
      ENDIF   
   ELSE
      m.lcFile = THIS.generatePageImageFilename(m.tiPage, .T.)   
      IF NOT EMPTY(SYS(2000,m.lcFile))
         ERASE (m.lcFile) NORECYCLE
      ENDIF
      THIS.OutputPage(m.tiPage,m.lcFile,THIS.pageImageType)
   ENDIF   
CATCH WHEN .T.
   m.llError = .T.
ENDTRY

RETURN (NOT m.llError)

ENDPROC
PROCEDURE pageimagetype_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "N" AND ;
   (m.vNewVal = 0 OR ;
   INLIST(m.vNewVal,;
          LISTENER_DEVICE_TYPE_EMF,;
          LISTENER_DEVICE_TYPE_TIF,;
          LISTENER_DEVICE_TYPE_JPG,;
          LISTENER_DEVICE_TYPE_GIF,;
          LISTENER_DEVICE_TYPE_PNG,;
          LISTENER_DEVICE_TYPE_BMP,;
          LISTENER_DEVICE_TYPE_MTIF))
   THIS.pageImageType = m.vNewVal
   THIS.pageImageExtension = THIS.getPageImageExtension() 
ENDIF



ENDPROC
PROCEDURE readconfiguration_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "N" AND NOT THIS.IsRunning
   THIS.ReadConfiguration = m.vNewVal
ENDIF   

ENDPROC
PROCEDURE setconfiguration
LPARAMETERS m.tlCalledFromInit

IF NOT THIS.IsRunning 
   * do some config work, don't change sessions --
   * at this point we don't have our private session
   * if we're being called in the Init

   LOCAL m.liSelect, m.lcPEM, m.llOpened, m.lcOrder, m.liType, m.llQuiet
  
   m.liSelect = SELECT(0)

   IF NOT USED("OutputConfig")
      * if called from Init, 
      * do this in quietmode
      * because the caller has no
      * opportunity to 
      * turn off the message
      m.llQuiet = (m.tlCalledFromInit AND NOT THIS.QuietMode)
      IF m.llQuiet
         THIS.QuietMode = .T.
      ENDIF
      THIS.GetConfigTable()
      IF m.llQuiet
         THIS.QuietMode = .F.
      ENDIF
      USE (THIS.ConfigurationTable) ALIAS "OutputConfig" IN 0 AGAIN NOUPDATE SHARED
      m.llOpened = .T.
   ELSE 
      m.lcOrder = ORDER("OutputConfig")
      SET ORDER TO ObjCode
   ENDIF

   IF (NOT THIS.HadError) AND THIS.VerifyConfigTable("OutputConfig")

      SELECT OutputConfig
      m.liType = THIS.ConfigurationObjtype

      SCAN FOR ObjType = m.liType AND ;
            NOT(DELETED() OR ;
                ObjName == "" OR ;
                ObjValue =="" )
          
         IF PEMSTATUS(THIS,ObjName,5) 
            m.lcPEM = UPPER(PEMSTATUS(THIS,ObjName,3))
            DO CASE
            CASE lcPEM == "PROPERTY"
               STORE EVAL(ObjValue) TO ("THIS."+ObjName)
            CASE INLIST("|"+lcPEM+"|","|METHOD|","|EVENT|")
               EVAL("THIS."+ObjName+"("+ObjValue+")")
            OTHERWISE
            ENDCASE
          ENDIF

      ENDSCAN

      IF m.llOpened
         USE IN OutputConfig
      ELSE
         SET ORDER TO (m.lcOrder) IN OutputConfig   
      ENDIF   

   ENDIF   

   SELECT (m.liSelect)

ENDIF   

ENDPROC
PROCEDURE setfrxdatasessionenvironment
DODEFAULT()
SET DELETED ON
SET EXCLUSIVE OFF
SET TALK OFF

ENDPROC
PROCEDURE supportspageimages
LPARAMETERS tcMethodToken

DO CASE
CASE THIS.isSuccessor OR EMPTY(THIS.pageImageType)
   RETURN .F.    
CASE EMPTY(m.tcMethodToken)
   RETURN THIS.ListenerType # LISTENER_TYPE_DEF
        * this indicates the set we are supporting in total
CASE m.tcMethodToken = "OUTPUTPAGE"
   RETURN INLIST(THIS.ListenerType,LISTENER_TYPE_PRN,LISTENER_TYPE_PAGED)
CASE INLIST(m.tcMethodToken,"AFTERREPORT","UNLOADREPORT")
   RETURN INLIST(THIS.ListenerType,LISTENER_TYPE_PRV,LISTENER_TYPE_ALLPGS)
ENDCASE  
ENDPROC
PROCEDURE targetfileext_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "C" AND NOT THIS.IsRunning
   THIS.targetfileext = m.vNewVal
ENDIF   

ENDPROC
PROCEDURE targetfilename_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "C" AND NOT THIS.IsRunning
   THIS.targetfilename = m.vNewVal
ENDIF   

ENDPROC
PROCEDURE targethandle_assign
LPARAMETERS m.vNewVal
* Readonly during report run
IF VARTYPE(m.vNewVal) = "N" AND NOT THIS.IsRunning
   THIS.targethandle = m.vNewVal
ENDIF   

ENDPROC
PROCEDURE verifyconfigtable
LPARAMETERS m.tcAlias, m.tcFailureMsgTable, m.tcFailureMsgIndexes

IF EMPTY(m.tcAlias) OR VARTYPE(m.tcAlias) # "C"
   RETURN .F.
ENDIF
LOCAL m.lcTable, m.lcMessage, m.lcAlias, m.liSelect, ;
      m.llReturn, m.liTagCount, laRequired[1], laKeys[1], ;
      m.liFound, m.llExactOff, m.llSafetyOn

m.llReturn = ;
       TYPE(m.tcAlias+".OBJTYPE") = "N" AND ;
       TYPE(m.tcAlias+".OBJCODE") = "N" AND ;  
       TYPE(m.tcAlias+".OBJNAME") = "C" AND ;
       TYPE(m.tcAlias+".OBJVALUE") = "C" AND ;
       TYPE(m.tcAlias+".OBJINFO") = "M" 
       
* additional fields may be included and order
* is not significant
       
IF NOT m.llReturn
   
   m.lcMessage = IIF(EMPTY(m.tcFailureMsgTable),;
                         OUTPUTCLASS_CONFIGTABLEWRONG_LOC, ;
                         m.tcFailureMsgTable)  + ;
               CHR(13)+CHR(13)+ ;
               DBF(m.tcAlias)
ENDIF   


IF m.llReturn

   IF (SET("EXACT") = "OFF")
      SET EXACT ON
      m.llExactOff = .T.
   ENDIF
   
   m.liSelect = SELECT(0)
   SELECT (m.tcAlias)

   * check for required keys...

   DIME laRequired[5]
   laRequired[1] = "OBJTYPE"
   laRequired[2] = "OBJCODE"
   laRequired[3] = "OBJNAME"
   laRequired[4] = "OBJVALUE"
   laRequired[5] = "DELETED()"   

   IF TAGCOUNT() > 0
      DIME laKeys[TAGCOUNT()]

      FOR m.liTagCount = 1 TO TAGCOUNT()
          laKeys[m.liTagCount] = UPPER(KEY(m.liTagCount))
      ENDFOR
   
      FOR m.liTagCount = 1 TO ALEN(laRequired)
         m.liFound = ASCAN(laKeys,UPPER(laRequired[m.liTagCount]))
         IF m.liFound = 0
            m.llReturn = .F.
            EXIT
         ENDIF
      ENDFOR
   ELSE
      m.llReturn = .F.
   ENDIF      
   
   IF NOT m.llReturn
   
     m.llSafetyOn = (SET("SAFETY") = "ON")
     SET SAFETY OFF
   
     TRY
         USE (DBF(m.tcAlias)) EXCLU ALIAS (m.tcAlias)
         INDEX ON Objtype TAG ObjType
         INDEX ON ObjCode TAG ObjCode
         INDEX ON ObjName TAG ObjName
         INDEX ON ObjValue TAG ObjValue
         INDEX ON DELETED() TAG OnDeleted    
         m.llReturn = .T.
      CATCH
      ENDTRY   
      
      IF m.llSafetyOn
         SET SAFETY ON
      ENDIF
      
      IF m.llReturn
         DIME laKeys[TAGCOUNT()]

         FOR m.liTagCount = 1 TO TAGCOUNT()
             laKeys[m.liTagCount] = UPPER(KEY(m.liTagCount))
         ENDFOR
   
         FOR m.liTagCount = 1 TO ALEN(laRequired)
            m.liFound = ASCAN(laKeys,UPPER(laRequired[m.liTagCount]))
            IF m.liFound = 0
               m.llReturn = .F.
               EXIT
            ENDIF
         ENDFOR
      ENDIF

      USE (DBF(m.tcAlias)) SHARED ALIAS (m.tcAlias)
   
   ENDIF
   
   IF NOT m.llReturn
      m.lcMessage =  IIF(EMPTY(m.tcFailureMsgIndexes),;
                         OUTPUTCLASS_CONFIGINDEXMISSING_LOC, ;
                         m.tcFailureMsgTable) + CHR(13) 
      FOR m.liTagCount = 1 TO ALEN(laRequired)
          m.lcMessage = m.lcMessage +  CHR(13) + ;
                      laRequired[m.liTagCount] 
      ENDFOR
   ENDIF
   
   IF m.llExactOff
      SET EXACT OFF
   ENDIF
   SELECT (m.liSelect) 

ENDIF

IF NOT(m.llReturn)
   THIS.DoMessage(m.lcMessage,MB_ICONSTOP )
   THIS.lastErrorMessage = m.lcMessage
ENDIF   

RETURN m.llReturn       

   
ENDPROC
PROCEDURE verifytargetfile
LOCAL m.lcFile

m.lcFile =  ALLTR(CHRTRAN(CHRTRAN(THIS.TargetFileName,;
                       OUTPUTCLASS_FILENAME_CHARS_DISALLOWED,"_"),"/","\"))
* embracing chrtran for slashes is necessary because of FULLPATH behavior.

IF NOT DIRECTORY(JUSTPATH(m.lcFile))
   m.lcFile = FULLPATH(ALLTR(m.lcFile))
ENDIF   

IF DIRECTORY(m.lcFile)
   * we have to generate a filename
   m.lcFile = FORCEPATH(SYS(2015), m.lcFile)
ENDIF

THIS.TargetFileName = m.lcFile   

IF JUSTEXT(THIS.TargetFileName) == "" AND ;
   RIGHT(THIS.TargetFileName,1) # "."      

   THIS.TargetFileExt = CHRTRAN(THIS.TargetFileExt,;
                        OUTPUTCLASS_FILENAME_CHARS_DISALLOWED,"_")

   THIS.TargetFileName = FORCEEXT(THIS.TargetFileName, ;
                                    THIS.TargetFileExt)
ENDIF                                 
 
IF NOT EMPTY(SYS(2000,THIS.TargetFileName))
   ERASE (THIS.TargetFileName) NORECYCLE
ENDIF

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*closetargetfile Finalizes file output.
*configurationobjtype_access 
*createconfigtable Creates a configuration table on demand.
*currentpageimagefilename_assign 
*externalfilelocation_assign 
*generatepageimagefilename Creates a filename for a generated page image file.
*getconfigtable Assesses and provides the name of the current configuration table, optionally creating it on disk if it is not available. 
*getpageimageextension Provides the appropriate file extension for the current pageImageType value.
*makeexternalfilelocationreachable Checks to see if the externalFileLocation (which may be relative to the current targetfilename) exists in the current environment, adjusting if necessary when the output process determines the need to create ancillary output files along with main target.
*opentargetfile Initializes a file for output purposes.
*outputpageimage Use OutputPage method to create a page image file according to current report's requirements.
*pageimagetype_assign 
*readconfiguration_assign 
*setconfiguration Checks the current configuration table for dynamic information in records of appropriate type, and executes these instructions if found.
*supportspageimages Evaluates whether the current reporting mode supports generating page images.
*targetfileext_assign 
*targetfilename_assign 
*targethandle_assign 
*verifyconfigtable Ascertains that the format and and contents of the configuration meet requirements, adjusting it if necessary.
*verifytargetfile Assures that the nominated filename and its network location are available at the beginning of a file-based report run.
configurationobjtype Holds the reserved value used to indicate that a configuration table row provides dynamic configuration information at runtime.
configurationtable Holds the name of the current configuration table.
currentpageimagefilename Provides the filename for the generated page image file for the current page during a report run, including the externalFileLocation path, which may be relative.
externalfilelocation Assigns a  UNC or file system path, either relative to the main output target or absolute, the file-outputting process uses for external files, such as images, it creates along with the main output target. 
pageimageextension Caches appropriate image file extension for current pageImageType.
pageimagetype Indicates a type of image file you want generated for each output page in a report run at the conclusion of a chained report set.
readconfiguration Indicates the conditions under which SetConfiguration code will run. 0=never, 1 = when the class instance Init runs, 2 = when the class instance runs BeforeReport, 3 = at both Init and BeforeReport.
targetfileext Provides the default file extension for file output.
targetfilename Provides the filename to which output will be written.  A unique name is generated for the class instance, which will be overwritten for successive report runs if not adjusted by the user.
targethandle Provides a low-level file handle, to which output is written directly when the class provides raw data to the file, otherwise reserves the file during the report run so other applications don't write to it .
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED7]
Adds configuration table handling and output target file handling to fxListener class[END RESERVED7]
[START RESERVED8]
reportlisteners.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] utilityreportlistener

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _16E19GTD6
[CLASS] xmllistener
[CLASSLOC] listener.vcx
[BASECLASS] reportlistener
[OBJNAME] xmldisplaylistener
[START PROPERTIES]
FRXDataSession = -1
Name = "xmldisplaylistener"
_memberdata =     1925<VFPData> <memberdata name="copyimagefilestoexternalfilelocation" type="property" display="copyImageFilesToExternalFileLocation" favorites="True" /> <memberdata name="imagefieldinstance" type="property" display="imageFieldInstance"  /> <memberdata name="imagefieldtofile" type="property" display="imageFieldToFile"  /> <memberdata name="imagefilebasename" type="property" display="imageFileBaseName" favorites="True" /> <memberdata name="imagesrcattr" type="property" display="imageSrcAttr" favorites="True" /> <memberdata name="jpgclsid" type="property" display="JPGclsid" /> <memberdata name="oldexternalfilelocation" type="property" display="oldExternalFileLocation"  /> <memberdata name="oldsendgdiplusimage" type="property" display="oldSendGDIPlusImage"/> <memberdata name="checkreportforgeneralfields" type="method" display="checkReportForGeneralFields" /><memberdata name="initializefilecopysettings" type="method" display="initializeFileCopySettings" /><memberdata name="utilityimage" type="property" display="utilityImage" /><memberdata name="adjustshapeaspectratio" type="method" display="adjustShapeAspectRatio" /><memberdata name="fillalphaattr" display="fillAlphaAttr" type="property"/><memberdata name="fillredattr" display="fillRedAttr" type="property"/><memberdata name="fillgreenattr" display="fillGreenAttr" type="property"/><memberdata name="fillblueattr" display="fillBlueAttr" type="property"/><memberdata name="penalphaattr" display="penAlphaAttr" type="property"/><memberdata name="penredattr" display="penRedAttr" type="property"/><memberdata name="pengreenattr" display="penGreenAttr" type="property"/><memberdata name="penblueattr" display="penBlueAttr" type="property"/><memberdata name="fontnameattr" display="fontNameAttr" type="property"/><memberdata name="fontstyleattr" display="fontStyleAttr" type="property"/><memberdata name="fontsizeattr" display="fontSizeAttr" type="property"/></VFPData>
externalfilelocation = ("")
fillalphaattr = ("FA")
fillblueattr = ("FB")
fillgreenattr = ("FG")
fillredattr = ("FR")
fontnameattr = ("FNAME")
fontsizeattr = ("FSIZE")
fontstyleattr = ("FSTYLE")
imagefieldinstance = 0
imagefieldtofile = ("")
imagefilebasename = ("")
imagesrcattr = ("img")
includebandswithnoobjects = .T.
includeformattinginlayoutobjects = .T.
jpgclsid = (.NULL.)
oldexternalfilelocation = ("")
oldsendgdiplusimage = 0
penalphaattr = ("PA")
penblueattr = ("PB")
pengreenattr = ("PG")
penredattr = ("PR")
utilityimage = .NULL.
[END PROPERTIES]
[START PROTECTED]
adjustshapeaspectratio
checkreportforgeneralfields
imagefieldinstance
imagefieldtofile
initializefilecopysettings
jpgclsid
oldexternalfilelocation
oldsendgdiplusimage
utilityimage
[END PROTECTED]
[START METHODS]
PROCEDURE AfterReport
LPARAMETERS tlCalledEarly
DODEFAULT(tlCalledEarly)
THIS.resetDataSession() 
ENDPROC
PROCEDURE BeforeReport
IF THIS.XMLMode # OUTPUTXML_RDL_ONLY
   THIS.oldSendGDIPlusImage = THIS.SendGDIPlusImage     
   THIS.oldExternalFileLocation =  THIS.ExternalFileLocation    
   THIS.JPGclsid = NULL && force reinitialization for each report
                        && on possible discovery of an image control mid-way
   IF THIS.checkReportForGeneralFields() 
      THIS.initializeFileCopySettings()
   ENDIF    
ENDIF   
DODEFAULT()
THIS.resetDataSession()

ENDPROC
PROCEDURE Destroy
STORE NULL TO ;
   THIS.JPGclsid, ;
   THIS.FormattingChanges, ;
   THIS.UtilityImage

DODEFAULT()


ENDPROC
PROCEDURE EvaluateContents
LPARAMETERS m.nFRXRecno, m.oObjProperties
IF DODEFAULT(m.nFRXRecno,m.oObjProperties)
   THIS.setFRXDataSession()
   IF USED(THIS.formattingChanges) AND NOT(EOF(THIS.formattingChanges))
      SELECT (THIS.formattingChanges) 
      WITH m.oObjProperties
         IF .Reload       
              REPLACE Reload WITH .T., ;
                   FR WITH .FillRed, ;
                   FG WITH .FillGreen, ;
                   FB WITH .FillBlue, ;
                   FA WITH .FillAlpha, ;
                   PR WITH .PenRed, ;
                   PG WITH .PenGreen, ;
                   PB WITH .PenBlue, ;
                   PA WITH .PenAlpha, ;
                   FNAME WITH .FontName, ;
                   FSTYLE WITH .FontStyle, ;
                   FSIZE WITH .FontSize
         ENDIF
      ENDWITH         
      SELECT FRX
   ENDIF
   THIS.resetDataSession() 
ENDIF   
           
ENDPROC
PROCEDURE Init
IF DODEFAULT()
   THIS.AppName = OUTPUTXMLDISPLAY_APPNAME_LOC
ELSE
   RETURN .F.   
ENDIF

RETURN NOT THIS.HadError
ENDPROC
PROCEDURE Render
LPARAMETERS m.nFRXRecNo,m.nLeft,m.nTop,m.nWidth,m.nHeight, ;
            m.nObjectContinuationType, m.cContentsToBeRendered, m.GDIPlusImage

LOCAL m.llCopyImage, m.lcFile, m.liDefaultBehavior

IF m.GDIPlusImage > 0 AND ;
  (ISNULL(THIS.Jpgclsid) OR EMPTY(THIS.Jpgclsid))
   * we didn't have any general fields but we do have
   * an image control, referenced as an expression,
   * they have explicitly turned on SendGDIPlusImage, and
   * this is the first time we're hitting an image control:
   THIS.initializeFileCopySettings()
ENDIF    

THIS.SetFRXDataSession()
GO m.nFRXRecNo IN FRX

IF THIS.CopyImageFilesToExternalFileLocation 
    IF (FRX.ObjType = FRX_OBJTYP_PICTURE) AND ;
       FRX.Offset # FRX_PICTURE_SOURCE_GENERAL AND ;
       FILE(m.cContentsToBeRendered)
       * use FILE() function here,
       * need to find if it is
       * built into an app
       m.llCopyImage = .T.
    ENDIF
ENDIF   

IF (FRX.ObjType = FRX_OBJTYP_PICTURE) AND ;
    FRX.General = FRX_PICTUREMODE_SCALE_KEEP_SHAPE AND ;
    FRX.Offset # FRX_PICTURE_SOURCE_GENERAL AND ;
    FILE(m.cContentsToBeRendered)
    * NB: doing this *only* when necessary for re-scaling.
    * see above for why FILE() function -- this will work
    * with the image object.
    THIS.utilityImage = LOADPICTURE(m.cContentsToBeRendered)
ENDIF    

THIS.SetCurrentDataSession()   

DO CASE

CASE m.llCopyImage

   m.lcFile = FORCEPATH(m.cContentsToBeRendered, ;
            FULLPATH(THIS.ExternalFileLocation,ADDBS(JUSTPATH(THIS.TargetFileName))))
            
   IF EMPTY(SYS(2000,m.lcFile))
   
      * used to be:
      * COPY FILE (cContentsToBeRendered) TO (lcFile)
      * to handle files built into an app
      
      STRTOFILE(FILETOSTR(m.cContentsToBeRendered),m.lcFile)
    
   ENDIF   
   
   IF EMPTY(SYS(2000,m.lcFile))
      THIS.ImageFieldToFile = ""
   ELSE
      THIS.ImageFieldToFile = JUSTFNAME(m.lcFile)
   ENDIF
   
CASE THIS.SendGDIPlusImage > LISTENER_SEND_GDI_IMAGE_NONE  AND ;
   m.GDIPlusImage > 0  AND ;
   GdipSaveImageToFile(m.GDIPlusImage,;
       STRCONV(FORCEPATH(THIS.ImageFileBaseName + "_"+ ;
                         TRANSFORM(THIS.ImageFieldInstance+1)+".jpg",;
                         FULLPATH(THIS.ExternalFileLocation,ADDBS(JUSTPATH(THIS.TargetFileName))))+CHR(0), ;
               STRCONV_DBCS_UNICODE) ,THIS.JPGCLSID,0) = 0

   THIS.ImageFieldInstance = THIS.ImageFieldInstance + 1       

   THIS.ImageFieldToFile = THIS.ImageFileBaseName +"_"+ ;
                           TRANSFORM(THIS.ImageFieldInstance)+".jpg"

OTHERWISE

   THIS.ImageFieldToFile = ""

ENDCASE

m.liDefaultBehavior = DODEFAULT(m.nFRXRecNo, @m.nLeft,@m.nTop,@m.nWidth,@m.nHeight, ;
          @m.nObjectContinuationType, @m.cContentsToBeRendered, @m.GDIPlusImage)
            
THIS.ImageFieldToFile = ""
THIS.UtilityImage = NULL

THIS.resetDataSession()

RETURN m.liDefaultBehavior
ENDPROC
PROCEDURE UnloadReport
DODEFAULT()
IF NOT (THIS.noPageEject OR ;
 ((TYPE("THIS.CommandClauses.NoPageEject") = "L") AND ;
   THIS.CommandClauses.NoPageEject))
   IF NOT ISNULL(THIS.OldExternalFileLocation)
      * even if empty
      THIS.ExternalFileLocation = THIS.OldExternalFileLocation
      THIS.OldExternalFileLocation = NULL    
   ENDIF      
   IF NOT (THIS.OldSendGDIPlusImage = THIS.SendGDIPlusImage)
      THIS.SendGDIPlusImage = THIS.OldSendGDIPlusImage
   ENDIF   
ENDIF   
THIS.resetDataSession()


ENDPROC
PROCEDURE adjustshapeaspectratio
LPARAMETERS m.tnWidth, m.tnHeight
IF VARTYPE(THIS.utilityImage) = "O"
   * the image is coming from a file of some sort
   * and we need to scale-and-retain
   LOCAL m.llAdjustHeight, m.llAdjustWidth
   DO CASE
   CASE (tnWidth < tnHeight) 
        * use 100% of the width of the space and scale the height        
        m.llAdjustHeight = .T.
   CASE (tnWidth > tnHeight) 
        * use 100% of the height of the space and scale the width
        m.llAdjustWidth = .T.
   CASE (m.tnWidth = m.tnHeight) 
       DO CASE
       CASE THIS.utilityImage.Height > THIS.utilityImage.Width
           m.llAdjustWidth = .T.
       CASE THIS.utilityImage.Height < THIS.utilityImage.Width
           m.llAdjustHeight = .T.
       OTHERWISE
           * both square, don't do adjustment
       ENDCASE           
   ENDCASE        
   If m.llAdjustWidth
      m.tnWidth = m.tnHeight *  ;
         (THIS.utilityImage.Width / THIS.utilityImage.Height)
   ENDIF
   If m.llAdjustHeight
      m.tnHeight = m.tnWidth * ;
         (THIS.utilityImage.Height / THIS.utilityImage.Width)
   ENDIF
ENDIF
ENDPROC
PROCEDURE checkreportforgeneralfields
LOCAL m.liGeneralFields, m.lcID, m.llOpened

m.liGeneralFields = 0

IF TYPE("THIS.CommandClauses.File") = "C" AND ;
   (NOT EMPTY(THIS.CommandClauses.File)) AND ;
   (FILE(THIS.CommandClauses.File)) && NB this is done before setting up dummy CommandClauses
   
   THIS.SetFRXDataSession()

   IF USED("FRX") 
      * this will be true
      * if we call in BeforeReport,
      * but that seems to cause a problem,
      * when we re-assign SendGDIPlusImage
      * so we're likely to call earlier,
      * in the LoadReport method
      SELECT FRX
   ELSE
      USE (THIS.CommandClauses.File) SHARED NOUPDATE ALIAS FRX IN 0
      SELECT FRX
      m.llOpened = .T.
   ENDIF   

   COUNT FOR ObjType = FRX_OBJTYP_PICTURE  AND  ;
           Offset =  FRX_PICTURE_SOURCE_GENERAL TO ;
             m.liGeneralFields

   IF m.llOpened
      USE IN FRX         
   ENDIF

   THIS.ResetDataSession()
ENDIF  

RETURN ( m.liGeneralFields > 0 )



ENDPROC
PROCEDURE contattr_assign
LPARAMETERS m.vNewVal
LOCAL m.lcVal
m.lcVal = THIS.ContAttr
DODEFAULT(m.vNewVal)
IF NOT (m.lcVal == THIS.ContAttr)
   THIS.SynchXSLTProcessorUser()
ENDIF   
ENDPROC
PROCEDURE copyimagefilestoexternalfilelocation_assign
LPARAMETERS m.vNewVal
IF NOT THIS.IsRunning and VARTYPE(m.vNewVal) = "L"
   IF NOT (m.vNewVal = THIS.CopyImageFilesToExternalFileLocation)
      THIS.CopyImageFilesToExternalFileLocation = m.vNewVal
      THIS.adjustXSLTParameter(IIF(m.vNewVal,"1","0"),"copyImageFiles")
      IF THIS.CopyImageFilesToExternalFileLocation 
         THIS.makeExternalFileLocationReachable()
      ENDIF
   ENDIF   
ENDIF   

ENDPROC
PROCEDURE datatextattr_assign
LPARAMETERS m.vNewVal
LOCAL m.lcVal
m.lcVal = THIS.dataTextAttr 
DODEFAULT(m.vNewVal)
IF NOT (m.lcVal == THIS.dataTextAttr)
   THIS.SynchXSLTProcessorUser()
ENDIF   
ENDPROC
PROCEDURE datatypeattr_assign
LPARAMETERS m.vNewVal
LOCAL m.lcVal
m.lcVal = THIS.dataTypeAttr 
DODEFAULT(m.vNewVal)
IF NOT (m.lcVal == THIS.dataTypeAttr )
   THIS.SynchXSLTProcessorUser()
ENDIF   
ENDPROC
PROCEDURE fillalphaattr_assign
LPARAMETERS m.vNewVal
IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal) ;
   AND NOT (m.vNewVal == THIS.fillAlphaAttr)
   THIS.fillAlphaAttr = m.vNewVal
   THIS.SynchXSLTProcessorUser()
ENDIF   





ENDPROC
PROCEDURE fillblueattr_assign
LPARAMETERS m.vNewVal
IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal);
   AND NOT (m.vNewVal == THIS.fillBlueAttr)
   THIS.fillBlueAttr = m.vNewVal
   THIS.synchXsltProcessorUser()
ENDIF   

ENDPROC
PROCEDURE fillgreenattr_assign
LPARAMETERS m.vNewVal
IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal);
   AND NOT (m.vNewVal == THIS.fillGreenAttr)
   THIS.fillGreenAttr = m.vNewVal
   THIS.synchXsltProcessorUser()
ENDIF   

ENDPROC
PROCEDURE fillredattr_assign
LPARAMETERS m.vNewVal
IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal);
   AND NOT (m.vNewVal == THIS.fillRedAttr)
   THIS.fillRedAttr = m.vNewVal
   THIS.synchXsltProcessorUser()
ENDIF   

ENDPROC
PROCEDURE fontnameattr_assign
LPARAMETERS m.vNewVal
IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal);
   AND NOT (m.vNewVal == THIS.fontNameAttr)
   THIS.fontNameAttr = m.vNewVal
   THIS.synchXsltProcessorUser()
ENDIF   

ENDPROC
PROCEDURE fontsizeattr_assign
LPARAMETERS m.vNewVal
IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal);
   AND NOT (m.vNewVal == THIS.fontSizeAttr)
   THIS.fontSizeAttr = m.vNewVal
   THIS.synchXsltProcessorUser()
ENDIF   

ENDPROC
PROCEDURE fontstyleattr_assign
LPARAMETERS m.vNewVal
IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal);
   AND NOT (m.vNewVal == THIS.fontStyleAttr)
   THIS.fontStyleAttr = m.vNewVal
   THIS.synchXsltProcessorUser()
ENDIF   

ENDPROC
PROCEDURE getrawformattinginfo
LPARAMETERS m.tnLeft, m.tnTop, m.tnWidth, m.tnHeight, m.tnObjectContinuationType
LOCAL m.lcInfo

THIS.adjustShapeAspectRatio (@tnWidth, @tnHeight)

m.lcInfo = DODEFAULT(m.tnLeft, m.tnTop, m.tnWidth, m.tnHeight, m.tnObjectContinuationType)
IF NOT EMPTY(THIS.ImageFieldtoFile) 
   m.lcInfo = m.lcInfo + " "+THIS.ImageSrcAttr+"='"+THIS.ImageFieldtoFile+"'"
ENDIF   

THIS.setFRXDataSession()
IF USED(THIS.formattingChanges) AND ;
   SEEK(RECNO("FRX"),THIS.formattingChanges,"FRXRecno")          
   SELECT (THIS.formattingChanges)
   IF Reload
      m.lcInfo = m.lcInfo + " "+THIS.penAlphaAttr+"='"+TRANSFORM(PA)+"'"      
      m.lcInfo = m.lcInfo + " "+THIS.penRedAttr+"='"+TRANSFORM(PR)+"'"      
      m.lcInfo = m.lcInfo + " "+THIS.penGreenAttr+"='"+TRANSFORM(PG)+"'"      
      m.lcInfo = m.lcInfo + " "+THIS.penBlueAttr+"='"+TRANSFORM(PB)+"'"                                       
      m.lcInfo = m.lcInfo + " "+THIS.fillAlphaAttr+"='"+TRANSFORM(FA)+"'"      
      m.lcInfo = m.lcInfo + " "+THIS.fillRedAttr+"='"+TRANSFORM(FR)+"'"      
      m.lcInfo = m.lcInfo + " "+THIS.fillGreenAttr+"='"+TRANSFORM(FG)+"'"      
      m.lcInfo = m.lcInfo + " "+THIS.fillBlueAttr+"='"+TRANSFORM(FB)+"'"                                       
      m.lcInfo = m.lcInfo + " "+THIS.fontNameAttr+"='"+TRANSFORM(FNAME)+"'"   
      m.lcInfo = m.lcInfo + " "+THIS.fontSizeAttr+"='"+TRANSFORM(FSIZE)+"'"   
      m.lcInfo = m.lcInfo + " "+THIS.fontStyleAttr+"='"+TRANSFORM(FSTYLE)+"'"                         
   ENDIF
   SELECT FRX
ENDIF

RETURN m.lcInfo
ENDPROC
PROCEDURE getvfprdlcontents
LPARAMETERS m.tcNodeName, m.tlAsString

IF VARTYPE(THIS.CommandClauses) = "O"

   ADDPROPERTY(THIS.CommandClauses,;
             "externalFileLocation", ;
             THIS.externalFileLocation)
             
   ADDPROPERTY(THIS.CommandClauses, ;
            "copyImageFilesToExternalFileLocation", ;
            THIS.copyImageFilesToExternalFileLocation) 
            
   ADDPROPERTY(THIS.CommandClauses, ;
            "imageFileBaseName", ;
            THIS.imageFileBaseName)             
ENDIF            
            
RETURN DODEFAULT(m.tcNodeName, m.tlAsString)                         
ENDPROC
PROCEDURE heightattr_assign
LPARAMETERS m.vNewVal
LOCAL m.lcVal
m.lcVal = THIS.HeightAttr
DODEFAULT(m.vNewVal)
IF NOT (m.lcVal == THIS.HeightAttr)
   THIS.SynchXSLTProcessorUser()
ENDIF   
ENDPROC
PROCEDURE idattribute_assign
LPARAMETERS m.vNewVal
LOCAL m.lcVal
m.lcVal = THIS.IdAttribute
DODEFAULT(m.vNewVal)
IF NOT (m.lcVal == THIS.IdAttribute)
   THIS.SynchXSLTProcessorUser()
ENDIF   
ENDPROC
PROCEDURE idrefattribute_assign
LPARAMETERS m.vNewVal
LOCAL m.lcVal
m.lcVal = THIS.IdRefAttribute
DODEFAULT(m.vNewVal)
IF NOT (m.lcVal == THIS.IdRefAttribute)
   THIS.SynchXSLTProcessorUser()
ENDIF   
ENDPROC
PROCEDURE imagefilebasename_assign
LPARAMETERS m.vNewVal
THIS.ImageFileBaseName = ALLTR(CHRTRAN(JUSTSTEM(TRANSFORM(m.vNewVal)),;
                         OUTPUTCLASS_FILENAME_CHARS_DISALLOWED,"_"))
ENDPROC
PROCEDURE imagesrcattr_assign
LPARAMETERS m.vNewVal
IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal) AND ;
   (NOT m.vNewVal == THIS.imageSrcAttr)
   THIS.imageSrcAttr = m.vNewVal
   THIS.SynchXSLTProcessorUser()
ENDIF      

ENDPROC
PROCEDURE initializefilecopysettings
#define CLSID_JPG 	"{557CF401-1A04-11D3-9A73-0000F81EF32E}"


DECLARE INTEGER GdipSaveImageToFile in GDIPLUS.DLL  ;
       integer image,string filename,string @ CLSID_clsidEncoder,integer encoderParams        

LOCAL m.lcID

IF ISNULL(THIS.Jpgclsid) OR EMPTY(THIS.Jpgclsid)
   DECLARE integer CLSIDFromString IN ole32 string,string @
   m.lcID = SPACE(20)
   CLSIDFromString(STRCONV(CLSID_JPG ,STRCONV_DBCS_UNICODE),@m.lcID)      
   THIS.Jpgclsid = m.lcID
   m.lcID = ""
ENDIF

IF THIS.SendGDIPlusImage < LISTENER_SEND_GDI_IMAGE_HANDLE 
   THIS.SendGDIPlusImage =   LISTENER_SEND_GDI_IMAGE_HANDLE
ENDIF   

THIS.makeExternalFileLocationReachable()

ENDPROC
PROCEDURE initializeformattingchangescursor
DODEFAULT()
IF THIS.CallEvaluateContents = LISTENER_CALLDYNAMICMETHOD_ALWAYS
   IF USED(THIS.formattingChanges)
      USE IN (THIS.formattingChanges) && override, faster to re-create
      CREATE CURSOR (THIS.FormattingChanges) ;
             (FRXRecno i, ;
              Reload l, ;
              DText M, ;
              DType c(1), ;
              FA i, ;              
              FR i, ;
              FG i, ;              
              FB i, ;
              PA i, ;              
              PR i, ;
              PG i, ;              
              PB i, ;
              FName v(50), ;
              FStyle i, ;
              FSize i ; 
              )
    ELSE
       CREATE CURSOR (THIS.FormattingChanges) ;
             (FRXRecno i, ;
              Reload l, ;
              FA i, ;              
              FR i, ;
              FG i, ;              
              FB i, ;
              PA i, ;              
              PR i, ;
              PG i, ;              
              PB i, ;
              FName v(50), ;
              FStyle i, ;
              FSize i ; 
              )
    ENDIF              

ENDIF

ENDPROC
PROCEDURE leftattr_assign
LPARAMETERS m.vNewVal
LOCAL m.lcVal
m.lcVal = THIS.LeftAttr
DODEFAULT(m.vNewVal)
IF NOT (m.lcVal == THIS.LeftAttr)
   THIS.SynchXSLTProcessorUser()
ENDIF   
ENDPROC
PROCEDURE pageimageattr_assign
LPARAMETERS vNewVal
LOCAL m.lcVal
m.lcVal = THIS.pageImageAttr
DODEFAULT(m.vNewVal)
IF NOT (m.lcVal == THIS.pageImageAttr)
   THIS.SynchXSLTProcessorUser()
ENDIF  
ENDPROC
PROCEDURE penalphaattr_assign
LPARAMETERS m.vNewVal
IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal);
   AND NOT (m.vNewVal == THIS.penAlphaAttr)
   THIS.penAlphaAttr = m.vNewVal
   THIS.synchXsltProcessorUser()
ENDIF   

ENDPROC
PROCEDURE penblueattr_assign
LPARAMETERS m.vNewVal
IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal);
   AND NOT (m.vNewVal == THIS.penBlueAttr)
   THIS.penBlueAttr = m.vNewVal
   THIS.synchXsltProcessorUser()
ENDIF   

ENDPROC
PROCEDURE pengreenattr_assign
LPARAMETERS m.vNewVal
IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal);
   AND NOT (m.vNewVal == THIS.penGreenAttr)
   THIS.penGreenAttr = m.vNewVal
   THIS.synchXsltProcessorUser()
ENDIF   

ENDPROC
PROCEDURE penredattr_assign
LPARAMETERS m.vNewVal
IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal);
   AND NOT (m.vNewVal == THIS.penRedAttr)
   THIS.penRedAttr = m.vNewVal
   THIS.synchXsltProcessorUser()
ENDIF   

ENDPROC
PROCEDURE resetdocument
THIS.ResetToDefault("ImageFieldInstance")
THIS.ResetToDefault("ImageFieldToFile")
THIS.ResetToDefault("UtilityImage")
DODEFAULT()


ENDPROC
PROCEDURE setdomformattinginfo
LPARAMETERS m.toNode, m.tnLeft, m.tnTop, m.tnWidth,m.tnHeight, m.tnObjectContinuationType

THIS.adjustShapeAspectRatio (@m.tnWidth, @m.tnHeight)

DODEFAULT( m.toNode, m.tnLeft, m.tnTop, m.tnWidth,m.tnHeight, m.tnObjectContinuationType)

IF NOT EMPTY(THIS.ImageFieldtoFile) 
   m.toNode.SetAttribute(THIS.ImageSrcAttr,THIS.ImageFieldtoFile )                  
ENDIF   

THIS.setFRXDataSession()
IF USED(THIS.formattingChanges) AND ;
   SEEK(RECNO("FRX"),THIS.formattingChanges,"FRXRecno")          
   SELECT (THIS.formattingChanges)
   IF Reload
      WITH m.toNode
          .setAttribute(THIS.penAlphaAttr,PA)
          .setAttribute(THIS.penRedAttr,PR)
          .setAttribute(THIS.penGreenAttr,PG)
          .setAttribute(THIS.penBlueAttr,PB)
          .setAttribute(THIS.fillAlphaAttr,FA)
          .setAttribute(THIS.fillRedAttr,FR)
          .setAttribute(THIS.fillGreenAttr,FG)
          .setAttribute(THIS.fillBlueAttr,FB)
          .setAttribute(THIS.fontNameAttr,FNAME)          
          .setAttribute(THIS.fontSizeAttr,FSIZE)          
          .setAttribute(THIS.fontStyleAttr,FSTYLE)                              
      ENDWITH
   ENDIF
   SELECT FRX
ENDIF

ENDPROC
PROCEDURE topattr_assign
LPARAMETERS m.vNewVal
LOCAL m.lcVal
m.lcVal = THIS.TopAttr
DODEFAULT(m.vNewVal)
IF NOT (m.lcVal == THIS.TopAttr)
   THIS.SynchXSLTProcessorUser()
ENDIF   
ENDPROC
PROCEDURE widthattr_assign
LPARAMETERS m.vNewVal
LOCAL m.lcVal
m.lcVal = THIS.WidthAttr
DODEFAULT(m.vNewVal)
IF NOT (m.lcVal == THIS.WidthAttr)
   THIS.SynchXSLTProcessorUser()
ENDIF   
ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*adjustshapeaspectratio Adjust the height and width for the rendered contents of a Picture layout control to give accurate aspect ratio for the current file.
*checkreportforgeneralfields Performs startup chores necessary to save out copies of general fields on disk when a report is rendered.
*copyimagefilestoexternalfilelocation_assign 
*fillalphaattr_assign 
*fillblueattr_assign 
*fillgreenattr_assign 
*fillredattr_assign 
*fontnameattr_assign 
*fontsizeattr_assign 
*fontstyleattr_assign 
*imagefilebasename_assign 
*imagesrcattr_assign 
*initializefilecopysettings Provides required environment settings for non-filebased images to be copied to files at runtime.
*penalphaattr_assign 
*penblueattr_assign 
*pengreenattr_assign 
*penredattr_assign 
copyimagefilestoexternalfilelocation Indicates whether file-based images should be copied to a  common location from their original locations on your disk, for reference  as image sources in the XML output.
fillalphaattr Supplies the name of the XML attribute used to show the Fill-Alpha  value provided to a field control layout object by EvaluateContents processing.
fillblueattr Supplies the name of the XML attribute used to show the Fill-Blue value provided to a field control layout object by EvaluateContents processing.
fillgreenattr Supplies the name of the XML attribute used to show the Fill-Green value provided to a field control layout object by EvaluateContents processing.
fillredattr Supplies the name of the XML attribute used to show the Fill-Red value provided to a field control layout object by EvaluateContents processing.
fontnameattr Supplies the name of the XML attribute used to show the Font-Name value provided to a field control layout object by EvaluateContents processing.
fontsizeattr Supplies the name of the XML attribute used to show the Font-Size value provided to a field control layout object by EvaluateContents processing.
fontstyleattr Supplies the name of the XML attribute used to show the Font-Style value provided to a field control layout object by EvaluateContents processing.
imagefieldinstance Keeps count of image instances for use in generating unique filenames for disk versions of non-filebased images in the report.
imagefieldtofile Holds generated filename for image being rendered to disk from a non-filebased image.
imagefilebasename Assigns an optional  prefix to be added to generated image file names when image files are saved to disk during the rendering of general fields in a report run
imagesrcattr Supplies the name of the XML attribute used to show filename copied, or generated for non-filebased images, at runtime.
jpgclsid Provides the GUID used when accessing GDI+ to request a file to be saved as JPG type.
oldexternalfilelocation Saves the user's old externalFileLocation information during a report run, if the Listener has to temporarily change it to generate  image files from non-filebased images.
oldsendgdiplusimage Saves the user's preference for GDIPlus image handle receipt if the Listener has to temporary change this setting to generate image files from non-filebased images.
penalphaattr Supplies the name of the XML attribute used to show the Pen-Alpha value provided to a field control layout object by EvaluateContents processing.
penblueattr Supplies the name of the XML attribute used to show the Pen-Blue value provided to a field control layout object by EvaluateContents processing.
pengreenattr Supplies the name of the XML attribute used to show the Pen-Green value provided to a field control layout object by EvaluateContents processing.
penredattr Supplies the name of the XML attribute used to show the Pen-Red value provided to a field control layout object by EvaluateContents processing.
utilityimage Utility image object for handling aspect ratio of scale-and-retain filebased images.
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED7]
Tunes XML settings suitably for presentation output needs, and adds image-file-publishing capabilities.[END RESERVED7]
[START RESERVED8]
reportlisteners.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] xmldisplaylistener

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _13E0OB2YR
[CLASS] utilityreportlistener
[CLASSLOC] listener.vcx
[BASECLASS] reportlistener
[OBJNAME] xmllistener
[START PROPERTIES]
</VFPData>
<memberdata name="adjustxsltparameter" type="method" display="adjustXSLTParameter" favorites="True"/>
<memberdata name="evaluatestringtoboolean" display="evaluateStringToBoolean" type="property"/><memberdata name="applyrdltransform" display="applyRDLTransform" type="property"/>
<memberdata name="getrunnodecontents" display="getRunNodeContents" type="method"/><memberdata name="addrunnode" display="addRunNode" type="method"/><memberdata name="includedatatypeattributes" display="includeDataTypeAttributes" type="property" favorites="True"/><memberdata name="datatypeattr" type="property" display="dataTypeAttr" favorites="True"/><memberdata name="datatextattr" type="property" display="dataTextAttr" favorites="True"/><memberdata 
<memberdata name="successorgfxnorender" display="successorGFXNoRender" type="property"/><memberdata name="fixmsxmlobjectfordtds" display="fixMSXMLObjectForDTDs" type="method"/><memberdata name="frxcharsetsinuse" display="frxCharsetsInUse" type="method"/>
FRXDataSession = -1
Height = 23
Name = "xmllistener"
Width = 23
_memberdata =     5491<VFPData><memberdata name="applyusertransform" type="property" display="applyUserTransform" favorites="True"/><memberdata name="applyusertransformtooutput" type="method" display="applyUserTransformToOutput"/><memberdata name="applyxslt" type="method" display="applyXslt" favorites="True"/><memberdata name="columnnodes" type="property" display="columnNodes"/><memberdata name="contattr" type="property" display="contAttr" favorites="True"/><memberdata name="currentband" type="property" display="currentBand"/><memberdata name="currentcolumn" type="property" display="currentColumn"/><memberdata name="includepage" type="property" display="includePage"/><memberdata name="currentdocument" type="property" display="currentDocument" favorites="True"/><memberdata name="currentpage" type="property" display="currentPage"/><memberdata name="datanodes" type="property" display="dataNodes"/><memberdata name="getdefaultuserxslt" type="method" display="getDefaultUserXslt"/><memberdata name="preparefrxcopy" type="method" display="prepareFrxCopy"/><memberdata name="removefrxcopy" type="method" display="removeFrxCopy"/><memberdata name="getpathedimageinfo" type="method" display="getPathedImageInfo"/><memberdata name="getrawformattinginfo" type="method" display="getRawFormattingInfo"/><memberdata name="getvfprdlcontents" type="method" display="getVFPRdlContents"/><memberdata name="getfrxlayoutobjectfieldlist" type="method" display="getFrxLayoutObjectFieldlist"/><memberdata name="heightattr" type="property" display="heightAttr" favorites="True"/><memberdata name="idattribute" type="property" display="idAttribute" favorites="True"/><memberdata name="idrefattribute" type="property" display="idrefAttribute" favorites="True"/><memberdata name="includebandswithnoobjects" type="property" display="includeBandsWithNoObjects" favorites="True"/><memberdata name="includebreaksindata" type="property" display="includeBreaksInData" favorites="True"/><memberdata name="includedatasourcesinvfprdl" type="property" display="includeDataSourcesInVfpRdl" favorites="True"/><memberdata name="includeformattinginlayoutobjects" type="property" display="includeFormattingInLayoutObjects" favorites="True"/><memberdata name="insertxmlconfigrecords" type="method" display="insertXmlConfigRecords"/><memberdata name="leftattr" type="property" display="leftAttr" favorites="True"/><memberdata name="loadprocessorobject" type="method" display="loadProcessorObject"/><memberdata name="nopageeject" type="property" display="noPageEject" favorites="True"/><memberdata name="pagenodes" type="property" display="pageNodes"/><memberdata name="resetdocument" type="method" display="resetDocument" favorites="True"/><memberdata name="resetreport" display="resetReport" type="method"/><memberdata name="setdomformattinginfo" type="method" display="setDOMFormattingInfo"/><memberdata name="setfrxdatasession" type="method" display="setFRXDataSession"/><memberdata name="synchxsltprocessoruser" type="method" display="synchXsltProcessorUser"/><memberdata name="topattr" type="property" display="topAttr" favorites="True"/><memberdata name="verifyattributenames" type="method" display="verifyAttributeNames"/><memberdata name="verifyncname" type="method" display="verifyNCName" favorites="True"/><memberdata name="verifynodenames" type="method" display="verifyNodeNames"/><memberdata name="widthattr" type="property" display="widthAttr" favorites="True"/><memberdata name="writeraw" type="method" display="writeRaw"/><memberdata name="xmlmode" type="property" display="xmlMode" favorites="True"/><memberdata name="xmlrawconv" type="method" display="xmlRawConv"/><memberdata name="xmlrawnode" type="method" display="xmlRawNode"/><memberdata name="xmlrawtag" type="method" display="xmlRawTag"/><memberdata name="xsltparameters" type="property" display="xsltParameters" favorites="True"/><memberdata name="xsltprocessorrdl" type="property" display="xsltProcessorRdl" favorites="True"/><memberdata name="xsltprocessoruser" type="property" display="xsltProcessorUser" favorites="True"/>
applyrdltransform = .F.
columnnodes = (NULL)
contattr = ("c")
currentband = (NULL)
currentcolumn = (NULL)
currentdocument = (NULL)
currentpage = (NULL)
datanodes = (NULL)
datatextattr = ("DTEXT")
datatypeattr = ("DTYPE")
evaluatecontentsvalues = (.NULL.)
formattingchanges = (.NULL.)
heightattr = ("h")
idattribute = ("id")
idrefattribute = ("idref")
includebreaksindata = 0
includedatatypeattributes = .F.
includepage = .T.
leftattr = ("l")
name="formattingchanges" type="property" display="formattingChanges" /> <memberdata name="initializeformattingchangescursor" type="method" display="initializeFormattingChangesCursor"/><memberdata name="evaluatecontentsvalues" display="evaluateContentsValues" type="property"/><memberdata name="formatdatavalue" display="formatDataValue" type="method"/><memberdata name="pageimageattr" type="property" display="pageImageAttr" favorites="True"/>
nopageeject = .F.
pageimageattr = ("PLINK")
pagenodes = (NULL)
runcollectorresetlevel = 1
successorgfxnorender = (.NULL.)
targetfileext = ("XML")
topattr = ("t")
widthattr = ("w")
xmlmode = 2
xsltparameters = (NULL)
xsltprocessorrdl = (NULL)
xsltprocessoruser = (NULL)
[END PROPERTIES]
[START PROTECTED]
addrunnode
applyrdltransform
applyusertransformtooutput
columnnodes
currentband
currentcolumn
currentpage
datanodes
evaluatecontentsvalues
evaluatestringtoboolean
fixmsxmlobjectfordtds
formatdatavalue
frxcharsetsinuse
getdefaultuserxslt
getfrxlayoutobjectfieldlist
getpathedimageinfo
getrawformattinginfo
getrunnodecontents
getvfprdlcontents
includepage
initializeformattingchangescursor
insertxmlconfigrecords
loadprocessorobject
pagenodes
preparefrxcopy
removefrxcopy
resetreport
setdomformattinginfo
successorgfxnorender
synchxsltprocessoruser
verifyattributenames
verifynodenames
verifytargetfile
writeraw
xmlrawconv
xmlrawnode
xmlrawtag
[END PROTECTED]
[START METHODS]
PROCEDURE AfterBand
LPARAMETERS m.nBandObjCode, m.nFRXRecNo

DODEFAULT(m.nBandObjCode, m.nFRXRecNo)


IF THIS.InvokeOnCurrentPass() AND ;
   THIS.Targethandle > -1 
  
   LOCAL m.lcBand, m.loNode, m.lcID, m.lcIDRef, ;
         m.llFormatBreakBand, m.loObjects, m.llOmitBand


   THIS.SetFRXDataSession()   
   m.lcBand =  IIF(SEEK(OUTPUTXML_OBJTYPE_NODES+FRX_OBJTYP_BAND+ ;
                    OUTPUTXML_OBJTYPE_BANDOFFSET+nBandObjCode,;
                    "Nodes","FrxNodes"),;
                    Nodes.ObjValue, ;
                    OUTPUTXML_GOOFTAG)
                    
   GO m.nFRXRecNo IN FRX
   IF NOT THIS.IncludeBandsWithNoObjects 
      m.loObjects = THIS.FRXCursor.GetObjectsInBand(FRX.UniqueID,.F.,THIS.FRXDataSession)
      IF loObjects.Count = 0
          m.llOmitBand = .T.
      ENDIF
      m.loObjects = NULL
   ENDIF   
   
   THIS.SetCurrentDataSession()
      
   m.llFormatBreakBand = INLIST(m.nBandObjCode,;
                    FRX_OBJCOD_PAGEHEADER, ;
                    FRX_OBJCOD_PAGEFOOTER, ;
                    FRX_OBJCOD_COLHEADER, ;
                    FRX_OBJCOD_COLFOOTER)                 
                    
   * first evaluate THIS.IncludeBreaksInData 
   DO CASE
   CASE m.llOmitBand = .T.
      * nothing
   CASE THIS.IncludeBreaksInData = OUTPUTXML_BREAKS_INDATA OR ;
        NOT m.llFormatBreakBand   

      #IF OUTPUTXML = OUTPUTXML_RAW
         
         IF EMPTY(NVL(THIS.CurrentBand,"")) 
           * see continuation discussion in Render.
           * our fix there may have left us with
           * no band here
           * do nothing
         ELSE
         
            THIS.CurrentBand = NVL(THIS.CurrentBand,"") + ;
               THIS.XMLRawTag( m.lcBand, .F., m.lcID, m.lcIDRef ) 
  
            IF NOT (ISNULL(THIS.CurrentBand) OR EMPTY(THIS.CurrentBand))
               THIS.WriteRaw(THIS.CurrentBand)
               THIS.CurrentBand = ""
            ENDIF

         ENDIF    
               
      #ELIF OUTPUTXML = OUTPUTXML_DOTNET                       
  
      #ELSE
         * nothing to do here when using the DOM
         THIS.CurrentBand = NULL
      #ENDIF

   CASE THIS.IncludeBreaksInData = OUTPUTXML_BREAKS_COLLECTION
      * build the collection which will be inserted into the
      * data before finishing.
      * but the band output at this point is .F.
      #IF OUTPUTXML = OUTPUTXML_RAW
          IF INLIST( m.nBandObjCode, ;
                 FRX_OBJCOD_PAGEHEADER, ;
                 FRX_OBJCOD_PAGEFOOTER) 
             THIS.CurrentPage = NVL(THIS.CurrentPage,"")
             THIS.CurrentPage = THIS.CurrentPage +  ;
                               THIS.XMLRawTag( m.lcBand, .F., m.lcID, m.lcIDRef ) 
             THIS.PageNodes = THIS.PageNodes + THIS.CurrentPage
             THIS.CurrentPage = NULL
          ELSE
             THIS.CurrentColumn = NVL(THIS.CurrentColumn,"")
             THIS.CurrentColumn = THIS.CurrentColumn + ;
                                THIS.XMLRawTag( m.lcBand, .F., m.lcID, m.lcIDRef ) 
             THIS.ColumnNodes = THIS.ColumnNodes + THIS.CurrentColumn
             THIS.CurrentColumn = NULL
          ENDIF
          
      #ELIF OUTPUTXML = OUTPUTXML_DOTNET 
      
      #ELSE
      
          * we leave THIS.CurrentBand alone in this case,
          * to use after the band has finished.
          IF INLIST( nBandObjCode, ;
                 FRX_OBJCOD_PAGEHEADER, ;
                 FRX_OBJCOD_PAGEFOOTER) 
             THIS.CurrentPage = NULL
          ELSE
             THIS.CurrentColumn = NULL
          ENDIF
          
      #ENDIF
   CASE INLIST( m.nBandObjCode, ;
                 FRX_OBJCOD_COLHEADER, ;
                 FRX_OBJCOD_COLFOOTER)   && XMLBREAKS_NONE and column band
   
       THIS.CurrentColumn = NULL
   OTHERWISE  && XMLBREAKS_NONE and page band

       THIS.CurrentPage = NULL
   
   ENDCASE
   
   THIS.resetDataSession()
   
ENDIF


IF INLIST(m.nBandObjCode,FRX_OBJCOD_PAGEFOOTER, FRX_OBJCOD_TITLE) 
   THIS.includePage = .F.
ENDIF

ENDPROC
PROCEDURE AfterReport
LPARAMETERS tlCalledEarly

THIS.SetFRXDataSession()

IF THIS.TargetHandle > -1 AND NOT (THIS.HadError )

    THIS.fillRunCollector()
   
   #IF OUTPUTXML = OUTPUTXML_RAW
   
       LOCAL m.lcNode
       IF NOT THIS.XMLMode = OUTPUTXML_RDL_ONLY 
        
          IF  NOT EMPTY(NVL(THIS.CurrentBand,""))
             m.lcNode = SUBSTR(THIS.CurrentBand,2,AT(" ", THIS.CurrentBand)-2)
             THIS.CurrentBand = THIS.CurrentBand + THIS.XMLRawTag(m.lcNode)
             * write a closing tag
             THIS.WriteRaw(THIS.CurrentBand)
          ENDIF

          IF THIS.IncludeBreaksInData = OUTPUTXML_BREAKS_COLLECTION 
             IF NOT ISNULL(THIS.PageNodes)
                 lcNode =  IIF(SEEK( OUTPUTXML_OBJTYPE_NODES+OUTPUTXML_OBJCODE_PAGES,;
                             "Nodes","FrxNodes"), ;
                           Nodes.ObjValue, ;
                           OUTPUTXML_GOOFTAG)
                 THIS.WriteRaw(THIS.PageNodes) 
                 THIS.WriteRaw(THIS.XMLRawTag(m.lcNode))                  
             ENDIF
             IF NOT ISNULL(THIS.ColumnNodes)
                m.lcNode =  IIF(SEEK( OUTPUTXML_OBJTYPE_NODES+OUTPUTXML_OBJCODE_COLS,;
                             "Nodes","FrxNodes"), ;
                           Nodes.ObjValue, ;
                           OUTPUTXML_GOOFTAG)
                 THIS.WriteRaw(THIS.ColumnNodes) 
                 THIS.WriteRaw(THIS.XMLRawTag(m.lcNode))                                   
             ENDIF
          ENDIF          
        
          m.lcNode =  IIF(SEEK( OUTPUTXML_OBJTYPE_NODES+OUTPUTXML_OBJCODE_DATA,;
                        "Nodes","FrxNodes"), ;
                      Nodes.ObjValue, ;
                      OUTPUTXML_GOOFTAG)
       
          THIS.WriteRaw( THIS.XMLRawTag(m.lcNode))
       ENDIF
        
       m.lcNode = THIS.getRunNodeContents(.T.)
       
       IF NOT (ISNULL(lcNode) OR EMPTY(lcNode))
          THIS.WriteRaw(lcNode)
       ENDIF             

       m.lcNode =  IIF(SEEK( OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_REPORTHEADER, ;
                           "Nodes","ObjType"), ;
                            Nodes.ObjValue, ;
                            OUTPUTXML_GOOFTAG)               
       THIS.WriteRaw( THIS.XMLRawTag(m.lcNode))    

       * check to see if continuation... 
       IF NOT OUTPUTXML_CONTINUATION
          THIS.WriteRaw( THIS.XMLRawTag(THIS.CurrentDocument))          
       ENDIF
  
   #ELIF OUTPUTXML = OUTPUTXML_DOTNET     
      * XMLTextWriter work
   #ELSE
       LOCAL m.loNode
       * domwork here        
       IF THIS.IncludeBreaksInData = OUTPUTXML_BREAKS_COLLECTION
          * currently all this is done on entry, but
          * if not:
          * append the pages collection
          * into the report data node --
          * that's where we should be right now
          * THIS.DataNodes.AppendChild(THIS.PageNodes)
          ** IF NOT ISNULL(THIS.ColumnNodes)
          * THIS.DataNodes.AppendChild(THIS.ColumnNodes)             
          ** ENDIF
       ENDIF
       
       m.loNode = THIS.getRunNodeContents()
       
       IF NOT ISNULL(m.loNode)
          THIS.DataNodes.ParentNode.AppendChild(m.loNode)
       ENDIF             

       IF NOT OUTPUTXML_CONTINUATION
          THIS.CurrentDocument.Save(THIS.TargetFileName)
       ENDIF

       m.loNode = NULL

    #ENDIF

ENDIF
   
IF OUTPUTXML_CONTINUATION
   IF THIS.runCollectorResetLevel = OUTPUTFX_RUNCOLLECTOR_RESET_ONREPORT 
      THIS.resetRunCollector()       
   ENDIF
   THIS.ResetReport()   
ELSE
   IF THIS.runCollectorResetLevel > OUTPUTFX_RUNCOLLECTOR_RESET_NEVER 
      THIS.resetRunCollector()       
   ENDIF
   THIS.ResetDocument()     
   IF (NOT tlCalledEarly) AND ;
      (THIS.applyUserTransform OR ;
       THIS.applyRDLTransform)
      THIS.ApplyUserTransformToOutput()
      IF (NOT THIS.HadError)
         * we suppressed this message earlier when closing the target file,
         * which is just an intermediary format in this case:
         IF THIS.DoMessage( OUTPUTCLASS_SUCCESS_LOC + ;
                        IIF(SYS(2024)="Y",CHR(13)+OUTPUTCLASS_REPORT_INCOMPLETE_LOC,""),;
                        MB_ICONINFORMATION + MB_YESNO ) = IDYES
            _CLIPTEXT = THIS.TargetFileName
         ENDIF
      ENDIF   
   ENDIF   
ENDIF

THIS.resetDataSession()   

IF (NOT tlCalledEarly)
   DODEFAULT()
ENDIF   


ENDPROC
PROCEDURE BeforeBand
LPARAMETERS m.nBandObjCode, m.nFRXRecNo, m.tlContinuedBand

DODEFAULT(m.nBandObjCode, m.nFRXRecNo)

IF INLIST(m.nBandObjCode,FRX_OBJCOD_PAGEHEADER, FRX_OBJCOD_TITLE,FRX_OBJCOD_SUMMARY) 
   THIS.includePage =  THIS.IncludePageInOutput(_PAGENO)
   *(THIS.PageNo >= THIS.CommandClauses.RangeFrom) AND ;
   *    ((THIS.CommandClauses.RangeTo = -1) OR (THIS.PageNo <= THIS.CommandClauses.RangeTo))
   * possibly to be adapted later:
   * regardless of whether IncludePageInOutput() is used
   * or the manual evaluation above (commented) is used,
   * _PAGENO will work for continued reports only if NORESET is not used.
   * THIS.PageNo/THIS.SharedPageNo will not work whether NORESET is used or not,
   * for continued reports, 
   * unless you maintain a private offset.  RANGE is
   * sensitive to the current REPORT FORM command, not the full
   * NOPAGEEJECT (chained) run
   
ENDIF


IF THIS.InvokeOnCurrentPass() AND ;
  THIS.Targethandle > -1 
  
   LOCAL m.lcBand, m.loNode, m.lcID, m.lcIDRef, ;
         m.llFormatBreakBand, m.lcInterruptedBand,;
         m.llOmitBand, m.loObjects

   THIS.SetFRXDataSession()   

   GO m.nFRXRecNo IN FRX   

   IF NOT THIS.IncludeBandsWithNoObjects 
      m.loObjects = THIS.FRXCursor.GetObjectsInBand(FRX.UniqueID,.F.,THIS.FRXDataSession)
      IF m.loObjects.Count = 0
          m.llOmitBand = .T.
      ENDIF
      m.loObjects = NULL
   ENDIF   
      
   m.lcBand =  IIF(SEEK(OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_BAND+ ;
                    OUTPUTXML_OBJTYPE_BANDOFFSET+nBandObjCode,;
                    "Nodes","FrxNodes"),;
                    Nodes.ObjValue, ;
                    OUTPUTXML_GOOFTAG)
   THIS.SetCurrentDataSession()
                    
   m.llFormatBreakBand = INLIST(nBandObjCode,;
                    FRX_OBJCOD_PAGEHEADER, ;
                    FRX_OBJCOD_PAGEFOOTER, ;
                    FRX_OBJCOD_COLHEADER, ;
                    FRX_OBJCOD_COLFOOTER)                 
                    
   
   IF m.llFormatBreakBand

      m.lcIDRef =  TRANSFORM(m.nFRXRecNo) && TRANSFORM(IIF(EMPTY(FRX.UniqueID),"",FRX.UniqueID))
      m.lcID = TRANSFORM(IIF(THIS.sharedPageNo = 0, THIS.PageNo, THIS.sharedPageNo))
         
   ELSE

      m.lcID =  TRANSFORM(m.nFRXRecNo) && TRANSFORM(IIF(EMPTY(FRX.UniqueID),"",FRX.UniqueID) )
      IF m.tlContinuedBand
         m.lcID = m.lcID + "+"
      ENDIF
      m.lcIDRef = TRANSFORM(IIF(THIS.sharedPageNo = 0, THIS.PageNo, THIS.sharedPageNo))
      
   ENDIF

   * first evaluate THIS.IncludeBreaksInData 
   DO CASE
   CASE m.llOmitBand
      * do nothing -- TBD checked later.
   CASE THIS.IncludeBreaksInData = OUTPUTXML_BREAKS_INDATA OR ;
        NOT m.llFormatBreakBand   

      #IF OUTPUTXML = OUTPUTXML_RAW
         IF NOT (ISNULL(THIS.CurrentBand) OR EMPTY(THIS.CurrentBand))
             * a data band has spanned
             * formatting breaks (pages or columns)
             * and we haven't otherwise caught it.
             * This should not happen.
             m.lcInterruptedBand = SUBSTR(ALLTR(THIS.CurrentBand),2,AT(" ", THIS.CurrentBand)-2)
             * write a closing tag
             THIS.WriteRaw(THIS.CurrentBand + THIS.XMLRawTag(m.lcInterruptedBand))
         ENDIF
         
      
        THIS.CurrentBand =  THIS.XMLRawTag( m.lcBand,.T., m.lcID, m.lcIDRef ) 
               
      
      #ELIF OUTPUTXML = OUTPUTXML_DOTNET                       
  
      #ELSE

          m.loNode = THIS.CurrentDocument.CreateElement(m.lcBand)
          m.loNode.SetAttribute(THIS.idAttribute,m.lcID)
          m.loNode.SetAttribute(THIS.idrefAttribute,m.lcIDRef)
          THIS.DataNodes.AppendChild(m.loNode)
          THIS.CurrentBand = m.loNode                                    
          m.loNull = NULL
      #ENDIF

   CASE THIS.IncludeBreaksInData = OUTPUTXML_BREAKS_COLLECTION
      * build the collection which will be inserted into the
      * data before finishing.
      * but the band output at this point is .F.
      #IF OUTPUTXML = OUTPUTXML_RAW
          IF INLIST( m.nBandObjCode, ;
                 FRX_OBJCOD_PAGEHEADER, ;
                 FRX_OBJCOD_PAGEFOOTER) 
             THIS.CurrentPage = NVL(THIS.CurrentPage,"")
             THIS.CurrentPage = THIS.CurrentPage + ;
                                THIS.XMLRawTag( m.lcBand, .T.,m.lcID, m.lcIDRef ) 
          ELSE
             THIS.CurrentColumn = NVL(THIS.CurrentColumn,"")
             THIS.CurrentColumn = THIS.CurrentColumn + ;
                                  THIS.XMLRawTag( m.lcBand, .T., m.lcID, m.lcIDRef ) 
          ENDIF
          
         
      #ELIF OUTPUTXML = OUTPUTXML_DOTNET 
      
      #ELSE
      
          * we leave THIS.CurrentBand alone in this case,
          * to use after the band has finished.
          IF INLIST( m.nBandObjCode, ;
                 FRX_OBJCOD_PAGEHEADER, ;
                 FRX_OBJCOD_PAGEFOOTER) 
             THIS.CurrentPage = THIS.CurrentDocument.CreateElement(m.lcBand)
             THIS.CurrentPage.SetAttribute(THIS.idAttribute,m.lcID)
             THIS.CurrentPage.SetAttribute(THIS.idrefAttribute,m.lcIDRef)
             THIS.PageNodes.AppendChild(THIS.CurrentPage)
          ELSE
             THIS.CurrentColumn = THIS.CurrentDocument.CreateElement(m.lcBand)
             THIS.CurrentColumn.SetAttribute(THIS.idAttribute,m.lcID)
             THIS.CurrentColumn.SetAttribute(THIS.idrefAttribute,m.lcIDRef)
             THIS.ColumnNodes.AppendChild(THIS.CurrentColumn)
          ENDIF
          
      #ENDIF
   CASE INLIST( m.nBandObjCode, ;
                 FRX_OBJCOD_COLHEADER, ;
                 FRX_OBJCOD_COLFOOTER)   && XMLBREAKS_NONE and column band
   
      THIS.CurrentColumn = "X"

   OTHERWISE  && XMLBREAKS_NONE and page band

      THIS.CurrentPage = "X"
   
   ENDCASE
   
   THIS.resetDataSession()
   
ENDIF



ENDPROC
PROCEDURE BeforeReport
DODEFAULT()

IF (NOT THIS.HadError) 
   THIS.SetFRXDataSession()
   IF THIS.isSuccessor 
      * need a private norender object
      * to handle potential rendering tests
      * specific to this output type     
      THIS.successorGFXNoRender = ;
           THIS.checkCollectionForSpecifiedMember(;
           THIS.gfxNoRenderClass,;
           THIS.gfxNoRenderClassLib,.T.,.T.)           
   ENDIF
   IF USED("FRX")
      LOCAL m.liSelect, m.lcDocument, m.lcReport, ;
            m.lcRDL, m.lcPage, m.lcCol, m.lcData, m.loNode, m.loParent
      m.liSelect = SELECT(0)
      SELECT FRX

      IF THIS.TargetHandle = -1 AND ;
         (THIS.applyUserTransform OR ;
          THIS.applyRDLTransform)
         THIS.verifyTargetFile()      
         IF EMPTY(JUSTEXT(THIS.TargetFileName))
            THIS.TargetFileName = FORCEEXT(THIS.TargetFileName,THIS.TargetFileExt)
         ENDIF   
         THIS.AddProperty("SaveTargetFileName",THIS.TargetFileName)
         THIS.TargetFileName = FORCEEXT(THIS.TargetFileName,"TMP")
      ENDIF
         
      IF (THIS.TargetHandle > -1 OR THIS.OpenTargetFile())  
         IF NOT USED("Nodes")
            IF  UPPER(FULLPATH(THIS.ConfigurationTable)) == ;
                UPPER(FULLPATH(FORCEEXT(OUTPUTCLASS_INTERNALDBF,"DBF")))
                USE (THIS.ConfigurationTable) AGAIN IN 0  ;
                   NOUPDATE ALIAS Nodes SHARED
            ELSE       
                USE (THIS.ConfigurationTable) AGAIN IN 0  ;
                   ALIAS Nodes SHARED
                THIS.VerifyNodeNames()
                THIs.VerifyAttributeNames()
            ENDIF
         ENDIF
            
         * create helper object
         * create band and object cursors   
         * we may want to evaluate raw mode
         * as well as THIS.XMLMode to see if these are needed:
         IF (NOT (THIS.IncludeBandsWithNoObjects AND  ;
            THIS.XMLMode = OUTPUTXML_DATA_ONLY) ) && OR OUTPUTXML_PERFORMLOCALECONVERSION 
            THIS.LoadFRXCursor = .T.               
            IF ISNULL(THIS.FRXCursor) OR ;
               (NOT THIS.FRXCursor.CreateObjectCursor("FRX", "OBJECTS", .F., .T. ,THIS.FRXDataSession)) && force the load and make sure
                                                         && we have access to runtime
                                                         && version of the cursor
               THIS.IncludeBandsWithNoObjects = .T.
            ELSE
               SELECT Bands                  
               IF TAGNO("UniqueID") = 0
                  INDEX ON UniqueID TAG UniqueID
               ENDIF
               SET ORDER TO 0                  
               SELECT Objects
               IF TAGNO("UniqueID") = 0
                  INDEX ON UniqueID TAG UniqueID
               ENDIF
               SET ORDER TO 0
            ENDIF   
         ENDIF   
         
         THIS.IsRunning = .T.               
         SET ORDER TO 0 IN FRX            
         m.lcDocument =  IIF(SEEK(OUTPUTXML_OBJTYPE_NODES+ ;
                              OUTPUTXML_OBJCODE_DOC,;
                              "Nodes","FrxNodes"), ;
                              Nodes.ObjValue, ;
                            OUTPUTXML_GOOFTAG)
         m.lcReport =  IIF(SEEK( OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_REPORTHEADER, ;
                            "Nodes","ObjType"), ;
                             Nodes.ObjValue, ;
                             OUTPUTXML_GOOFTAG)               
  
         IF NOT THIS.XMLMode = OUTPUTXML_RDL_ONLY 
            m.lcData =  IIF(SEEK( OUTPUTXML_OBJTYPE_NODES+ ;
                                 OUTPUTXML_OBJCODE_DATA, ;
                                "Nodes","FrxNodes"), ;
                                 Nodes.ObjValue, ;
                                 OUTPUTXML_GOOFTAG)
         ENDIF
         IF NOT THIS.XMLMode = OUTPUTXML_DATA_ONLY 
            m.lcRDL = IIF(SEEK( OUTPUTXML_OBJTYPE_NODES+ ;
                             OUTPUTXML_OBJCODE_RDL, ;
                             "Nodes","FrxNodes"), ;
                             Nodes.ObjValue, ;
                             OUTPUTXML_GOOFTAG)
         ENDIF
         IF THIS.IncludeBreaksInData = OUTPUTXML_BREAKS_COLLECTION   
            m.lcPage =  IIF(SEEK( OUTPUTXML_OBJTYPE_NODES+ ;
                                OUTPUTXML_OBJCODE_PAGES, ;
                                "Nodes","FrxNodes"), ;
                                Nodes.ObjValue, ;
                                OUTPUTXML_GOOFTAG)
   *        GO (THIS.frxHeaderRecno) IN FRX
   *        IF FRX.VPos > 1
            m.lcCol = IIF(SEEK( OUTPUTXML_OBJTYPE_NODES+;
                              OUTPUTXML_OBJCODE_COLS,;
                              "Nodes","FrxNodes"), ;
                               Nodes.ObjValue, ;
                              OUTPUTXML_GOOFTAG)
   
    *       ENDIF
         ENDIF                    
         #IF OUTPUTXML = OUTPUTXML_RAW
             IF EMPTY(THIS.CurrentDocument) OR ISNULL(THIS.CurrentDocument)
                THIS.CurrentDocument = m.lcDocument
                THIS.WriteRaw( ;
                     THIS.XMLRawTag( THIS.CurrentDocument,.T.) )   
             ENDIF
             THIS.WriteRaw( ;
                  THIS.XMLRawTag( m.lcReport,.T.) )   
             * could add FRXname as ID here                
             IF NOT THIS.XMLMode = OUTPUTXML_DATA_ONLY    
                * write RDL here
                THIS.WriteRaw( ;
                     THIS.XMLRawTag( m.lcRDL,.T.,THIS.xmlRawConv( THIS.CommandClauses.FILE)) )  
                THIS.WriteRaw( STRCONV(THIS.GetVFPRDLContents(m.lcRDL, .T.),STRCONV_DBCS_UTF8)  )
                THIS.WriteRaw( ;
                     THIS.XMLRawTag( m.lcRDL) )   
             ENDIF
             IF NOT THIS.XMLMode = OUTPUTXML_RDL_ONLY           
                THIS.WriteRaw( ;
                 THIS.XMLRawTag( m.lcData,.T.) )   
                      
                IF THIS.IncludeBreaksInData = OUTPUTXML_BREAKS_COLLECTION   
                   THIS.PageNodes =  THIS.XMLRawTag( m.lcPage,.T.)  
 *                 IF NOT EMPTY(lcCol)
                      THIS.ColumnNodes = THIS.XMLRawTag(m.lcCol,.T.)
 *                 ENDIF
                ENDIF
              ENDIF
                     
         #ELIF OUTPUTXML = OUTPUTXML_DOTNET
             * XMLTextWriter work  
         #ELSE
             IF VARTYPE(THIS.CurrentDocument) # "O"
                LOCAL m.liSession
                m.liSession = SET("DATASESSION")
                THIS.resetDataSession()
                THIS.CurrentDocument = CREATEOBJECT(OUTPUTXML_DOMFREETHREADED_DOCUMENTOBJECT)
                SET DATASESSION TO (m.liSession)
                * COMPROP(THIS.CurrentDocument,"UTF8",1)                                
                THIS.CurrentDocument.DocumentElement = THIS.CurrentDocument.CreateElement(m.lcDocument)
             ENDIF
             loNode = THIS.CurrentDocument.CreateElement(m.lcReport)                  
             * setattribute id using FRXName here                
             * idref?
             THIS.CurrentDocument.DocumentElement.AppendChild(m.loNode)
             m.loParent = loNode             
             IF NOT THIS.XMLMode = OUTPUTXML_DATA_ONLY    
                m.loNode = THIS.CurrentDocument.CreateElement(m.lcRDL)
                m.loNode.SetAttribute(THIS.idAttribute,THIS.CommandClauses.FILE)
                m.loNode.AppendChild(THIS.GetVFPRDLContents(m.lcRDL))
                m.loParent.AppendChild(m.loNode)
             ENDIF
             IF NOT THIS.XMLMode = OUTPUTXML_RDL_ONLY                        
                m.loNode = THIS.CurrentDocument.CreateElement(m.lcData)
                * possibly add DE stuff here                
                m.loParent.AppendChild(m.loNode)
                THIS.DataNodes = m.loNode
                IF THIS.IncludeBreaksInData = OUTPUTXML_BREAKS_COLLECTION   
                   THIS.PageNodes = THIS.CurrentDocument.CreateElement(m.lcPage)
                   THIS.DataNodes.AppendChild(THIS.PageNodes)
                   THIS.ColumnNodes = THIS.CurrentDocument.CreateElement(m.lcCol)
                   THIS.DataNodes.AppendChild(THIS.ColumnNodes)                   
                ENDIF
             ENDIF
         #ENDIF
         IF THIS.XMLMode = OUTPUTXML_RDL_ONLY
            THIS.AfterReport(.T.)
         ENDIF
      ENDIF
      *&* Sedna
      IF THIS.XMLMode # OUTPUTXML_RDL_ONLY
         THIS.initializeFormattingChangesCursor()    
         SELECT FRX
         IF USED(THIS.formattingChanges)
            SELECT FRX
            SCAN FOR Platform = FRX_PLATFORM_WINDOWS AND ;
                 ObjType = FRX_OBJTYP_FIELD AND NOT DELETED() && fields only
                INSERT INTO (THIS.FormattingChanges) ;
                  (FRXRecno) VALUES (RECNO("FRX"))
            ENDSCAN
            SELECT (THIS.FormattingChanges)
            INDEX ON FRXRecno TAG FRXRecno
            SELECT FRX
         ENDIF
      ENDIF
      STORE NULL TO m.loNode, m.loParent
      SELECT (m.liSelect)
   ELSE
      THIS.DoMessage(OUTPUTXML_FRXMISSING_LOC,MB_ICONSTOP )
      THIS.lastErrorMessage = OUTPUTXML_FRXMISSING_LOC
   ENDIF   
   THIS.resetDataSession()
ENDIF

RETURN 
ENDPROC
PROCEDURE Destroy
   
DODEFAULT()
THIS.ResetDocument()
STORE NULL TO ;
   THIS.ColumnNodes, ;
   THIS.CurrentBand, ;
   THIS.CurrentColumn, ;
   THIS.CurrentDocument, ;
   THIS.CurrentPage, ;
   THIS.DataNodes, ;
   THIS.pageNodes, ;
   THIS.XSLTProcessorRDL, ;
   THIS.XSLTProcessorUser, ;
   THIS.xsltParameters 

ENDPROC
PROCEDURE Error
LPARAMETERS m.nError, m.cMethod, m.nLine

   DODEFAULT(m.nError,m.cMethod,m.nLine)
   * we could evaluate errors first, but generally,
   THIS.CloseTargetFile()
   IF THIS.isRunning
      THIS.QuietMode = .T.
   ENDIF   
   THIS.CancelReport()


ENDPROC
PROCEDURE EvaluateContents
LPARAMETERS m.nFRXRecno, m.oObjProperties
DODEFAULT(m.nFRXRecno,m.oObjProperties)
* do some work even though we may not be
* adding DTYPE and DTEXT, so that
* subclasses can rely on the right record
* being made available in the formattingChanges alias
* and the "empty values" object always being there
IF THIS.InvokeOnCurrentPass() AND ;
   THIS.targetHandle <> -1
   THIS.setFRXDataSession() 
   IF USED(THIS.formattingChanges)
      IF ISNULL(THIS.evaluateContentsValues) 
         * first time
         SELECT (THIS.formattingChanges)
         SCATTER MEMO BLANK NAME THIS.evaluateContentsValues ;
              FIELDS EXCEPT FRXRecno
      ENDIF
      =SEEK(m.nFRXRecno,THIS.FormattingChanges, "FRXRecno") 
      IF NOT EOF(THIS.formattingChanges)
         SELECT (THIS.formattingChanges) 
         GATHER NAME THIS.evaluateContentsValues  && always start off empty
         IF THIS.includeDataTypeAttributes 
            WITH m.oObjProperties
               IF EMPTY(.Value)
                 REPLACE DType WITH "C"
               ELSE
                 REPLACE DType WITH VARTYPE(.Value), ;
                         DText WITH THIS.formatDataValue(.Value)
               ENDIF  
            ENDWITH         
         ENDIF
         SELECT FRX
      ENDIF   
   ENDIF   
   THIS.resetDataSession() 
ELSE
   RETURN .F.   
ENDIF      
           
ENDPROC
PROCEDURE Init
THIS.ReadConfiguration = OUTPUTCLASS_READCONFIG_INIT

IF DODEFAULT()
   THIS.AppName = OUTPUTXML_APPNAME_LOC
   THIS.ResetDocument()
ELSE
   RETURN .F.   
ENDIF

IF THIS.applyUserTransform
   THIS.GetDefaultUserXSLT()
ENDIF   
RETURN NOT THIS.HadError
ENDPROC
PROCEDURE Render
LPARAMETERS m.nFRXRecNo, m.nLeft,m.nTop,m.nWidth,m.nHeight, ;
            m.nObjectContinuationType, m.cContentsToBeRendered, m.GDIPlusImage

IF NOT ISNULL(THIS.successorGFXNoRender)
   * XML Output and descendents respect norendering properties
   * as successors, evaluating them individually since the conditions
   * might apply only to some output types
   IF THIS.successorGFXNoRender.applyFX(THIS,"RENDER",m.nFRXRecNo, m.nLeft) = ;
       OUTPUTFX_BASERENDER_NORENDER
       RETURN OUTPUTFX_BASERENDER_NORENDER
   ENDIF                
ENDIF

IF (DODEFAULT(m.nFRXRecNo, @m.nLeft,@m.nTop,@m.nWidth,@m.nHeight, ;
              @m.nObjectContinuationType, @m.cContentsToBeRendered, @m.GDIPlusImage) # ;
              OUTPUTFX_BASERENDER_NORENDER) AND ;
   THIS.InvokeOnCurrentPass() AND ;
   THIS.Targethandle > -1 

   * also evaluate THIS.IncludeBreaksInData and 
   * the band for the object in question.

   * If the stars align, create the node for the object here.  For now:
   
   LOCAL m.lcNode, m.loNode, m.lcFormattingInfo, m.lcContents,  ;
         m.llTextType, m.loBandRef, m.liBandRecno, m.lcID
  
   THIS.SetFRXDataSession()
   
   GO m.nFRXRecNo IN FRX
   

   m.lcContents = m.cContentsToBeRendered
   m.llTextType = INLIST(FRX.ObjType,  FRX_OBJTYP_LABEL, FRX_OBJTYP_FIELD)
   m.lcID = TRANSFORM(m.nFRXRecNo)
   IF INLIST(m.nObjectContinuationType, ;
             LISTENER_CONTINUATION_MIDDLE, ;
             LISTENER_CONTINUATION_END)
      m.lcID = m.lcID + "+"
   ENDIF

      
   IF THIS.IncludeBreaksInData = OUTPUTXML_BREAKS_COLLECTION ;
      OR (ISNULL(THIS.CurrentPage) AND ISNULL(THIS.CurrentColumn))
      m.lcNode =   IIF(SEEK(OUTPUTXML_OBJTYPE_NODES+FRX.ObjType,"Nodes","ObjType"), ;
                     Nodes.ObjValue,;
                     OUTPUTXML_GOOFTAG)
                  
      #IF OUTPUTXML = OUTPUTXML_RAW
          m.lcFormattingInfo = THIS.GetRawFormattingInfo( m.nLeft, m.nTop, m.nWidth,m.nHeight, m.nObjectContinuationType)
          THIS.setFRXDataSession()          
          IF m.llTextType
             * build 1515: render gets unicode
             m.lcContents = STRCONV(TRANSFORM(m.lcContents),STRCONV_UNICODE_UTF8)
          ELSE
             m.lcContents = TRANSFORM(m.lcContents)  
          ENDIF
          DO CASE
          CASE NOT ISNULL(THIS.CurrentPage)
             THIS.CurrentPage = THIS.CurrentPage +  ;
                 THIS.XMLRawNode( ;
                 m.lcNode, ;
                 m.lcContents, ;
                 m.lcID,.F.,m.lcFormattingInfo) && FRX.UniqueID
          CASE NOT ISNULL(THIS.CurrentColumn)
             THIS.CurrentColumn = THIS.CurrentColumn +  ;
                 THIS.XMLRawNode( ;
                 m.lcNode, ;
                 m.lcContents, ;
                 m.lcID,.F.,m.lcFormattingInfo) 
          OTHERWISE 
             * write directly to the stream
             * First, take care of continuation.
             IF EMPTY(NVL(THIS.CurrentBand,""))
                * first object in a continued band
                 IF ISNULL(THIS.FRXCursor)
                    m.liBandRecno = 0
                 ELSE
                    m.loBandRef =  THIS.FRXCursor.GetBandFor(FRX.UniqueID, .T.,THIS.FRXDataSession)
                    SELECT FRX
                    LOCATE FOR UniqueID == loBandRef.UniqueID
                    IF EOF()
                       m.liBandRecno = 0
                    ELSE
                       m.liBandRecno = RECNO()
                    ENDIF
                 ENDIF
                 IF m.liBandRecno = 0
                    THIS.CurrentBand = THIS.XMLRawTag(OUTPUTXML_GOOFTAG, .T.,;
                                  "0",TRANSFORM(IIF(THIS.sharedPageNo = 0, THIS.PageNo, THIS.sharedPageNo)) )
                 ELSE
                    THIS.SetCurrentDataSession()
                    THIS.BeforeBand(FRX_OBJCOD_DETAIL,m.liBandRecno, .T.)
                    THIS.SetFRXDataSession()
                 ENDIF                 
                 THIS.CurrentBand = THIS.CurrentBand + ;
                      THIS.XMLRawNode( ;
                       m.lcNode, ;
                       m.lcContents, ;
                       m.lcID,.F.,m.lcFormattingInfo) 
                IF EOF()      
                   THIS.WriteRaw(THIS.CurrentBand + ;
                                THIS.XMLRawTag(OUTPUTXML_GOOFTAG))
                   THIS.CurrentBand = ""               
                ENDIF
                GO m.nFRXRecNo IN FRX
             ELSE      
                THIS.CurrentBand = THIS.CurrentBand + ;
                     THIS.XMLRawNode( ;
                      m.lcNode, ;
                      m.lcContents, ;
                      m.lcID,.F., m.lcFormattingInfo) 
             ENDIF
             
          ENDCASE
     
      #ELIF OUTPUTXML =  OUTPUTXML_DOTNET
          * XMLTextWriter work
      #ELSE      
          * if continuation type is of type 2 or 3
          * and we're in a text type object
          * we have to create a new
          * continued band node as if a BeforeBand event has occurred.         
          THIS.setFRXDataSession()
          IF ISNULL(THIS.CurrentBand)
             * first object in a continued band
             IF ISNULL(THIS.FRXcursor)
                m.liBandRecno = 0
             ELSE
                m.loBandRef =  THIS.FRXCursor.GetBandFor(FRX.UniqueID, .T., THIS.FRXDataSession)
                SELECT FRX
                LOCATE FOR UniqueID == m.loBandRef.UniqueID
                m.liBandRecno = RECNO()
             ENDIF
             THIS.SetCurrentDataSession()
             IF EOF()
                 THIS.BeforeBand(FRX_OBJCOD_DETAIL,1, .T.)
             ELSE
                 THIS.BeforeBand(FRX_OBJCOD_DETAIL,m.liBandRecno, .T.)
             ENDIF
             THIS.SetFRXDataSession()
             GO m.nFRXRecNo IN FRX
          ENDIF
          m.loNode = THIS.CurrentDocument.CreateElement(m.lcNode)          
          m.lcContents = TRANSFORM(m.lcContents)            
          * build 1515: render gets unicode, and is already regionally transformed          
          * EXCEPT if it's a filename for an image, in which case it's DBCS          
          IF m.llTextType 
             m.loNode.Text = CREATEBINARY(m.lcContents)          
          ELSE
             m.loNode.Text = m.lcContents          
          ENDIF             
          m.loNode.SetAttribute(THIS.IdAttribute,m.lcID)
          THIS.SetDOMFormattingInfo( m.loNode, m.nLeft, m.nTop, m.nWidth,m.nHeight, m.nObjectContinuationType)
          DO CASE
          CASE NOT ISNULL(THIS.CurrentPage)
             THIS.CurrentPage.AppendChild(m.loNode)          
          CASE NOT ISNULL(THIS.CurrentColumn)
             THIS.CurrentColumn.AppendChild(m.loNode)          
          OTHERWISE
             THIS.CurrentBand.AppendChild(m.loNode)                     
          ENDCASE
          m.loNode = NULL
       #ENDIF
   ELSE
      * otherwise object belongs to a formatting header or footer
      * and we're not processing them (XMLBREAKS_NONE)
   ENDIF                   
   
   THIS.resetDataSession()
   
ENDIF

RETURN  
ENDPROC
PROCEDURE addrunnode
LPARAMETERS m.oXML, m.tvValueExpr, m.tcPropertyName

LOCAL m.oNode, m.vValue
m.oNode = m.oXML.createElement("property")
m.oNode.setAttribute("id",m.tcPropertyName)
m.vValue = THIS.evaluateUserExpression(m.tvValueExpr)
IF TYPE("m.vValue.XML") = "C" && xmlnode
   m.oNode.appendChild(m.vValue)
ELSE
   m.oNode.Text = TRANSFORM(m.vValue)
ENDIF
m.vValue = NULL
m.oXML.DocumentElement.appendChild(m.oNode)
m.oNode = NULL


ENDPROC
PROCEDURE adjustxsltparameter
LPARAMETERS m.tvValue, m.tsKey, m.tlRemoveOnly

LOCAL m.liIndex, m.liSession

IF ISNULL(THIS.XSLTParameters) AND NOT m.tlRemoveOnly
   m.liSession = SET("DATASESSION")
   THIS.resetDataSession()
   THIS.XSLTParameters = CREATEOBJECT("Collection")
   SET DATASESSION TO (m.liSession)
ENDIF

IF NOT ISNULL(THIS.XSLTParameters)
   WITH THIS.XSLTParameters
      FOR m.liIndex = 1 TO .COUNT
          IF .GETKEY(m.liIndex) == m.tsKey
             .REMOVE(m.liIndex)
             EXIT
          ENDIF
      NEXT
      IF NOT (m.tlRemoveOnly)
         .ADD(m.tvValue,m.tsKey)
      ENDIF
   ENDWITH   
ENDIF

ENDPROC
PROCEDURE applyrdltransform_access
RETURN (THIS.XMLMode = OUTPUTXML_RDL_ONLY AND ;
       (NOT ISNULL(THIS.xsltProcessorRdl )))

ENDPROC
PROCEDURE applyusertransform_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "L" AND NOT THIS.IsRunning
   THIS.applyUserTransform = m.vNewVal
   IF THIS.applyUserTransform AND ;
      (ISNULL(THIS.XSLTProcessorUser))
      THIS.GetDefaultUserXSLT()
   ENDIF   
ENDIF   

ENDPROC
PROCEDURE applyusertransformtooutput
DO CASE
CASE (THIS.applyUserTransform AND NOT ;
   (ISNULL(THIS.XSLTProcessorUser))) OR ;
   THIS.applyRDLTransform 

   LOCAL m.lvProcessor

   * THIS.SaveTargetFileName is real
   * THIS.TargetFileName is TMP
   IF THIS.xmlMode = OUTPUTXML_RDL_ONLY
      m.lvProcessor = THIS.XSLTProcessorRDL
   ELSE
      m.lvProcessor = THIS.XSLTProcessorUser
   ENDIF   
   IF NOT EMPTY(SYS(2000,THIS.SaveTargetFileName))
      ERASE (THIS.SaveTargetFileName) NORECYCLE
   ENDIF
   *&* Sedna change to ensure better encoding behavior
   *&* See notes in .ApplyXSLT method
   STRTOFILE(THIS.ApplyXSLT(THIS.TargetFileName,m.lvProcessor, THIS.XSLTParameters), ;
             THIS.SaveTargetFileName)
   ERASE (THIS.TargetFileName) NORECYCLE
   THIS.TargetFileName = THIS.SaveTargetFileName
   RETURN .T.
CASE THIS.applyUserTransform && no processor but public property is still set
   IF NOT EMPTY(SYS(2000,THIS.SaveTargetFileName))
      ERASE (THIS.SaveTargetFileName) NORECYCLE
   ENDIF
   COPY FILE (THIS.TargetFileName) TO (THIS.SaveTargetFileName)
   ERASE (THIS.TargetFileName) NORECYCLE
   THIS.TargetFileName = THIS.SaveTargetFileName
   RETURN .F.  
OTHERWISE
   RETURN .F. 
ENDCASE



ENDPROC
PROCEDURE applyxslt
LPARAMETERS m.tvSource, m.tvProcessor, m.tvParamCollection, m.tvFRXAlias

LOCAL m.loSource, m.loProcessor, m.lcReturn, m.llSuccess, m.liParam, m.liSession, m.llCharsetsInUse

m.lcReturn = ""

STORE NULL TO m.loSource, m.loProcessor

IF VARTYPE(m.tvSource) = "C" 

   * first param can be filename, string, or object
   * if filename or string, test existance
   * and try to load as a dom object
*   m.liSession = SET("DATASESSION")
*   THIS.resetDataSession()
   m.llCharsetsInUse = THIS.frxCharsetsInUse(m.tvFRXAlias)
   m.loSource = CREATEOBJECT(OUTPUTXML_DOMDOCUMENTOBJECT)
   THIS.fixMSXMLObjectForDTDs(m.loSource)
   DO CASE
   CASE FILE(m.tvSource) AND NOT m.llCharsetsInUse
      m.loSource.Load(m.tvSource)
   CASE FILE(m.tvSource) 
      *&* m.loSource.Load(m.tvSource) 
      *&* would introduce problems with the (multi) charset-handling
      *&* in FRX by engine
      *&* see notes below
      m.loSource.LoadXML(FILETOSTR(m.tvSource))
   OTHERWISE
      m.loSource.LoadXML(m.tvSource)
   ENDCASE
*   SET DATASESSION TO (m.liSession)
  
   IF NOT ISNULL(m.loSource) AND ;
      LEN(m.loSource.XML) > 0 AND ;
      EMPTY(m.loSource.parseError.reason)
      m.llSuccess = .T.
   ELSE
      m.loSource = NULL
*      IF NOT ISNULL(m.loSource)
*         THIS.LastErrorMessage = loSource.parseError.reason
*      ENDIF   
   ENDIF
ELSE
   * if object, test nodetypestring availability
   * and then for document/tree shape.
   IF VARTYPE(m.tvSource) = "O"
      TRY 
         IF INLIST("|"+UPPER(m.tvSource.nodeTypeString)+"|", ;
                       "|DOCUMENT|","|ELEMENT|") && quick and dirty test for tree shape
            m.loSource = m.tvSource           
            m.llSuccess = .T.
         ENDIF
      ENDTRY
   ENDIF   

ENDIF

IF m.llSuccess 

   * for failed transformations, return source XML
   m.lcReturn = m.loSource.XML
   
   * as above
   * second param can be filename or object
 
   * if filename, as above
   *  if object, test for appropriate interface
   * figure out if it's a processor factory
   * or an instance (either dom or stylesheet)
   *  and error out if we can't figure it out
   m.llSuccess = .F.
   IF VARTYPE(m.tvProcessor) = "C"    
      m.loProcessor = THIS.LoadProcessorObject(m.tvProcessor)
      IF NOT ISNULL(m.loProcessor)
         m.loProcessor = m.loProcessor.createProcessor()      
      ENDIF
   ELSE
      IF VARTYPE(m.tvProcessor) = "O" 
         TRY
            IF VARTYPE(m.tvProcessor.styleSheet) = "O"
               m.loProcessor = m.tvProcessor
               * if the object was a processor object
               * get a stylesheet instance
               m.loProcessor = m.loProcessor.createProcessor()
            ENDIF   
         CATCH
            * just want to swallow the errors here because
            * of the primitive tests being used
         ENDTRY
      ENDIF
   ENDIF
  
   IF NOT ISNULL(m.loProcessor) 
      m.llSuccess = .T.
   ENDIF
ENDIF

IF m.llSuccess
            
   
   WITH m.loProcessor
      IF VARTYPE(m.tvParamCollection) = "O" AND ;
         UPPER(m.tvParamCollection.BaseClass) == "COLLECTION" AND ;
         m.tvParamCollection.Count > 0

         FOR m.liParam = 1 TO m.tvParamCollection.Count
            .AddParameter(m.tvParamCollection.GetKey(m.liParam), ;
                         m.tvParamCollection.Item(m.liParam))
         ENDFOR
      ENDIF   
      * always override for current external file location info, if we have one:
       IF NOT EMPTY(THIS.externalFileLocation)
          .AddParameter("externalFileLocation", THIS.externalFileLocation)
       ENDIF          
      .input = m.loSource
      .transform()
      m.lcReturn = .output
   ENDWITH

ENDIF

STORE NULL TO m.loSource, m.loProcessor

*&* Sedna change to 
*&* ensure UTF-8 File contents per documented
*&* behavior of this class.  xsl:output encoding is ignored
*&* by the msxml processor transform anyway when outputting
*&* to a string (see http://msdn2.microsoft.com/en-us/library/ms753765.aspx) 
*&* and as a result we are outputting a file with no encoding
*&* specified after the transform.  So we should ensure that it
*&* is in the default XML encoding when none is specified,
*&* which is UTF-8. But Fox has changed the UTF-16 return value 
*&* from the MSXML processor objects to DBCS.  We need to fix 
*&* that at the time we send to disk for other applications to 
*&* read, can't do it before this point.  We can't do it
*&* in cases where the user has marked explicit fontcharsets in
*&* the FRX, since this information is passed along in VFP-RDL XML
*&* and could be treated differently by different output mechanisms/XSLT.
*&* We will preserve original behavior in that case.

IF m.llCharsetsInUse
   RETURN m.lcReturn
ELSE
   RETURN (STRCONV(m.lcReturn,STRCONV_DBCS_UTF8))
ENDIF   
ENDPROC
PROCEDURE closetargetfile
LOCAL m.llResetQuietMode
m.llResetQuietMode =  ;
 ((NOT THIS.HadError) AND (NOT THIS.QuietMode) AND  ;
  (THIS.applyUserTransform OR THIS.applyRDLTransform ))
IF m.llResetQuietMode
   THIS.QuietMode = .T.
ENDIF
DODEFAULT()
IF m.llResetQuietMode
   THIS.QuietMode = .F.
ENDIF      
ENDPROC
PROCEDURE contattr_assign
LPARAMETERS m.vNewVal
IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal)
   THIS.contAttr = m.vNewVal
ENDIF   



ENDPROC
PROCEDURE createconfigtable
LPARAMETERS m.tcDBF, m.tlOverWrite
* table is being created from scratch,
* may be in a VCX in an unknown environment
* (definitely not in REPORTOUTPUT.APP!)

DODEFAULT(m.tcDBF, m.tlOverWrite)

IF NOT THIS.HadError
   LOCAL m.liSelect, m.llSafetyOn
   m.llSafetyOn = (SET("SAFETY") = "ON")
   SET SAFETY OFF
   m.liSelect = SELECT(0)
   SELECT 0
   USE (m.tcDBF) EXCLU  
   INDEX ON ObjType+ObjCode+ ;
      IIF(ObjType=FRX_OBJTYP_BAND+OUTPUTXML_OBJTYPE_NODES, ;
          OUTPUTXML_OBJTYPE_BANDOFFSET,0) ;
      TAG FRXNodes  
   IF m.llSafetyOn
      SET SAFETY ON
   ENDIF   
   THIS.InsertXMLConfigRecords()   
   USE
   SELECT (m.liSelect)
ENDIF   

ENDPROC
PROCEDURE currentdocument_assign
LPARAMETERS m.vNewVal
* TBD: evaluate for readonly status during the life of the report run
THIS.currentdocument = m.vNewVal

ENDPROC
PROCEDURE datatextattr_assign
LPARAMETERS m.vNewVal
IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal)
   THIS.dataTextAttr = m.vNewVal
ENDIF   



ENDPROC
PROCEDURE datatypeattr_assign
LPARAMETERS m.vNewVal
IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal)
   THIS.dataTypeAttr = m.vNewVal
ENDIF   

ENDPROC
PROCEDURE evaluatestringtoboolean
LPARAMETERS tcVal
RETURN INLIST(UPPER(m.tcVal),"YES",".T.","TRUE","1")         
ENDPROC
PROCEDURE fillruncollector
* getRunNodeContents will allow a Collection, 
* a table/alias, or an empty-type object.
* Table/Alias is easiest, and allows you to use
* reset levels of OUTPUTFX_RUNCOLLECTOR_RESET_NEVER or
* OUTPUTFX_RUNCOLLECTOR_RESET_ONCHAIN, because the entry
* keys do not have to be unique.
* However, a Collection or EMPTY object
* allows you to add serialized XML documents as the values
* of a single property if you like. (This is done
* in addRunNode method.) You also don't have to 
* place a cursor in the user's data session.
* (The getRunNodeContents method will find the cursor in the FRX data session 
* as well, but that wouldn't work very well for 
* chained reports; in fact, even CurrentDataSession is
* dicey with chained reports unless you're sure none
* of them has a private data session.)
* For these reasons, although its known document 
* properties are all simple values, xmlListener 
* chooses to implement
* fillRunCollector using a Collection object, and   
* a CASE exists below to load the XML contents properly
* for any consumers that wish to read it as true XML.
* runCollectorResetLevel is readonly at OUTPUTFX_RUNCOLLECTOR_RESET_ONREPORT
* to ensure uniqueness of the keys for each report run.

* If you override this method to use an alias, you can
* gather data cumulatively for chained runs however you
* choose, and getRunNodeContents should cope.

* If you augment this method to add to the collection,
* you can add serialized objects
* in the form of XML nodes that have nothing to do with the 
* original memberdata contents, and may be completely different
* in schema.  HTMLListener does this for HTTP-EQUIV handling.

IF ISNULL(THIS.runCollector) OR VARTYPE(THIS.runCollector) # "O"
   * because we are using OUTPUTFX_RUNCOLLECTOR_RESET_ONREPORT,
   * this should always be true, and the session issue is
   * probably not relevant.  But we will adjust the session
   * in case somebody changes this #DEFINEd life-period of
   * the runCollector object
   LOCAL m.liSession
   m.liSession = SET("DATASESSION")
   THIS.resetDataSession()
   THIS.runCollector = CREATEOBJECT("Collection")
   SET DATASESSION TO (m.liSession)
ENDIF

THIS.setFRXDataSession()
IF USED(THIS.memberDataAlias) 
   LOCAL m.lvValue, m.lcExpr, m.liSelect, m.loXML, m.loXMLTemp
   IF USED("FRX") 
      GO (THIS.frxHeaderRecno) IN FRX
      #IF OUTPUTXML = OUTPUTXML_DOM
         m.loXML = CREATEOBJECT(OUTPUTXML_DOMFREETHREADED_DOCUMENTOBJECT)
         m.loXMLTemp = CREATEOBJECT(OUTPUTXML_DOMFREETHREADED_DOCUMENTOBJECT)
      #ELSE
         m.loXML = CREATEOBJECT("Microsoft.XMLDOM")
         m.loXMLTemp = CREATEOBJECT("Microsoft.XMLDOM")
      #ENDIF      
      IF NOT m.loXML.LoadXML(FRX.Style)
         m.loXML = NULL
      ENDIF
   ENDIF      
   m.liSelect = SELECT(0)

   SELECT (THIS.memberDataAlias)
   SCAN ALL FOR FRXRecno = THIS.frxHeaderRecno AND ;
        Type = FRX_BLDR_MEMBERDATATYPE  ;
        AND (NOT (EMPTY(Execute) OR EMPTY(Name) OR EMPTY(ExecWhen) OR DELETED()))
        * do not check
        * for Name == FRX_BLDR_NAMESPACE_ADVANCEDPROPS   
        * because you can add your own in. 
        * But it must have *some* namespace.
        * IOW, the original metadata record with 
        * blank namespace is not included in this treatment,
        * because its Execute and ExecWhen fields 
        * are specified to have different scripting behavior.       
        m.lvValue = ""
        m.lcExpr = Execute
        DO CASE
        CASE VAL(DeClass) = ADVPROP_EDITMODE_GETEXPR 
           m.lvValue = THIS.evaluateUserExpression(m.lcExpr)
        CASE VAL(DeClass) = ADVPROP_EDITMODE_TEXT AND ;
           NOT ISNULL(m.loXML) 
           m.lvValue = ;
              m.loXML.SelectSingleNode("/VFPData/reportdata" + ;
                      "[@name='" + Name + "' and @execwhen='" + ExecWhen + "']/@execute")
           IF (NOT ISNULL(m.lvValue)) AND ;
              m.loXMLTemp.LoadXML(m.lvValue.Text)
              m.lvValue = m.loXMLTemp.DocumentElement
           ELSE
              m.lvValue = m.lcExpr
               * may not really be XML, we still want the information
           ENDIF                      
        OTHERWISE
           m.lvValue = m.lcExpr
        ENDCASE

        * The following help ensures uniqueness of key values
        * in case people use the same property names in ExecWhen.
        
        IF Name == FRX_BLDR_NAMESPACE_ADVANCEDPROPS 
           m.lcExpr = ExecWhen
        ELSE
           m.lcExpr = Name+"."+ExecWhen
        ENDIF
        IF THIS.runCollector.getKey(m.lcExpr) = 0  
           THIS.runCollector.add(m.lvValue,m.lcExpr)
        ENDIF
   ENDSCAN        
   SELECT (liSelect)
   STORE NULL  TO m.loXML, m.loXMLTemp
ENDIF

ENDPROC
PROCEDURE fixmsxmlobjectfordtds
LPARAMETERS m.toXML

IF VARTYPE(m.toXML) = "O"
  TRY
     WITH m.toXML
        .validateOnParse = .F.
        .resolveExternals = .F.
        .setProperty("ProhibitDTD",.F.)
     ENDWITH
   CATCH WHEN .T. && Swallow any errors.
     *&* This fix primarily benefits
     *&* external usees of the ApplyXSLT public method;
     *&* it does not affect standard/automatic
     *&* usage of ApplyXSLT to VFP-RDL XML files.
     *&* It allows people to use the ApplyXSLT method
     *&* more flexibly when transforming XML data
     *&* between two schemas (standard B2B requirement).
     *&* However, the "ProhibitDTD" property
     *&* is not supported by the original 2003 msxml4.dll
     *&* distribution file.
     *&* The property will exist, and 
     *&* the behavior will be supported, if the user has
     *&* applied fixes and updates to MSXML as is usually
     *&* the case.
     *&* If the msxml4.dll file has been deployed using
     *&* an MSM supplied with VFP as part of a distribution
     *&* setup to a Vista machine, rather than as part of 
     *&* normal OS files in pre-Vista environments, this
     *&* may *not* be the case.
     *&* For information about updates and patches 
     *&* to msxml4.dll, 
     *&* see http://www.microsoft.com/downloads/details.aspx?FamilyID=24b7d141-6cdf-4fc4-a91b-6f18fe6921d4&DisplayLang=en#Instructions
     *&* Vulnerabilities in Microsoft XML Core Services 4.0 Could Allow Remote Code Execution (927978)
     *&* Note that msxml4.dll is a side-by-side installation file and 
     *&* the update will fail to occur properly if the DLL is currently locked
     *&* because an application is, or has been, using it.  This would including
     *&* loading VFP.
     *&* For instructions regarding "locked" file that may cause installation to fail
     *&* and how to get around it, see http://support.microsoft.com/?kbid=927978
     *&* To ensure that the updates have been applied, check the current date
     *&* of the msxml4.dll file in %windir%/system32 directory.
     *&* At this writing (Sedna development timeframe), the date of msxml4.dll is 11/2006.
   ENDTRY
ENDIF

ENDPROC
PROCEDURE formatdatavalue
LPARAMETERS m.tVal
IF INLIST(VARTYPE(m.tVal),"D","T")
   RETURN TTOC(m.tVal,3) 
ELSE
   * a subclass could do more here
   RETURN TRANSFORM(m.tVal)
ENDIF
ENDPROC
PROCEDURE frxcharsetsinuse
LPARAMETERS tcAlias
LOCAL m.liSession, m.liSelect, m.liTally, m.liRec, m.lcAlias, m.llSwitchSessions

IF VARTYPE(tcAlias) # "C" OR EMPTY(tcAlias) OR UPPER(ALLTRIM(tcAlias)) == "FRX"
   m.lcAlias = "FRX"
   m.llSwitchSessions = .T.
ELSE
   m.lcAlias = ALLTRIM(tcAlias)
ENDIF   

m.liTally = 0

IF THIS.FRXDataSession > -1 AND m.llSwitchSessions
   m.liSession = SET("DATASESSION")
   THIS.setFRXDataSession()
ELSE
   m.liSession = -1   
ENDIF   

IF USED(m.lcAlias)
   m.liSelect = SELECT(0)
   m.liRec = RECNO(m.lcAlias)
   SELECT (m.lcAlias)
   COUNT ALL FOR INLIST(ObjType,;
                        FRX_OBJTYP_LABEL,;
                        FRX_OBJTYP_FIELD) AND ;
                  Double AND Resoid # 1 ;
         TO m.liTally            
         *&* RESOID=1 indicates use of default locale, treat this like no charset indication
         *&* do not pay attention to header value, just text labels and expressions,
         *&* because the header value doesn't propagate to existing controls (even at designtime)
         *&* -- it just indicates the default for new objects.        
         *&* If you adjusted the FRX contents at runtime with new 
         *&* text controls, you might want to pay attention to the contents
         *&* of the header RESOID and DOUBLE values, though -- just as the design-time
         *&* components do.
  IF m.liRec > RECCOUNT()
     GO BOTTOM
     SKIP
  ELSE
     GO m.liRec
  ENDIF                   
  SELECT (m.liSelect)
ENDIF

IF m.liSession > -1
   SET DATASESSION TO (m.liSession)
ENDIF

RETURN (m.liTally > 0)
ENDPROC
PROCEDURE getdefaultuserxslt
** this is an abstract method for use by subclasses
ENDPROC
PROCEDURE getfrxlayoutobjectfieldlist
LPARAMETERS m.tcAlias
* frx
* PLATFORM,UNIQUEID,TIMESTAMP,OBJTYPE,OBJCODE,NAME,EXPR,VPOS,HPOS,HEIGHT,WIDTH,STYLE,
* PICTURE,ORDER,UNIQUE,COMMENT,ENVIRON,BOXCHAR,FILLCHAR,TAG,TAG2,PENRED,PENGREEN,PENBLUE,
* FILLRED,FILLGREEN,FILLBLUE,PENSIZE,PENPAT,FILLPAT,FONTFACE,FONTSTYLE,FONTSIZE,MODE,RULER,
* RULERLINES,GRID,GRIDV,GRIDH,FLOAT,STRETCH,STRETCHTOP,TOP,BOTTOM,SUPTYPE,SUPREST,NOREPEAT,RESETRPT,PAGEBREAK,COLBREAK,RESETPAGE,GENERAL,SPACING,DOUBLE,SWAPHEADER,SWAPFOOTER,EJECTBEFOR,EJECTAFTER,PLAIN,SUMMARY,ADDALIAS,OFFSET,TOPMARGIN,BOTMARGIN,TOTALTYPE,RESETTOTAL,RESOID,CURPOS,SUPALWAYS,SUPOVFLOW,SUPRPCOL,SUPGROUP,SUPVALCHNG,SUPEXPR,USER
* objects
* UNIQUEID,OBJTYPE,OBJCODE,EXPR,VPOS,HPOS,HEIGHT,WIDTH,OBJNAME,LOCALE_ID,START_BAND_ID,BAND_OFFSET,END_BAND_ID,BANDLABEL,SELECTED,OBJ_PICT,BAND_SEQ
* bands
* UNIQUEID,OBJTYPE,OBJCODE,EXPR,BANDLABEL,START,STOP,HEIGHT,P_START,P_STOP,P_HEIGHT,RESETTOTAL,BAND_SEQ,REL_BAND_ID



RETURN ;
       "RECNO() AS FrxRecno, "+m.tcAlias+".PLATFORM, "+m.tcAlias+".NAME,"+m.tcAlias+".EXPR,"+m.tcAlias+".OFFSET,"+m.tcAlias+".VPOS,"+m.tcAlias+".HPOS,"+m.tcAlias+".HEIGHT,"+;
       ""+m.tcAlias+".OBJTYPE, "+m.tcAlias+".TAG, "+m.tcAlias+".TAG2,"+m.tcAlias+".PENSIZE,"+m.tcAlias+".PENPAT,"+m.tcAlias+".FILLPAT,"+;
       ""+m.tcAlias+".WIDTH,"+m.tcAlias+".STYLE,"+m.tcAlias+".PICTURE,"+m.tcAlias+".ORDER,"+m.tcAlias+".COMMENT,"+m.tcAlias+".FILLCHAR,"+;       
       ""+m.tcAlias+".PENRED,"+m.tcAlias+".PENGREEN,"+m.tcAlias+".PENBLUE,"+m.tcAlias+".FILLRED,"+m.tcAlias+".FILLGREEN,"+m.tcAlias+".FILLBLUE,"+;
       ""+m.tcAlias+".FONTFACE, "+m.tcAlias+".FONTSTYLE,"+m.tcAlias+".FONTSIZE,"+m.tcAlias+".MODE,"+m.tcAlias+".FLOAT,"+m.tcAlias+".STRETCH,"+m.tcAlias+".STRETCHTOP,"+; 
       "BITTEST( "+m.tcAlias+".FONTSTYLE, 0 ) AS FontBold,"+ ;
       "BITTEST( "+m.tcAlias+".FONTSTYLE, 1 ) AS FontItalic,"+ ;
       "BITTEST( "+m.tcAlias+".FONTSTYLE, 3 ) AS FontUnderline,"+ ;
       "BITTEST( "+m.tcAlias+".FONTSTYLE, 7 ) AS FontStrikeThrough,"+ ;
       "THIS.GetPathedImageInfo("+m.tcAlias+".ObjType, "+m.tcAlias+".Name, "+m.tcAlias+".Picture, "+m.tcAlias+".Offset) AS UnpathedImg,"+ ;       
       "THIS.GetPathedImageInfo("+m.tcAlias+".ObjType, "+m.tcAlias+".Name, "+m.tcAlias+".Picture, "+m.tcAlias+".Offset, .T.) AS PathedImg,"+ ;
       ""+m.tcAlias+".TOP,"+m.tcAlias+".BOTTOM,"+m.tcAlias+".NOREPEAT,"+m.tcAlias+".PAGEBREAK,"+m.tcAlias+".COLBREAK,"+m.tcAlias+".RESETPAGE,"+m.tcAlias+".GENERAL,"+m.tcAlias+".SPACING,"+ ;
       ""+m.tcAlias+".SWAPHEADER,"+m.tcAlias+".SWAPFOOTER,"+m.tcAlias+".EJECTBEFOR,"+m.tcAlias+".EJECTAFTER,"+m.tcAlias+".TOTALTYPE,"+m.tcAlias+".RESETTOTAL,"+ ;
       "IIF("+m.tcAlias+".DOUBLE,"+m.tcAlias+".RESOID,1) AS FONTCHARSET,"+m.tcAlias+".SUPALWAYS,"+m.tcAlias+".SUPOVFLOW,"+m.tcAlias+".SUPRPCOL,"+m.tcAlias+".SUPGROUP,"+m.tcAlias+".SUPVALCHNG,"+m.tcAlias+".SUPEXPR,"+m.tcAlias+".USER,"+ ;
       "OBJECTS.UniqueID AS ObjID, OBJECTS.ObjName, Objects.Locale_ID,"+ ;
       "OBJECTS.START_BAND_ID,OBJECTS.BAND_OFFSET,OBJECTS.END_BAND_ID,"+ ;
       "BANDS.UNIQUEID AS BandID,BANDS.OBJCODE AS BandType,Bands.BANDLABEL,Bands.START,"+;
       "Bands.STOP,Bands.BAND_SEQ,Bands.REL_BAND_ID, ("+m.tcAlias+".ObjType=9 AND (NOT "+m.tcAlias+".Plain)) AS BandStretch"
ENDPROC
PROCEDURE getpathedimageinfo
LPARAMETERS m.tObjType, m.tName, m.tPicture, m.tOffset, m.tPathed
LOCAL m.lcReturn, m.lcFile
m.lcReturn = ""
IF m.tObjType =  FRX_OBJTYP_PICTURE  
   DO CASE
   CASE m.tOffset = 0 && literal filename
      m.lcReturn = STRTRAN(m.tPicture,["],[])
      IF m.tPathed
         m.lcReturn = FULLPATH(m.tPicture,THIS.CommandClauses.File)      
      ELSE
         m.lcReturn = JUSTFNAME(m.tPicture)
      ENDIF
   CASE m.tOffset = 1 && general field
      m.lcReturn = "["+m.tName+"]"
   CASE m.tOffset = 2 AND TYPE(m.tName)= "O" && imagecontrol
      m.lcReturn = "["+m.tName+"]"   
   CASE m.tOffset = 2 AND TYPE(m.tName) = "C" && expression
      m.lcFile = EVALUATE(m.tName)
      IF NOT FILE(m.lcFile)
         m.lcFile = EVALUATE(STRTRAN(m.tName,"()","")) && indirect
      ENDIF
      IF FILE(m.lcFile)
         IF m.tPathed
            m.lcReturn = FULLPATH(EVALUATE(m.tName))
         ELSE
            m.lcReturn = JUSTFNAME(EVALUATE(m.tName))
         ENDIF
      ELSE
         m.lcReturn =  "["+m.tName+"]" 
      ENDIF
   OTHERWISE
      m.lcReturn = "["+m.tName+"]"
   ENDCASE
ENDIF
m.lcReturn = PADR(CHRTRAN(m.lcReturn,"\","/"), OUTPUTXML_CHARFIELD_LIMIT)

RETURN m.lcReturn


ENDPROC
PROCEDURE getrawformattinginfo
LPARAMETERS m.tnLeft, m.tnTop, m.tnWidth, m.tnHeight, m.tnObjectContinuationType
LOCAL m.lcInfo

m.lcInfo = ""

m.lcInfo = m.lcInfo + " "+THIS.contAttr+"='"+TRANSFORM(m.tnObjectContinuationType)+"'"

IF THIS.IncludeFormattingInLayoutObjects
   m.lcInfo = m.lcInfo + " "+THIS.leftAttr+"='"+ TRANSFORM(m.tnLeft)+"'"
   m.lcInfo = m.lcInfo + " "+THIS.topAttr+"='"+TRANSFORM(m.tnTop)+"'"
   m.lcInfo = m.lcInfo + " "+THIS.widthAttr+"='"+TRANSFORM(m.tnWidth)+"'"      
   m.lcInfo = m.lcInfo + " "+THIS.heightAttr+"='"+TRANSFORM(m.tnHeight)+"'"     
ENDIF

THIS.setFRXDataSession()

m.llPageImages = (NOT EMPTY(THIS.currentPageImageFilename)) ;
                  AND USED(THIS.memberDataAlias)

IF THIS.includeDataTypeAttributes  OR m.llPageImages
   IF USED(THIS.FormattingChanges) AND ;
      SEEK(RECNO("FRX"),THIS.FormattingChanges,"FRXRecno") 
      SELECT (THIS.FormattingChanges)                  
      IF THIS.includeDataTypeAttributes
         IF EMPTY(DText)
            m.lcInfo = m.lcInfo + " "+THIS.dataTypeAttr+"='"+DType+"'"            
         ELSE
            m.lcInfo = m.lcInfo + " "+THIS.dataTypeAttr+"='"+DType+"'"      
            m.lcInfo = m.lcInfo + " "+THIS.dataTextAttr+"='"+THIS.xmlRawConv(DText)+"'"     
         ENDIF      
      ENDIF
   ENDIF      
   IF m.llPageImages AND SEEK(RECNO("FRX"),THIS.memberDataAlias,"FRXRecno")
      SELECT (THIS.memberDataAlias)
      LOCATE FOR FRXRecno = RECNO("FRX") AND ;
                 Type == FRX_BLDR_MEMBERDATATYPE AND ;
                 Name == FRX_BLDR_NAMESPACE_ADVANCEDPROPS AND ;
                 ExecWhen == FRX_BLDR_ADVPROP_HTML_PAGEIMAGEHREF AND ;
                 THIS.evaluateStringToBoolean(Execute) 
      IF FOUND()
         m.lcInfo = m.lcInfo + " " + THIS.pageImageAttr+"='"+ ;
                    THIS.currentPageImageFilename +"'"
      ENDIF
   ENDIF   
   SELECT FRX            
ENDIF   


RETURN m.lcInfo
ENDPROC
PROCEDURE getrunnodecontents
LPARAMETERS m.tlAsString

LOCAL m.lcItem, m.oXML, m.lvValue, m.liSession

THIS.setFRXDataSession()
m.lcItem =  IIF(SEEK( OUTPUTXML_OBJTYPE_NODES+ OUTPUTXML_OBJCODE_RUN , ;
                      "Nodes","FrxNodes"), ;
                       Nodes.ObjValue, ;
                      OUTPUTXML_GOOFTAG)               
               
* Handles Cursor, Empty object, Collection
* Raw or dom method.

m.lcItem = "<"  + m.lcItem + "/>"

m.liSession = SET("DATASESSION")
THIS.resetDataSession()
#IF OUTPUTXML = OUTPUTXML_DOM
   m.oXML = CREATEOBJECT(OUTPUTXML_DOMFREETHREADED_DOCUMENTOBJECT)
#ELSE
   m.oXML = CREATEOBJECT("Microsoft.XMLDOM")
#ENDIF      
SET DATASESSION TO (m.liSession)

IF m.oXML.LoadXML(m.lcItem)
   THIS.setCurrentDataSession()
   DO CASE 
   CASE ISNULL(THIS.runCollector)
      m.oXML = NULL
   CASE VARTYPE(THIS.runCollector) = "C" 
      IF NOT (USED(THIS.runCollector) AND ;
              RECCOUNT(THIS.runCollector) > 0)
         * try FRX datasession
         THIS.setFRXDataSession()
      ENDIF        
      IF (USED(THIS.runCollector) AND ;
              RECCOUNT(THIS.runCollector) > 0)
         * two fields significant, first evaluates to property value, 
         * second is property name
         LOCAL m.lcField1, m.lcField2, m.liIndex, m.liSelect
         m.liSelect = SELECT(0)
         SELECT (THIS.runCollector)
         FOR m.liIndex = 1 TO FCOUNT()
             IF INLIST(TYPE(FIELD(m.liIndex)),"M","C")
                IF EMPTY(m.lcField1)
                   m.lcField1 = FIELD(m.liIndex)
                ELSE
                   m.lcField2 = FIELD(m.liIndex)
                   EXIT
                ENDIF
             ENDIF
         ENDFOR
         IF (EMPTY(m.lcField1))
            m.oXML = NULL
         ELSE
            SCAN ALL FOR NOT DELETED()
               THIS.addRunNode(m.oXML,EVAL(m.lcField1),;
                            IIF(EMPTY(m.lcField2) OR EMPTY(EVAL(m.lcField2)), ;
                     "P" + TRANSFORM(RECNO()), EVAL(m.lcField2)))
            ENDSCAN
         ENDIF
      ENDIF         
      SELECT (m.liSelect)      
   CASE VARTYPE(THIS.runCollector) = "O" AND ;
       TYPE("THIS.runCollector.Baseclass") = "U"
         * empty object
       LOCAL m.liIndex, m.laMembers[1]
       IF AMEMBERS(m.laMembers,THIS.runCollector) = 0
          m.oXML = NULL
       ELSE
          FOR m.liIndex = 1 TO ALEN(m.laMembers)
             THIS.addRunNode(m.oXML,;
                             "THIS.runCollector." + m.laMembers[m.liIndex], ;
                             m.laMembers[m.liIndex])
          ENDFOR
       ENDIF          
   CASE VARTYPE(THIS.runCollector) = "O" AND ;
      UPPER(THIS.runCollector.BaseClass) == "COLLECTION"
      LOCAL m.liIndex
      IF THIS.runCollector.Count = 0
         m.oXML = NULL
      ELSE
         FOR m.liIndex = 1 TO THIS.runCollector.Count
            THIS.addRunNode(m.oXML,"THIS.runCollector[" + TRANSFORM(m.liIndex) + "]",;
                            IIF(EMPTY(THIS.runCollector.getKey[m.liIndex]), ;
                                "P" + TRANSFORM(m.liIndex), ;
                                THIS.runCollector.getKey[m.liIndex] ))
         ENDFOR
         
      ENDIF         
   OTHERWISE
      m.oXML = NULL
   ENDCASE      
   
   THIS.setFRXDataSession()

   DO CASE
   CASE ISNULL(m.oXML)
      RETURN NULL
   CASE m.tlAsString
      RETURN m.oXML.DocumentElement.XML   
   OTHERWISE
      RETURN m.oXML.DocumentElement
   ENDCASE
ELSE
   RETURN NULL
ENDIF      
   
ENDPROC
PROCEDURE getvfprdlcontents
LPARAMETERS m.tcNodeName, m.tlAsString
* NB: no push/pop session here, don't bother
* because we're switching back and forth
* rapidly and not changing anything important
LOCAL m.liSelectCurrent, m.liSelectFRX, m.liSession, ;
      m.liFlds, m.liDBFS, m.liIndex1, m.liIndex2, laFlds[1], ;
      laDBFS[1], laRels[1], m.lcAlias, m.lcKey, m.llDesc, ;
      m.lcFilter, m.lcRel, m.liRels, m.lcSkip, m.lcResult, m.llWholePage
LOCAL m.oXA, m.oXT1, m.oXT2, m.oXT3, m.oXT4, m.oXT5,m.oXT6, ;
      m.oXML, m.oNode, m.oCommand
m.liSession = SET("DATASESSION")
THIS.setFRXDataSession()
m.liSelectFRX = SELECT(0)
IF THIS.IncludeDataSourcesInVFPRDL
   CREATE CURSOR VFPDataSource (the_alias c(200), rpt_driver l, the_dbf m, the_order m, order_desc l, the_filter m, the_skip m )
   CREATE CURSOR flds (the_alias c(200), the_field m, the_type c(1))
   CREATE CURSOR rels (the_parent c(200), the_target c(200), the_expr m)
   SELECT flds
   INDEX ON the_alias TAG the_alias
   SELECT rels
   INDEX ON the_parent TAG the_alias
   SELECT VFPDataSource
   SET RELATION TO the_alias INTO flds, the_alias INTO rels
   THIS.setCurrentDataSession() 
   m.liSelectCurrent = SELECT(0)
   m.liDBFS = AUSED(laDBFS) 
   FOR m.liIndex = 1 TO m.liDBFS
      THIS.setCurrentDataSession()
      m.lcAlias = laDBFs[m.liIndex,1]
      SELECT (m.lcAlias)
      m.lcDBF = DBF()
      m.liFlds = AFIELDS(laFlds)
      m.lcKey = SET("ORDER")
      m.llDesc =  (" DESC" $ UPPER(m.lcKey))   
      m.lcFilter = SET("FILTER")
      m.lcSkip = SET("SKIP")
      IF NOT EMPTY(m.lcKey)
         m.lcKey = STRTRAN(UPPER(m.lcKey),"TAG","")
         m.liIndex2 = ATC(" OF",m.lcKey)
         IF m.liIndex2 > 0
            m.lcKey = LEFT(m.lcKey,m.liIndex2)
         ENDIF
         m.lcKey = ALLTR(m.lcKey)
         m.liTag = TAGNO(m.lcKey)
         IF m.liTag > 0
            m.lcKey = KEY(m.liTag)
         ELSE
            m.lcKey = ""
         ENDIF
      ENDIF    
      m.liRels = 0
      STORE "" TO laRels
      DO WHILE .T.
         m.lcRel = RELATION(m.liRels + 1)
         IF EMPTY(m.lcRel)
            EXIT
         ELSE
            m.liRels = m.liRels + 1
            DIME laRels[m.liRels,3]
            laRels[m.liRels,1] = TARGET(m.liRels)
            laRels[m.liRels,2] = m.lcRel
         ENDIF
      ENDDO
      THIS.setFRXDataSession()
      INSERT INTO VFPDataSource VALUES (m.lcAlias, (UPPER(m.lcAlias)==UPPER(THIS.Drivingalias)), m.lcDBF, m.lcKey, m.llDesc, m.lcFilter, m.lcSkip)
      FOR m.liIndex2 = 1 TO m.liFlds
         INSERT INTO flds VALUES (m.lcAlias, laFlds[m.liIndex2,1], laFlds[m.liIndex2,2])
      ENDFOR
      FOR m.liIndex2 = 1 TO m.liRels
         INSERT INTO rels VALUES (m.lcAlias, laRels[m.liIndex2,1], laRels[m.liIndex2,2])   
      ENDFOR
   ENDFOR
   THIS.setCurrentDataSession()
   SELECT (m.liSelectCurrent)
ENDIF
THIS.setFRXDataSession()
m.lcAlias = THIS.prepareFrxCopy()
m.lcResult = THIS.getFRXLayoutObjectFieldList(m.lcAlias)
SELECT &lcResult ;
   FROM (m.lcAlias) ;
   LEFT JOIN Bands ON &lcAlias..UniqueID = Bands.UniqueID ;
   LEFT JOIN Objects ON &lcAlias..UniqueID = Objects.UniqueID ;
   WHERE Platform = FRX_PLATFORM_WINDOWS AND NOT DELETED() ;
   INTO CURSOR VFPFRXLayoutObject READWRITE
THIS.removeFRXCopy(m.lcAlias)   
SELECT VFPFRXLayoutObject
* get rid of compiled data:
IF TYPE("VFPFRXLayoutObject.Tag") # "U"
   REPLACE Tag WITH "" ALL FOR NOT INLIST(ObjType,FRX_OBJTYP_VARIABLE,FRX_OBJTYP_BAND,FRX_OBJTYP_DATAENV ,FRX_OBJTYP_DATAOBJ)
ENDIF
IF TYPE("VFPFRXLayoutObject.Tag2") # "U"
   REPLACE Tag2 WITH "" ALL FOR INLIST(ObjType,FRX_OBJTYP_REPORTHEADER,FRX_OBJTYP_DATAENV,FRX_OBJTYP_DATAOBJ)
ENDIF
IF TYPE("VFPFRXLayoutObject.Fontface") # "U"
   REPLACE Fontface WITH ""  ALL FOR INLIST(ObjType,FRX_OBJTYP_DATAENV,FRX_OBJTYP_DATAOBJ)
ENDIF   
GO TOP IN VFPFRXLayoutObject
m.llWholePage = VFPFRXLayoutObject.Top 
SELECT Nodes.ObjValue AS Name, ;
       Nodes.ObjType-OUTPUTXML_OBJTYPE_NODES AS Type, ;
       Nodes.ObjCode AS Code, ;
       Nodes.ObjInfo AS Info ;
    FROM Nodes ;   
    WHERE BETWEEN(ObjType,OUTPUTXML_OBJTYPE_NODES, OUTPUTXML_OBJTYPE_NODES+100) ;
    AND NOT DELETED() ;
    INTO CURSOR VFPFRXLayoutNode READWRITE
m.liFlds = AMEMBERS(laFlds, THIS,0)
FOR m.liIndex1 = 1 TO m.liFlds
   IF ATC("attr",laFlds[m.liIndex1]) > 1
      INSERT INTO VFPFRXLayoutNode VALUES ;
        (TRANSFORM(EVALUATE("THIS."+laFlds[m.liIndex1])),;
         0, ;
         OUTPUTXML_OBJCODE_ATTRIBMEMBER,;
         laFlds[m.liIndex1]+ " attribute nodename")
   ENDIF
ENDFOR   
m.oXA=CREATEOBJECT("XMLAdapter")
m.oXA.RespectCursorCP = .T.
m.oXT4 = m.oXA.AddTableSchema("VFPFRXLayoutObject")
m.oXT5 = m.oXA.AddTableSchema("VFPFRXLayoutNode")

IF USED(THIS.memberDataAlias) AND ;
   RECCOUNT(THIS.memberDataAlias) > 0
   m.oXT6 = m.oXA.AddTableSchema(THIS.memberDataAlias,.F.,;
                                 STRCONV("VFPFRXMemberData",STRCONV_DBCS_UNICODE))
ENDIF
m.oXA.RespectNesting=.T.
IF THIS.IncludeDataSourcesInVFPRDL
   m.oXT1=oXA.AddTableSchema("VFPDataSource")
   m.oXT2=oXA.AddTableSchema("flds")
   m.oXT3=oXA.AddTableSchema("rels")
   m.oXT1.Nest(m.oXT2)
   m.oXT1.Nest(m.oXT3)
ENDIF

m.oXA.XMLSchemaLocation = ""
m.oXA.ToXML("lcResult")
THIS.resetDataSession()
#IF OUTPUTXML = OUTPUTXML_DOM
   m.oXML = CREATEOBJECT(OUTPUTXML_DOMFREETHREADED_DOCUMENTOBJECT)
#ELSE
   m.oXML = CREATEOBJECT("Microsoft.XMLDOM")
#ENDIF      
THIS.setFRXDataSession()
m.oXML.LoadXML(m.lcResult)
m.oNode = m.oXML.SelectSingleNode("/./*")
IF NOT ISNULL(THIS.CommandClauses)
   m.oCommand = m.oXML.createElement("VFPFRXCommand")
   m.liFlds = AMEMBERS(laFlds, THIS.CommandClauses)   
   FOR m.liIndex1 = 1 TO m.liFlds
       m.lcKey = EVAL("THIS.CommandClauses."+laFlds[m.liIndex1]) 
       IF VARTYPE(m.lcKey) = "L"
          IF m.lcKey
             m.lcKey = "true"
          ELSE
             m.lcKey = "false"
          ENDIF
       ENDIF
       m.oCommand.SetAttribute(laFlds[m.liIndex1], TRANSFORM(m.lcKey))
   ENDFOR
   m.oCommand.SetAttribute("OutputType",TRANSFORM(THIS.OutputType))
   m.oCommand.SetAttribute("appName",THIS.appName)
   m.oCommand.SetAttribute("targetFileName",THIS.targetFileName)
   m.oNode.appendChild(m.oCommand)
ENDIF   
m.oCommand =  oXML.createElement("VFPFRXPrintJob")
m.oCommand.SetAttribute("pagewidth", THIS.SharedPageWidth)
m.oCommand.SetAttribute("pageheight", THIS.SharedPageHeight)
m.oCommand.SetAttribute("name",THIS.PrintJobName)
m.oCommand.SetAttribute("pagedesign",IIF(llWholePage,"whole","printable"))
TRY
   * if PROMPT was used this will probably work
   m.oCommand.SetAttribute("printresolution",TRANSFORM(PRTINFO(PRT_YRESOLUTION ,SET("PRINTER",3))))
   #IF .F. 
      * OUTPUTXML_RESOLUTIONFIX
      * try to reset based on current printer FRX information
      GO (THIS.frxHeaderRecno) IN FRX
      SELECT FRX
      m.liIndex = IIF(ALINES(laFlds,Picture,.T.) > 0, ASCAN(laFlds,"YRESOLUTION"),0) 
      IF m.liIndex = 0
         m.liIndex = IIF(ALINES(laFlds,Expr,.T.) > 0, ASCAN(laFlds,"YRESOLUTION"),0) 
      ENDIF
      IF m.liIndex > 0
         m.liIndex = VAL(ALLTRIM(SUBSTR(laFlds[liIndex],AT("=",laFlds[m.liIndex])+1)))
         IF m.liIndex > 0
            m.oCommand.SetAttribute("printresolution",TRANSFORM(m.liIndex))         
         ELSE
            m.oCommand.SetAttribute("printresolution","-1")                  
         ENDIF
      ENDIF
      IF USED("SetPrinter")
         USE IN SetPrinter
      ENDIF
   #ENDIF    
CATCH WHEN .T.
   * this can happen when there is no printer
   m.oCommand.SetAttribute("printresolution","-1") 
ENDTRY   
m.oNode.appendChild(m.oCommand)
IF THIS.IncludeDataSourcesInVFPRDL
   USE IN VFPDataSource
   USE IN flds
   USE IN rels
ENDIF   
USE IN VFPFRXLayoutObject
USE IN VFPFRXLayoutNode
STORE NULL TO ;
   m.oXA, m.oXT1, m.oXT2, m.oXT3, m.oXT4, m.oXT5, m.oXT6, m.oXML, m.oCommand
SELECT (m.liSelectFRX)
SET DATASESSION TO (m.liSession)
IF tlAsString
   RETURN m.oNode.XML
ELSE
   RETURN m.oNode
ENDIF
ENDPROC
PROCEDURE heightattr_assign
LPARAMETERS m.vNewVal
IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal)
   THIS.heightAttr = m.vNewVal
ENDIF   



ENDPROC
PROCEDURE idattribute_assign
LPARAMETERS m.vNewVal
IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal)
   THIS.idattribute = m.vNewVal
ENDIF   

ENDPROC
PROCEDURE idrefattribute_assign
LPARAMETERS m.vNewVal
IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal)
   THIS.idrefattribute = m.vNewVal
ENDIF   

ENDPROC
PROCEDURE includebandswithnoobjects_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "L" AND NOT THIS.IsRunning 
   THIS.IncludeBandsWithNoObjects = m.vNewVal
ENDIF   

ENDPROC
PROCEDURE includebreaksindata_assign
LPARAMETERS m.vNewVal
* Readonly during report run

IF VARTYPE(m.vNewVal) = "N" AND ;
   INLIST(m.vNewVal, ;
          OUTPUTXML_BREAKS_INDATA,;
          OUTPUTXML_BREAKS_NONE, ;
          OUTPUTXML_BREAKS_COLLECTION) AND ;
   NOT THIS.IsRunning 
   THIS.IncludeBreaksInData = m.vNewVal
ENDIF   

ENDPROC
PROCEDURE includedatasourcesinvfprdl_assign
LPARAMETERS m.vNewVal

IF VARTYPE(m.vNewVal) = "L" 
   THIS.IncludeDataSourcesinVFPRDL = m.vNewVal
ENDIF   

ENDPROC
PROCEDURE includedatatypeattributes_assign
LPARAMETERS m.tvNewVal
IF VARTYPE(m.tvNewVal) = "L"
   THIS.includeDataTypeAttributes = m.tvNewVal
ENDIF   

ENDPROC
PROCEDURE includeformattinginlayoutobjects_assign
LPARAMETERS m.vNewVal
*TBD: evaluate whether
* it's okay to do this during a run?

IF VARTYPE(m.vNewVal) = "L"
   THIS.IncludeFormattingInLayoutObjects = m.vNewVal
ENDIF   

ENDPROC
PROCEDURE initializeformattingchangescursor
THIS.formattingChanges= "F"+SYS(2015)
IF THIS.includeDataTypeAttributes 
   CREATE CURSOR (THIS.formattingChanges) ;
             (FRXRecno i, ;
              DText M, ;
              DType C(1))
ENDIF 
ENDPROC
PROCEDURE insertxmlconfigrecords
* protected,
* assumes it is being called with config
* table already SELECTed.

   DELETE FOR ;
      BETWEEN(OBJTYPE,OUTPUTXML_OBJTYPE_NODES, OUTPUTXML_OBJTYPE_NODES + 100)

   INSERT INTO (ALIAS()) VALUES ;
    (OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_BAND, ;
      FRX_OBJCOD_TITLE,'','Title','Title Band nodename')
   INSERT INTO (ALIAS()) VALUES ;
    (OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_BAND,;
      FRX_OBJCOD_PAGEHEADER,'','PH','Page Header Band nodename')
   INSERT INTO (ALIAS()) VALUES ;
    (OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_BAND,;
      FRX_OBJCOD_COLHEADER,'','CH','Column Header Band nodename')
   INSERT INTO (ALIAS()) VALUES ;
    (OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_BAND,;
      FRX_OBJCOD_GROUPHEADER,'','GH','Group Header Band nodename')
   INSERT INTO (ALIAS()) VALUES ;
    (OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_BAND, ;
      FRX_OBJCOD_DETAIL,'','D','Detail Band nodename')
   INSERT INTO (ALIAS()) VALUES ;
    (OUTPUTXML_OBJTYPE_NODES+FRX_OBJTYP_BAND, ;
      FRX_OBJCOD_GROUPFOOTER,'','GF','Group Footer Band nodename')
   INSERT INTO (ALIAS()) VALUES ;
    (OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_BAND, ;
      FRX_OBJCOD_COLFOOTER,'','CF','Column Footer Band nodename')
   INSERT INTO (ALIAS()) VALUES ;
    (OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_BAND, ;
      FRX_OBJCOD_PAGEFOOTER,'','PF','Page Footer Band nodename')
   INSERT INTO (ALIAS()) VALUES ;
    (OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_BAND, ;
      FRX_OBJCOD_SUMMARY,'','Summary','Summary Band nodename')
   INSERT INTO (ALIAS()) VALUES ;
    (OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_BAND, ;
      FRX_OBJCOD_DETAILHEADER,'','DH','Detail Header Band nodename')
   INSERT INTO (ALIAS()) VALUES ;
    (OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_BAND, ;
      FRX_OBJCOD_DETAILFOOTER,'','DF','Detail Footer Band nodename')
   INSERT INTO (ALIAS()) VALUES ;
    (OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_REPORTHEADER,;
      FRX_OBJCOD_REPORTHEADER ,'','VFP-Report','Report root nodename')
   INSERT INTO (ALIAS()) VALUES ;
    (OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_LABEL, ;
      FRX_OBJCOD_OTHER,'','T','Text object nodename')
   INSERT INTO (ALIAS()) VALUES ;
    (OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_FIELD, ;
      FRX_OBJCOD_OTHER,'','E','Expression object nodename')
   INSERT INTO (ALIAS()) VALUES ;
    (OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_PICTURE,;
      FRX_OBJCOD_OTHER,'','P','Picture object nodename')
   INSERT INTO (ALIAS()) VALUES ;
    (OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_RECTANGLE,;
      FRX_OBJCOD_RECTANGLE,'','S','Shape object nodename')
   INSERT INTO (ALIAS()) VALUES ;
    (OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_LINE, ;
      FRX_OBJCOD_OTHER,'','L','Line object nodename')
   INSERT INTO (ALIAS()) VALUES ;
    (OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_VARIABLE,;
      FRX_OBJCOD_OTHER,'','V','Variable nodename')
   INSERT INTO (ALIAS()) VALUES ;
    (OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_FONTRES,;
      FRX_OBJCOD_OTHER,'','FontRes','FontResource nodename')
   INSERT INTO (ALIAS()) VALUES ;
    (OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_DATAENV,;
      FRX_OBJCOD_OTHER,'','DataEnv','DataEnvironment nodename')
   INSERT INTO (ALIAS()) VALUES ;
    (OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_DATAOBJ,;
      FRX_OBJCOD_OTHER,'','DE-Cursor','DE-Cursor nodename')
   INSERT INTO (ALIAS()) VALUES ;
    (OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_DATAOBJ, ;
      FRX_OBJCOD_OTHER+1,'','DE-Relation','DE-Relation nodename')
     * offset the DE Relation because
     * this information isn't in ObjType or ObjCode
     * as distinct from DE-Cursor other than in the Name field
   INSERT INTO (ALIAS()) VALUES ;
    (OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_GROUP, ;
      FRX_OBJCOD_OTHER,'','Group','Group selector nodename')
   INSERT INTO (ALIAS()) VALUES ;
    (OUTPUTXML_OBJTYPE_NODES, ;
     OUTPUTXML_OBJCODE_DOC,'','Reports','XML Document root nodename')
   INSERT INTO (ALIAS()) VALUES ;
    (OUTPUTXML_OBJTYPE_NODES,;
     OUTPUTXML_OBJCODE_DATA,'','Data','Report scope data root nodename')
   INSERT INTO (ALIAS()) VALUES ;
    (OUTPUTXML_OBJTYPE_NODES, ;
     OUTPUTXML_OBJCODE_RDL,'','VFP-RDL','RDL layout description root nodename')
   INSERT INTO (ALIAS()) VALUES ;
    (OUTPUTXML_OBJTYPE_NODES, ;
     OUTPUTXML_OBJCODE_PAGES,'','Pages','Pages collection root nodename')
   INSERT INTO (ALIAS()) VALUES ;
    (OUTPUTXML_OBJTYPE_NODES, ;
     OUTPUTXML_OBJCODE_COLS,'','Columns','Column collection root nodename')
   *&* Sedna     
   INSERT INTO (ALIAS()) VALUES ;
    (OUTPUTXML_OBJTYPE_NODES, ;
     OUTPUTXML_OBJCODE_RUN,'','Run','Run property set root nodename')

ENDPROC
PROCEDURE invokeoncurrentpass
RETURN (THIS.includePage) AND ;
       (NOT THIS.XMLMode = OUTPUTXML_RDL_ONLY ) AND ;
       ((NOT THIS.TwoPassProcess) OR THIS.CurrentPass = LISTENER_FULLPASS)
        


ENDPROC
PROCEDURE leftattr_assign
LPARAMETERS m.vNewVal
IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal)
   THIS.leftAttr = m.vNewVal
ENDIF   


ENDPROC
PROCEDURE loadprocessorobject
LPARAMETERS m.tcVal

LOCAL m.loReturn
m.loReturn = NULL

IF VARTYPE(m.tcVal) = "C" AND NOT EMPTY(m.tcVal)
  LOCAL m.loProcessor, m.loStylesheet, m.liSession
  m.liSession = SET("DATASESSION")
  THIS.resetDataSession()
  m.loProcessor  = CREATEOBJECT(OUTPUTXML_XSLT_PROCESSOROBJECT)
  m.loStyleSheet = CREATEOBJECT(OUTPUTXML_DOMFREETHREADED_DOCUMENTOBJECT)
  THIS.fixMSXMLObjectForDTDs(m.loStyleSheet)
  SET DATASESSION TO (m.liSession)
  IF FILE(m.tcVal)
    m.loStyleSheet.Load(m.tcVal)
  ELSE
    * try to load it as a string
    m.loStyleSheet.LoadXML(m.tcVal)
  ENDIF
  IF LEN(m.loStyleSheet.XML) > 0 AND ;
     EMPTY(m.loStyleSheet.parseError.reason)
     m.loProcessor.styleSheet = loStyleSheet
     m.loReturn = m.loProcessor
*  ELSE     
*     THIS.LastErrorMessage = loSStyleSheet.parseError.reason
  ENDIF   
ENDIF

RETURN loReturn
ENDPROC
PROCEDURE nopageeject_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "L" AND NOT THIS.IsRunning
   THIS.NoPageEject = m.vNewVal
ENDIF   

ENDPROC
PROCEDURE opentargetfile
#IF OUTPUTXML = OUTPUTXML_DOM
   THIS.VerifyTargetFile() 
   THIS.TargetHandle = 0
   RETURN (NOT THIS.HadError)
#ELSE
   RETURN DODEFAULT()   
#ENDIF

ENDPROC
PROCEDURE pageimageattr_assign
LPARAMETERS vNewVal

IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal)
   THIS.pageImageAttr = m.vNewVal
ENDIF   


ENDPROC
PROCEDURE preparefrxcopy
LOCAL m.lcAlias, m.lcFile
m.lcAlias = "FRX"
IF EMPTY(SYS(2000,THIS.CommandClauses.File)) AND ;
   USED("FRX")
   *&* streamlined in Sedna leveraging new superclass capabilities.   
   m.lcFile = THIS.prepareFRXSwapCopy(JUSTPATH(THIS.targetFileName),.T.)
   m.lcAlias = JUSTSTEM(m.lcFile)   
   * prepareFRXSwapCopy defines the file name suitably for the
   * above JUSTSTEM() evaluation -> alias to work all the time.
   SELECT FRX
ENDIF
RETURN m.lcAlias
ENDPROC
PROCEDURE removefrxcopy
LPARAMETERS m.tcAlias
LOCAL m.lcFile
IF m.tcAlias # "FRX"
   m.lcFile = DBF(m.tcAlias)
   USE IN (m.tcAlias)
   * streamlined in Sedna using
   * new superclass feature
   THIS.removeFRXSwapCopy(m.lcFile) 
ENDIF      

ENDPROC
PROCEDURE resetcallevaluatecontents
IF (THIS.CallEvaluateContents # LISTENER_CALLDYNAMICMETHOD_ALWAYS) AND ;
   THIS.includeDataTypeAttributes AND ;
   (THIS.xmlMode #  OUTPUTXML_RDL_ONLY)
   THIS.CallEvaluateContents = LISTENER_CALLDYNAMICMETHOD_ALWAYS
ENDIF
ENDPROC
PROCEDURE resetdocument
* Do *not* reset 
* page number/total
THIS.ResetReport()   
THIS.CloseTargetFile()
THIS.NoPageEject = .F.
IF THIS.HadError
   THIS.ResetToDefault("QuietMode")
ENDIF   
THIS.CurrentDocument = NULL




ENDPROC
PROCEDURE resetreport
THIS.IncludePage = .T.
THIS.IsRunning = .F.
THIS.DataNodes = NULL
THIS.PageNodes = NULL
THIS.ColumnNodes = NULL
THIS.CurrentBand = NULL
THIS.CurrentPage = NULL
THIS.CurrentColumn = NULL
THIS.evaluateContentsValues = NULL 
THIS.successorGFXNoRender = NULL
THIS.ClearStatus()   


   

ENDPROC
PROCEDURE resetruncollector
THIS.runCollector = NULL
ENDPROC
PROCEDURE runcollectorresetlevel_assign
LPARAMETERS tvNewVal
THIS.runCollectorResetLevel = OUTPUTFX_RUNCOLLECTOR_RESET_ONREPORT
ENDPROC
PROCEDURE setdomformattinginfo
LPARAMETERS m.toNode, m.tnLeft, m.tnTop, m.tnWidth,m.tnHeight, m.tnObjectContinuationType

m.toNode.SetAttribute(THIS.ContAttr,TRANSFORM(m.tnObjectContinuationType))                  
IF THIS.IncludeFormattingInLayoutObjects
   m.toNode.SetAttribute(THIS.LeftAttr,TRANSFORM(m.tnLeft))
   m.toNode.SetAttribute(THIS.TopAttr,TRANSFORM(m.tnTop))
   m.toNode.SetAttribute(THIS.WidthAttr,TRANSFORM(m.tnWidth))             
   m.toNode.SetAttribute(THIS.HeightAttr,TRANSFORM(m.tnHeight))
ENDIF

LOCAL  m.llPageImages

THIS.setFRXDataSession()

m.llPageImages = (NOT EMPTY(THIS.currentPageImageFilename)) ;
                  AND USED(THIS.memberDataAlias)


IF THIS.includeDataTypeAttributes OR m.llPageImages

   IF USED(THIS.FormattingChanges) AND ;
      SEEK(RECNO("FRX"),THIS.FormattingChanges,"FRXRecno") 
      SELECT (THIS.FormattingChanges)    
      IF THIS.includeDataTypeAttributes                  
         IF EMPTY(DText)
            m.toNode.SetAttribute(THIS.dataTypeAttr,DType)
         ELSE
            m.toNode.SetAttribute(THIS.dataTypeAttr,DType)
            m.toNode.SetAttribute(THIS.dataTextAttr,DText)
         ENDIF      
      ENDIF
   ENDIF    
   IF m.llPageImages AND SEEK(RECNO("FRX"),THIS.memberDataAlias,"FRXRecno")
      SELECT (THIS.memberDataAlias)
      LOCATE FOR FRXRecno = RECNO("FRX") AND ;
                 Type == FRX_BLDR_MEMBERDATATYPE AND ;
                 Name == FRX_BLDR_NAMESPACE_ADVANCEDPROPS AND ;
                 ExecWhen == FRX_BLDR_ADVPROP_HTML_PAGEIMAGEHREF AND ;
                 INLIST(UPPER(Execute),"YES",".T.","TRUE","1") 
      IF FOUND()
         m.toNode.SetAttribute(THIS.pageImageAttr,;
                               THIS.currentPageImageFileName)
      ENDIF      
   ENDIF
   SELECT FRX              
ENDIF   



ENDPROC
PROCEDURE setfrxdatasessionenvironment
DODEFAULT()
SET EXACT ON
SET SYSFORMATS ON
SET CENTURY ON
SET SAFETY OFF
ENDPROC
PROCEDURE setfrxrunstartupconditions
DODEFAULT()
IF TYPE("THIS.CommandClauses.File") # "C"
   ADDPROPERTY(THIS.CommandClauses,"File","")
ENDIF      
IF TYPE("THIS.CommandClauses.NoPageEject") # "L"
   ADDPROPERTY(THIS.CommandClauses,"NoPageEject",.F.)
ENDIF      

ENDPROC
PROCEDURE synchxsltprocessoruser
IF THIS.applyUserTransform AND NOT ISNULL(THIS.XSLTProcessorUser)
   THIS.XSLTProcessorUser = NULL
   THIS.applyUserTransform = .T. && kickstart
ENDIF 
ENDPROC
PROCEDURE targetfileext_assign
LPARAMETERS m.vNewVal
IF VARTYPE(m.vNewVal) = "C" AND ;
   NOT UPPER(ALLTRIM(STRTRAN(m.vNewVal,".",""))) == "TMP"
   DODEFAULT(m.vNewVal)
   * this class reserves the extension
   * TMP for swapping in and out when 
   * using temporary files and XLSTs transforms
ENDIF   
ENDPROC
PROCEDURE topattr_assign
LPARAMETERS m.vNewVal
IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal)
   THIS.topAttr = m.vNewVal
ENDIF   

ENDPROC
PROCEDURE verifyattributenames
* abstract
ENDPROC
PROCEDURE verifyconfigtable
LPARAMETERS m.tcAlias

LOCAL m.llReturn, laRequired[1], m.liIndex, m.liSelect, ;
      m.liTag, m.lcTag, m.lcIndex, m.llSafetyOn, m.llFixedOn

m.llReturn = DODEFAULT(m.tcAlias)

IF m.llReturn
   * check for required tagnames (used in SEEKs)
   
   m.liSelect = SELECT(0)
   SELECT (m.tcAlias)
   
   DIME laRequired[2,2]
   laRequired[1,1] = "OBJTYPE"
   laRequired[1,2] = "OBJTYPE"
   laRequired[2,1] = "FRXNODES"
   laRequired[2,2] = NORMALIZE("OBJTYPE+OBJCODE+IIF(OBJTYPE="+ ;
                      TRANSFORM(FRX_OBJTYP_BAND+OUTPUTXML_OBJTYPE_NODES,"9999999")+"," + ;
                      TRANSFORM(OUTPUTXML_OBJTYPE_BANDOFFSET,"9999999")+",0)")
   
   FOR m.liIndex = 1 TO ALEN(laRequired,1)
       m.liTag = TAGNO(laRequired[m.liIndex,1])
       IF m.liTag = 0 OR NOT NORMALIZE(KEY(m.liTag)) == ;
          laRequired[m.liIndex,2]
          m.llReturn = .F.
       ENDIF
   ENDFOR
   
   IF NOT m.llReturn
      m.llSafetyOn = (SET("SAFETY") = "ON")
      SET SAFETY OFF
      m.llFixedOn = (SET("FIXED") = "ON")
      SET FIXED OFF
   
      TRY
         USE (DBF(m.tcAlias)) EXCLU ALIAS (m.tcAlias)
         FOR m.liIndex = 1 TO ALEN(laRequired,1)
            m.lcTag = laRequired[m.liIndex,1]
            m.lcIndex = laRequired[m.liIndex,2]
            INDEX ON &lcIndex TAG &lcTag
         ENDFOR
      
         m.llReturn = .T.
      CATCH
      ENDTRY   
      
      
      IF m.llReturn
         FOR m.liIndex = 1 TO ALEN(laRequired,1)
             m.liTag = TAGNO(laRequired[m.liIndex,1])
             IF m.liTag = 0 OR NOT NORMALIZE(KEY(m.liTag)) == ;
                laRequired[m.liIndex,2]
                m.llReturn = .F.
             ENDIF
         ENDFOR
      ENDIF
      
      USE (DBF(m.tcAlias)) SHARED ALIAS (m.tcAlias)
      
      IF m.llSafetyOn
         SET SAFETY ON
      ENDIF
      IF m.llFixedOn
         SET FIXED ON
      ENDIF
   
   ENDIF
  
   IF NOT m.llReturn
      m.lcMessage =  OUTPUTXML_CONFIGTAGMISSING_LOC + CHR(13) 
      FOR m.liIndex = 1 TO ALEN(laRequired,1)
          m.lcMessage = m.lcMessage + ;
                     CHR(13) + laRequired[m.liIndex,1] + ;
                     "=" + laRequired[m.liIndex,2]
      ENDFOR               
      THIS.DoMessage(m.lcMessage,MB_ICONSTOP )      
      THIS.lastErrorMessage = OUTPUTXML_CONFIGTAGMISSING_LOC
   ENDIF
   
   IF m.llReturn 
                                  
     * just do one check, this is in case
     * a different listener created the config file.
     * the XML will run just fine without these records,
     * it will just use its gooftag instead of regular
     * nodenames if all or any are missing

     IF NOT SEEK( OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_REPORTHEADER, ;
                               ALIAS(),"ObjType")
        TRY
           IF IsReadOnly()
              USE (DBF(m.tcAlias)) SHARED ALIAS (m.tcAlias)
           ENDIF
           THIS.InsertXMLConfigRecords()
        CATCH
        ENDTRY   
                               
     ENDIF                          
   
   ENDIF
   
   SELECT (m.liSelect)
   
ENDIF

RETURN m.llReturn       

   
ENDPROC
PROCEDURE verifyncname
LPARAMETERS m.tcName

LOCAL m.llValid, m.liChar, m.lcChar

DO CASE 

CASE VARTYPE(m.tcName) # "C" OR EMPTY(m.tcName)
  * invalid
CASE LEFT(m.tcName,1) # "_" AND NOT ISALPHA(LEFT(m.tcName,1))
  * invalid
CASE LEFT(UPPER(m.tcName),3) = "XML"
  * invalid
OTHERWISE
  m.llValid = .T.  
  FOR m.liChar = 2 TO LEN(tcName)
     m.lcChar = SUBSTR(m.tcName,m.liChar,1)
     IF NOT (ISALPHA(m.lcChar) OR ;
             ISDIGIT(m.lcChar) OR ;
             INLIST(m.lcChar,".","-","_"))
        m.llValid = .F.
        EXIT
     ENDIF
  ENDFOR
ENDCASE

RETURN m.llValid 
ENDPROC
PROCEDURE verifynodenames
IF NOT USED("Nodes")
   RETURN .F.
ENDIF
IF ISREADONLY("Nodes")
   RETURN .T.
ENDIF   
   
LOCAL m.liSelect, m.llSuccess
m.liSelect = SELECT(0)
m.llSuccess = .T.
SELECT Nodes
SCAN FOR BETWEEN(ObjType,OUTPUTXML_OBJTYPE_NODES,OUTPUTXML_OBJTYPE_NODES+99) ;
     AND NOT DELETED()
   IF NOT THIS.VerifyNCName(ObjValue)
      DELETE
      m.llSuccess = .F.
   ENDIF
ENDSCAN
                    
SELECT (m.liSelect)
RETURN m.llSuccess                    
ENDPROC
PROCEDURE widthattr_assign
LPARAMETERS m.vNewVal
IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal)
   THIS.widthAttr = m.vNewVal
ENDIF   

ENDPROC
PROCEDURE writeraw
LPARAMETERS m.tcContents

 FWRITE(THIS.TargetHandle, m.tcContents) 

ENDPROC
PROCEDURE xmlmode_assign
LPARAMETERS m.vNewVal
* Readonly during report run
IF NOT THIS.IsRunning
   IF VARTYPE(m.vNewVal) = "N" AND ;
      INLIST(m.vNewVal,;
             OUTPUTXML_DATA_ONLY,;
             OUTPUTXML_RDL_ONLY, ;
             OUTPUTXML_DATA_RDL)
      THIS.xmlmode = m.vNewVal
   ENDIF
ENDIF   

ENDPROC
PROCEDURE xmlrawconv
LPARAMETERS m.tcValue
LOCAL m.lcValue, m.liChar
* must have ampersand as the first STRTRAN()      
m.lcValue = STRTRAN(m.tcValue, '&', '&amp;' )      
m.lcValue = STRTRAN(m.lcValue, '<', '&lt;' )
m.lcValue = STRTRAN(m.lcValue, '>', '&gt;' )
m.lcValue = STRTRAN(m.lcValue, '"', '&quot;' )
m.lcValue = STRTRAN(m.lcValue, ['], '&apos;' )
m.lcValue = CHRTRAN(m.lcValue, CHR(0)+CHR(4), "  ")
RETURN m.lcValue
* TBD: make any adjustments 
* and, if needed, for different element types if needed

ENDPROC
PROCEDURE xmlrawnode
LPARAMETERS m.tcNode,m.tcValue, m.tvID, m.tvIDRef, m.tvFormatting
LOCAL m.lcValue, m.lcNode
IF PARAMETERS() < 2
   m.lcValue = ""
ELSE
   m.lcValue = THIS.XMLRawConv(m.tcValue)
ENDIF
IF EMPTY(m.lcValue) 
  m.lcNode = THIS.XMLRawTag(m.tcNode,NULL, m.tvID, m.tvIDRef, m.tvFormatting)
ELSE
  m.lcNode = THIS.XMLRawTag(m.tcNode, .T., m.tvID, m.tvIDRef, m.tvFormatting)+m.lcValue+THIS.XMLRawTag(m.tcNode)
ENDIF

RETURN m.lcNode
   
ENDPROC
PROCEDURE xmlrawtag
LPARAMETERS m.tcNode, m.tlOpen, m.tcID, m.tcIDRef, m.tvFormatting
LOCAL m.lcNode

IF ISNULL(m.tlOpen) OR m.tlOpen
   m.lcNode = "<" + m.tcNode 
   IF NOT EMPTY(m.tcID)
      m.lcNode = m.lcNode + " "+THIS.idAttribute+"='"+m.tcID+"'"
   ENDIF
   IF NOT EMPTY(m.tcIDRef)
      m.lcNode = m.lcNode + " "+THIS.idRefAttribute+"='"+m.tcIDRef+"'"
   ENDIF
   IF NOT EMPTY(m.tvFormatting)
      m.lcNode = m.lcNode + " " + m.tvFormatting
   ENDIF
   IF ISNULL(m.tlOpen)
      m.lcNode = m.lcNode +  "/"
   ENDIF
   m.lcNode = m.lcNode + ">"
ELSE
   m.lcNode = "</"+ m.tcNode + ">"   
ENDIF

RETURN m.lcNode
ENDPROC
PROCEDURE xsltparameters_assign
LPARAMETERS m.vNewVal
DO CASE
CASE VARTYPE(m.vNewVal) = "X"
  THIS.XSLTParameters= NULL
CASE VARTYPE(m.vNewVal) = "O" 
   TRY
     IF UPPER(m.vNewVal.BaseClass) == "COLLECTION" 
       THIS.XSLTParameters = m.vNewVal
     ENDIF
   CATCH 
   ENDTRY
OTHERWISE
  THIS.XSLTParameters= NULL
ENDCASE






ENDPROC
PROCEDURE xsltprocessorrdl_assign
LPARAMETERS m.vNewVal
DO CASE
CASE VARTYPE(m.vNewVal) = "X"
   THIS.XSLTProcessorRDL = NULL
CASE VARTYPE(m.vNewVal) = "O" 
   TRY
     IF VARTYPE(m.vNewVal.stylesheet) = "O"
       THIS.XSLTProcessorRDL = m.vNewVal
     ENDIF
   CATCH 
   ENDTRY
CASE VARTYPE(m.vNewVal) = "C" 
   LOCAL m.loProcessor
   m.loProcessor = THIS.LoadProcessorObject(m.vNewVal)
   IF NOT ISNULL(m.loProcessor)
      THIS.XSLTProcessorRDL = m.loProcessor
   ENDIF
ENDCASE



ENDPROC
PROCEDURE xsltprocessoruser_assign
LPARAMETERS m.vNewVal
DO CASE
CASE VARTYPE(m.vNewVal) = "X"
   THIS.XSLTProcessorUser = NULL
CASE VARTYPE(m.vNewVal) = "O" 
   TRY
     IF VARTYPE(m.vNewVal.stylesheet) = "O"
       THIS.XSLTProcessorUser = m.vNewVal
     ENDIF
   CATCH 
   ENDTRY
CASE VARTYPE(m.vNewVal) = "C" 
   LOCAL m.loProcessor
   m.loProcessor = THIS.LoadProcessorObject(m.vNewVal)
   IF NOT ISNULL(m.loProcessor)
      THIS.XSLTProcessorUser = m.loProcessor
   ENDIF
ENDCASE



ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*addrunnode Adds a node to the Run portion of the XML document, looking for value results in both FRX and Report Run (Current) Data sessions.
*adjustxsltparameter Adds, changes, or removes a parameter in the XSLT Parameter Collection, creating the collection if necessary. Params: tvValue, tsKey, tlRemoveOnly.
*applyrdltransform_access 
*applyusertransform_assign 
*applyusertransformtooutput Applies a user-specified XSLT to XML output at the conclusion of a report run.
*applyxslt Provides generic facilities for applying XSLT to XML.
*contattr_assign 
*currentdocument_assign 
*datatextattr_assign 
*datatypeattr_assign 
*evaluatestringtoboolean Casts a string to .T. or .F..
*fixmsxmlobjectfordtds Adjust MSXML document objects to load XML with embedded DTDs properly.
*formatdatavalue Provides opportunity to re-format data value delivered in EvaluateContents appropriately for text/TRANSFORM'd version.
*frxcharsetsinuse Determine whether the FRX for a report run has layout elements with explicit charset instructions.
*getdefaultuserxslt Provides a hook for subclasses to supply their preferred XSLT document for use when XMLListener automatically applies XSLT at the end of a report run.
*getfrxlayoutobjectfieldlist Provides fields list to the getVFPRdlContents method, in a suitable comma-delimited format for inclusion as a macro in SQL SELECT statement from FRX cursor and related Bands and Objects cursors.
*getpathedimageinfo Supplies a fully-pathed filename for an image file included in the report, using the original relative-path information stored in the FRX.
*getrawformattinginfo Formulates the appropriate formatting attributes for an element when XMLListener is streaming XML to a file.
*getrunnodecontents Translates information dynamically generated and provided in the runCollector member into an XML format useful to other applications.
*getvfprdlcontents Translates report definition layout metadata, from the FRX and the current report run, into an XML format useful to other applications.
*heightattr_assign 
*idattribute_assign 
*idrefattribute_assign 
*includebandswithnoobjects_assign 
*includebreaksindata_assign 
*includedatasourcesinvfprdl_assign 
*includedatatypeattributes_assign 
*includeformattinginlayoutobjects_assign 
*initializeformattingchangescursor Evaluates requirements for a cursor to hold information gathered for Field layout controls during this report run and creates it if necessary.
*insertxmlconfigrecords Adds a record to the configuration table describing a default XML node when XML Listener is creating or editing a shared configuration table.
*leftattr_assign 
*loadprocessorobject Provides a generic means to load an XSLT processor object from a string representing an XSLT document or a filename.
*nopageeject_assign 
*pageimageattr_assign 
*preparefrxcopy Prepares FRX alias or copy for use in creating VFP-RDL contents.
*removefrxcopy Removes FRX copy used in preparing VFP-RDL.
*resetdocument Resets the XML document after a report run.
*resetreport Resets information for a report-level node during the production of an XML document that may span multiple reports.
*setdomformattinginfo Formulates the appropriate formatting attributes for an element when XMLListener is using the DOM to create XML.
*synchxsltprocessoruser Can be called in the assign of any Attribute-setting property to synchronize the XSLT associated with the class witht he new attribute values.
*topattr_assign 
*verifyattributenames Hook method called during XML Listener's augmented version of VerifyConfigTable, allowing subclasses to verify attribute names should they decide to store them in the configuration table similar to node names.
*verifyncname Generic method to validate strings as XML-standard NCNames.
*verifynodenames Method called during XML Listener's augmented version of VerifyConfigTable to check all node values in the configuration table for XML validity.
*widthattr_assign 
*writeraw Used to write raw XML data to a file.
*xmlmode_assign 
*xmlrawconv Used to convert any control characters to entity references when XML Listener is writing raw XML data to a file.
*xmlrawnode Used to formulate the contents of an XML element  node when XML Listener is writing the XML document as raw data to a file.
*xmlrawtag Used to formulate the contents of an XML tag when XML Listener is writing the XML document as raw data to a file.
*xsltparameters_assign 
*xsltprocessorrdl_assign 
*xsltprocessoruser_assign 
applyrdltransform Indicates whether an RDL-Only transformation is available and should be applied to XML output after an RDL-Only report run.
applyusertransform Indicates whether XMLListener should automatically apply an XSLT transform at the conclusion of a report run.
columnnodes Holds column-level output during a report run.
contattr Supplies the name of the attribute used to show continuation type for a layout object that can span bands or pages.
currentband Holds information about the band for which output is currently being generated during a report run.
currentcolumn Holds information about the column for which output is currently being generated during a report run.
currentdocument Holds information about the XML document for which output is currently being generated during a report run.
currentpage Holds information about the page for which output is currently being generated during a report run.
datanodes Holds non-formatting output (title, detail, group, and summary band objects) during a report run.
datatextattr Supplies the name of the XML attribute used to show the TRANSFORM'd value of the evaluated expression for a field control layout object.
datatypeattr Supplies the name of the XML attribute used to show the datatype of the evaluated expression for a field control layout object.
evaluatecontentsvalues An EMPTY object reference to hold changed formatting values during Rendering.
formattingchanges Reference in which classes can store information about actions taken to apply dynamic changes to layout controls' formatting attributes, for later use during Render event.
heightattr Supplies the name of the XML attribute used to show height for a layout object.
idattribute Supplies the name of the XML attribute used to provide the FRX record number for a layout object or page number of a formatting band (column or page) object.
idrefattribute Supplies the name of the XML attribute used to provide the current page for a layout object or FRX record number of a formatting band (column or page) object.
includebandswithnoobjects Indicates whether band-level information for bands with no contents should be included in the XML.
includebreaksindata 0 = provide page band nodes positioned along with other bands in the datastream, wherever they happen to occur, 1 = no pagebreak info, no page header and footer info, 2 = collection of pages with page headers and footers data
includedatasourcesinvfprdl Indicates whether information about the source tables, relations, indexes, etc should be included in the VFPRDL metadata section of the report XML.
includedatatypeattributes Indicates whether Data Type and Text information available in EvaluateContents should be included in the XML nodes generated for Field controls.
includeformattinginlayoutobjects Indicates whether formatting information such as positioning attributes should be included in the report XML.
includepage Evaluates whether the current page is part of the output page set and should be included in the XML document result.
leftattr Supplies the name of the XML attribute used to show leftmost position for a layout object.
nopageeject Indicates whether the XML Listener should consider the current report run to be continued.  Can be used without NOPAGEEJECT on the REPORT FORM command.
pageimageattr Supplies the name of the XML attribute used to show the filename for an associated generated page image file.
pagenodes Holds page-level output during a report run.
successorgfxnorender Private gfxNoRender object instance used for rendering checks specific to this output target when this reportListener is a Successor.
topattr Supplies the name of the XML attribute used to show topmost position for a layout object.
widthattr Supplies the name of the XML attribute used to show width for a layout object.
xmlmode 0 = data only, 1 = RDL only, 2 = data and RDL
xsltparameters Holds an optional parameter collection passed to the ApplyXSLT method when XMLListener automatically  applies a user XSLT transformation at the conclusion of a report run.
xsltprocessorrdl Holds an RDL-specific processor object, reserved for future use.
xsltprocessoruser Holds a user-definable processor object which, if filled and available at the end of a run, can be used automatically by XML Listener to transform the raw XML document to requirements.
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED7]
Provides XML output from a report run.[END RESERVED7]
[START RESERVED8]
reportlisteners.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] xmllistener
[EOF]
