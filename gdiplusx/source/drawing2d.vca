SCCTEXT Version 4.0.0.2
PLATFORM C(8,0),UNIQUEID C(10,0),TIMESTAMP N(10,0),CLASS M(4,0),CLASSLOC M(4,0),BASECLASS M(4,0),OBJNAME M(4,0),PARENT M(4,0),PROPERTIES M(4,0),PROTECTED M(4,0),METHODS M(4,0),OBJCODE M(4,0),OLE M(4,0),OLE2 M(4,0),RESERVED1 M(4,0),RESERVED2 M(4,0),RESERVED3 M(4,0),RESERVED4 M(4,0),RESERVED5 M(4,0),RESERVED6 M(4,0),RESERVED7 M(4,0),RESERVED8 M(4,0),USER M(4,0)
1252

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] Class     
[START RESERVED1]
VERSION =   3.00[END RESERVED1]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1QZ0NR7Z6
[CLASS] xfcobject
[CLASSLOC] system.vcx
[BASECLASS] custom
[OBJNAME] xfcdrawing2dbase
[START PROPERTIES]
Name = "xfcdrawing2dbase"
[END PROPERTIES]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED8]
drawing.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] xfcdrawing2dbase

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1QZ0NRQF8
[CLASS] xfcdrawingbase
[CLASSLOC] drawing.vcx
[BASECLASS] custom
[OBJNAME] xfcblend
[START PROPERTIES]
basename = Blend
_factors = 
_positions = 
_memberdata =      533<VFPData><memberdata name="equals" type="method" display="Equals"/><memberdata name="gethashcode" type="method" display="GetHashCode"/><memberdata name="gettype" type="method" display="GetType"/><memberdata name="tostring" type="method" display="ToString"/><memberdata name="finalize" type="method" display="Finalize"/><memberdata name="memberwiseclone" type="method" display="MemberwiseClone"/><memberdata name="factors" type="property" display="Factors"/><memberdata name="positions" type="property" display="Positions"/></VFPData>
Name = "xfcblend"
[END PROPERTIES]
[START PROTECTED]
_factors
_positions
_memberdata
[END PROTECTED]
[START METHODS]
PROCEDURE Init
*********************************************************************
** Method: Blend
**
** Initializes a new instance of the Blend class.
**
** History:
**  2006/03/07: Auto Generated
**	2006/06/09: BDurban - Partial 1999
*********************************************************************
LPARAMETERS tiCount, ;
			tqFactors, tqPositions

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	DODEFAULT()
	
	m.tiCount = EVL(m.tiCount,1)
	
	DIMENSION This.Factors[m.tiCount]
	DIMENSION This.Positions[m.tiCount]
	This.Factors = 0.0
	This.Positions = 0.0

	IF VARTYPE(m.tqFactors) = "Q"
		This._Factors = m.tqFactors
	ELSE
		This._Factors = REPLICATE(EMPTY_FLOAT, m.tiCount)
	ENDIF
	
	IF VARTYPE(m.tqPositions) = "Q"
		This._Positions = m.tqPositions
	ELSE
		This._Positions = REPLICATE(EMPTY_FLOAT, m.tiCount)
	ENDIF
	
CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN

** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.Blend.Blend%28vs.80%29.aspx
** Parameters:
**  [None]
**  int count
*********************************************************************

ENDPROC
PROCEDURE factors_access
*********************************************************************
** Property: Factors (Access)
**
** Gets or sets an array of blend factors for the gradient.
**
** History:
**  2006/03/07: Auto Generated
**	2006/06/11: BDurban - Coded
*********************************************************************
LPARAMETERS tiIndex

*!ToDo: Test this function

LOCAL leValue
m.leValue = 0.0

LOCAL loExc AS Exception
TRY
	m.tiIndex = NVL(m.tiIndex,1)
	
	DO CASE
	CASE VARTYPE(m.tiIndex) = "N"
		m.leValue = CTOBIN(SUBSTR(This._factors, (m.tiIndex-1)*4+1, 4), "N")
	** Special case, return the binary structure if we receive a VarBinary parameter
	CASE VARTYPE(m.tiIndex) = "Q"
		m.leValue = This._factors
	ENDCASE
	** This.SetStatus(GdipSomeFunction???())

CATCH TO loExc
	THROW m.loExc
ENDTRY
RETURN m.leValue

** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.Blend.Factors%28vs.80%29.aspx
** Returns: float[]
*********************************************************************

ENDPROC
PROCEDURE factors_assign
*********************************************************************
** Property: Factors (Assign)
**
** Gets or sets an array of blend factors for the gradient.
**
** History:
**  2006/03/07: Auto Generated
**	2006/06/11: BDurban - Coded
*********************************************************************
LPARAMETERS tnValue, tiIndex

*!ToDo: Test this function

LOCAL lqFactor

LOCAL loExc AS Exception
TRY
	DO CASE
	CASE VARTYPE(m.tnValue) = "Q"
		*!ToDo: Check the length of this binary string
		This._factors = m.tnValue
	OTHERWISE
		m.lqFactor = BINTOC(m.tnValue,"F")
		IF VARTYPE(m.tiIndex)="N" AND BETWEEN(m.tiIndex, 1, ALEN(This.Factors,1))
			This._factors = STUFF(This._factors, (m.tiIndex-1)*4+1, 4, m.lqFactor)
		ELSE
			This._factors = REPLICATE(m.lqFactor, ALEN(This.Factors,1))
		ENDIF
	ENDCASE
CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL
ENDPROC
PROCEDURE new
LPARAMETERS tiCount, ;
			tqFactors, tqPositions

RETURN This.CreateNew(This.Class, m.tiCount, m.tqFactors, m.tqPositions)
ENDPROC
PROCEDURE positions_access
*********************************************************************
** Property: Positions (Access)
**
** Gets or sets an array of blend positions for the gradient.
**
** History:
**  2006/03/07: Auto Generated
**	2006/06/11: BDurban - Coded
*********************************************************************
LPARAMETERS tiIndex

*!ToDo: Test this function

LOCAL leValue
m.leValue = 0.0

LOCAL loExc AS Exception
TRY
	m.tiIndex = NVL(m.tiIndex,1)
	
	DO CASE
	CASE VARTYPE(m.tiIndex) = "N"
		m.leValue = CTOBIN(SUBSTR(This._positions, (m.tiIndex-1)*4+1, 4), "N")
	** Special case, return the binary structure if we receive a VarBinary parameter
	CASE VARTYPE(m.tiIndex) = "Q"
		m.leValue = This._positions
	ENDCASE
	** This.SetStatus(GdipSomeFunction???())

CATCH TO loExc
	THROW m.loExc
ENDTRY
RETURN m.leValue

** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.Blend.Positions%28vs.80%29.aspx
** Returns: float[]
*********************************************************************

ENDPROC
PROCEDURE positions_assign
*********************************************************************
** Property: Positions (Assign)
**
** Gets or sets an array of blend positions for the gradient.
**
** History:
**  2006/03/07: Auto Generated
**	2006/06/11: BDurban - Coded
*********************************************************************
LPARAMETERS tnValue, tiIndex

*!ToDo: Test this function

LOCAL lqPosition

LOCAL loExc AS Exception
TRY
	DO CASE
	CASE VARTYPE(m.tnValue) = "Q"
		*!ToDo: Check the length of this binary string
		This._positions = m.tnValue
	OTHERWISE
		m.lqPosition = BINTOC(m.tnValue,"F")
		IF VARTYPE(m.tiIndex)="N" AND BETWEEN(m.tiIndex, 1, ALEN(This.Positions,1))
			This._positions = STUFF(This._positions, (m.tiIndex-1)*4+1, 4, m.lqPosition)
			This.Positions[m.tiIndex] = m.tnValue
		ELSE
			This._positions = REPLICATE(m.lqPosition, ALEN(This.Positions,1))
			This.Positions = m.tnValue
		ENDIF
	ENDCASE
CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
basename
_factors
_positions
^factors[1,0] Gets or sets an array of blend factors for the gradient.
^positions[1,0] Gets or sets an array of blend positions for the gradient.
*factors_access 
*factors_assign 
*positions_access 
*positions_assign 
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED8]
drawing.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] xfcblend
[START RESERVED1]
 	 drawing.hﬁ„„M5 system.hÊ‰0•Ô4 gdiplusconstants.hÓÂÎi05[END RESERVED1]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1QZ0NRQM6
[CLASS] xfcdrawingbase
[CLASSLOC] drawing.vcx
[BASECLASS] custom
[OBJNAME] xfccolorblend
[START PROPERTIES]
basename = ColorBlend
_colors = (0h)
_positions = (0h)
_memberdata =      531<VFPData><memberdata name="equals" type="method" display="Equals"/><memberdata name="gethashcode" type="method" display="GetHashCode"/><memberdata name="gettype" type="method" display="GetType"/><memberdata name="tostring" type="method" display="ToString"/><memberdata name="finalize" type="method" display="Finalize"/><memberdata name="memberwiseclone" type="method" display="MemberwiseClone"/><memberdata name="colors" type="property" display="Colors"/><memberdata name="positions" type="property" display="Positions"/></VFPData>
Name = "xfccolorblend"
[END PROPERTIES]
[START PROTECTED]
_colors
_positions
_memberdata
[END PROTECTED]
[START METHODS]
PROCEDURE Init
*********************************************************************
** Method: ColorBlend
**
** Initializes a new instance of the ColorBlend class.
**
** History:
**  2006/03/07: Auto Generated
**	2006/06/13: BDurban - Partial 1999
*********************************************************************
LPARAMETERS tiCount, ;
			tqColors, tqPositions

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	DODEFAULT()
	
	m.tiCount = EVL(m.tiCount,1)
	
	DIMENSION This.Colors[m.tiCount]
	DIMENSION This.Positions[m.tiCount]
	This.Colors = This.CreateNew("xfcColor", ARGB_Transparent)
	This.Positions = 0.0

	IF VARTYPE(m.tqColors) = "Q"
		This._Colors = m.tqColors
	ELSE
		This._Colors = REPLICATE(EMPTY_LONG, m.tiCount)
	ENDIF
	
	IF VARTYPE(m.tqPositions) = "Q"
		This._Positions = m.tqPositions
	ELSE
		This._Positions = REPLICATE(EMPTY_FLOAT, m.tiCount)
	ENDIF
	
CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN

** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.ColorBlend.ColorBlend%28vs.80%29.aspx
** Parameters:
**  [None]
**  int count
*********************************************************************

ENDPROC
PROCEDURE colors_access
*********************************************************************
** Property: Colors (Access)
**
** Gets or sets an array of colors that represents the colors to use at corresponding
** positions along a gradient.
**
** History:
**  2006/03/07: Auto Generated
**	2006/06/11: BDurban - Coded
*********************************************************************
LPARAMETERS tiIndex

*!ToDo: Test this function

LOCAL leValue
m.leValue = 0.0

LOCAL loExc AS Exception
TRY
	m.tiIndex = NVL(m.tiIndex,1)
	
	DO CASE
	CASE VARTYPE(m.tiIndex) = "N"
		m.leValue = CTOBIN(SUBSTR(This._colors, (m.tiIndex-1)*4+1, 4), "4rs")
		m.leValue = This.CreateNew("xfcColor", m.leValue)
	** Special case, return the binary structure if we receive a VarBinary parameter
	CASE VARTYPE(m.tiIndex) = "Q"
		m.leValue = This._colors
	ENDCASE
	** This.SetStatus(GdipSomeFunction???())

CATCH TO loExc
	THROW m.loExc
ENDTRY
RETURN m.leValue

** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.ColorBlend.Colors%28vs.80%29.aspx
** Returns: Color[]
*********************************************************************

ENDPROC
PROCEDURE colors_assign
*********************************************************************
** Property: Colors (Assign)
**
** Gets or sets an array of colors that represents the colors to use at corresponding
** positions along a gradient.
**
** History:
**  2006/03/07: Auto Generated
**	2006/06/11: BDurban - Coded
*********************************************************************
LPARAMETERS toColor AS xfcColor, tiIndex

*!ToDo: Test this function

LOCAL lqColor

LOCAL loExc AS Exception
TRY
	DO CASE
	CASE VARTYPE(m.toColor) = "Q"
		*!ToDo: Check the length of this binary string
		This._colors = m.toColor
	OTHERWISE
		m.lqColor = BINTOC(m.toColor.ToArgb(),"4rs")
		IF VARTYPE(m.tiIndex)="N" AND BETWEEN(m.tiIndex, 1, ALEN(This.Colors,1))
			This._colors = STUFF(This._colors, (m.tiIndex-1)*4+1, 4, m.lqColor)
		ELSE
			This._colors = REPLICATE(m.lqColor, ALEN(This.Colors,1))
		ENDIF
	ENDCASE
CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL
ENDPROC
PROCEDURE new
LPARAMETERS tiCount, ;
			tqColors, tqPositions

RETURN This.CreateNew(This.Class, m.tiCount, m.tqColors, m.tqPositions)
ENDPROC
PROCEDURE positions_access
*********************************************************************
** Property: Positions (Access)
**
** Gets or sets the positions along a gradient line.
**
** History:
**  2006/03/07: Auto Generated
**	2006/06/11: BDurban - Coded
*********************************************************************
LPARAMETERS tiIndex

*!ToDo: Test this function

LOCAL leValue
m.leValue = 0.0

LOCAL loExc AS Exception
TRY
	m.tiIndex = NVL(m.tiIndex,1)
	
	DO CASE
	CASE VARTYPE(m.tiIndex) = "N"
		m.leValue = CTOBIN(SUBSTR(This._positions, (m.tiIndex-1)*4+1, 4), "N")
	** Special case, return the binary structure if we receive a VarBinary parameter
	CASE VARTYPE(m.tiIndex) = "Q"
		m.leValue = This._positions
	ENDCASE
	** This.SetStatus(GdipSomeFunction???())

CATCH TO loExc
	THROW m.loExc
ENDTRY
RETURN m.leValue

** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.ColorBlend.Positions%28vs.80%29.aspx
** Returns: float[]
*********************************************************************

ENDPROC
PROCEDURE positions_assign
*********************************************************************
** Property: Positions (Assign)
**
** Gets or sets the positions along a gradient line.
**
** History:
**  2006/03/07: Auto Generated
**	2006/06/11: BDurban - Coded
*********************************************************************
LPARAMETERS tnValue, tiIndex

*!ToDo: Test this function

LOCAL lqPosition

LOCAL loExc AS Exception
TRY
	DO CASE
	CASE VARTYPE(m.tnValue) = "Q"
		*!ToDo: Check the length of this binary string
		This._positions = m.tnValue
	OTHERWISE
		m.lqPosition = BINTOC(m.tnValue,"F")
		IF VARTYPE(m.tiIndex)="N" AND BETWEEN(m.tiIndex, 1, ALEN(This.Positions,1))
			This._positions = STUFF(This._positions, (m.tiIndex-1)*4+1, 4, m.lqPosition)
			This.Positions[m.tiIndex] = m.tnValue
		ELSE
			This._positions = REPLICATE(m.lqPosition, ALEN(This.Positions,1))
			This.Positions = m.tnValue
		ENDIF
	ENDCASE
CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
basename
_colors
_positions
^colors[1,0] Gets or sets an array of colors that represents the colors to use at corresponding positions along a gradient.
^positions[1,0] Gets or sets the positions along a gradient line.
*colors_access 
*colors_assign 
*positions_access 
*positions_assign 
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED8]
drawing.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] xfccolorblend
[START RESERVED1]
 	 drawing.hﬁ„„M5 system.hÊ‰0•Ô4 gdiplusconstants.hÓÂÎi05[END RESERVED1]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1QZ0NRQXH
[CLASS] xfcgpobject
[CLASSLOC] drawing.vcx
[BASECLASS] custom
[OBJNAME] xfccustomlinecap
[START PROPERTIES]
basecap = 0
baseinset = 0
strokejoin = 0
widthscale = 0
_memberdata =     1231<VFPData><memberdata name="clone" type="method" display="Clone"/><memberdata name="createobjref" type="method" display="CreateObjRef"/><memberdata name="dispose" type="method" display="Dispose"/><memberdata name="equals" type="method" display="Equals"/><memberdata name="gethashcode" type="method" display="GetHashCode"/><memberdata name="getlifetimeservice" type="method" display="GetLifetimeService"/><memberdata name="getstrokecaps" type="method" display="GetStrokeCaps"/><memberdata name="gettype" type="method" display="GetType"/><memberdata name="initializelifetimeservice" type="method" display="InitializeLifetimeService"/><memberdata name="setstrokecaps" type="method" display="SetStrokeCaps"/><memberdata name="tostring" type="method" display="ToString"/><memberdata name="finalize" type="method" display="Finalize"/><memberdata name="memberwiseclone" type="method" display="MemberwiseClone"/><memberdata name="basecap" type="property" display="BaseCap"/><memberdata name="baseinset" type="property" display="BaseInset"/><memberdata name="strokejoin" type="property" display="StrokeJoin"/><memberdata name="widthscale" type="property" display="WidthScale"/><memberdata name="new" type="method" display="New"/></VFPData>

basename = CustomLineCap
lastresult = 0
Name = "xfccustomlinecap"
[END PROPERTIES]
[START PROTECTED]
_memberdata
[END PROTECTED]
[START METHODS]
PROCEDURE Destroy
*********************************************************************
** Method: Destroy
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/06: BDurban - Coded
*********************************************************************

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
This.SetStatus(GdipDeleteCustomLineCap(This.Handle))
CATCH TO loExc
	THROW m.loExc
ENDTRY
RETURN
ENDPROC
PROCEDURE Init
*********************************************************************
** Method: CustomLineCap
**
** Initializes a new instance of the CustomLineCap class with the specified outline
** and fill.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/06: BDurban - Coded
*********************************************************************
LPARAMETERS toFillPath AS xfcGraphicsPath, toStrokePath AS xfcGraphicsPath, ;
			tiBaseCap AS EnumLineCap, ;
			tnBaseInset

*!ToDo: Test this function

IF PCOUNT() = 0
	** Bypass for static object
	RETURN
ENDIF
	
LOCAL loExc AS Exception
TRY
	LOCAL lhCustomCap, lhFillPath, lhStrokePath
	DODEFAULT()
	STORE 0 TO m.lhCustomCap, m.lhFillPath, m.lhStrokePath
	
	IF VARTYPE(m.toFillPath)="O" AND m.toFillPath.BaseName=="GraphicsPath"
		m.lhFillPath = m.toFillPath.Handle
	ENDIF
	
	IF VARTYPE(m.toStrokePath)="O" AND m.toStrokePath.BaseName=="GraphicsPath"
		m.lhStrokePath = m.toStrokePath.Handle
	ENDIF
	
	m.tiBaseCap = EVL(m.tiBaseCap, LineCapFlat)
	m.tnBaseInset = EVL(m.tnBaseInset, 0.00)
	
	This.SetStatus(GdipCreateCustomLineCap(m.lhFillPath, m.lhStrokePath, m.tiBaseCap, m.tnBaseInset, @lhCustomCap))
	This.Handle = m.lhCustomCap
	
CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN

** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.CustomLineCap.CustomLineCap%28vs.80%29.aspx
** Parameters:
**  GraphicsPath fillPath, GraphicsPath strokePath
**  GraphicsPath fillPath, GraphicsPath strokePath, LineCap baseCap
**  GraphicsPath fillPath, GraphicsPath strokePath, LineCap baseCap, float baseInset
*********************************************************************

ENDPROC
PROCEDURE basecap_access
*********************************************************************
** Property: BaseCap (Access)
**
** Gets or sets the LineCap enumeration on which this CustomLineCap is based.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/06: BDurban - Coded
*********************************************************************

*!ToDo: Test this function

LOCAL liLineCap
m.liLineCap = 0

LOCAL loExc AS Exception
TRY
	This.SetStatus(GdipGetCustomLineCapBaseCap(This.Handle, @liLineCap))

CATCH TO loExc
	THROW m.loExc
ENDTRY
RETURN m.liLineCap

** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.CustomLineCap.BaseCap%28vs.80%29.aspx
** Returns: LineCap
*********************************************************************

ENDPROC
PROCEDURE basecap_assign
*********************************************************************
** Property: BaseCap (Assign)
**
** Gets or sets the LineCap enumeration on which this CustomLineCap is based.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/06: BDurban - Coded
*********************************************************************
LPARAMETERS tiLineCap

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	This.SetStatus(GdipSetCustomLineCapBaseCap(This.Handle, m.tiLineCap))
CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL
ENDPROC
PROCEDURE baseinset_access
*********************************************************************
** Property: BaseInset (Access)
**
** Gets or sets the distance between the cap and the line.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/06: BDurban - Coded
*********************************************************************

*!ToDo: Test this function

LOCAL lnInset
m.lnInset = 0.0

LOCAL loExc AS Exception
TRY
	This.SetStatus(GdipGetCustomLineCapBaseInset(This.Handle, @lnInset))

CATCH TO loExc
	THROW m.loExc
ENDTRY
RETURN m.lnInset

** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.CustomLineCap.BaseInset%28vs.80%29.aspx
** Returns: float
*********************************************************************

ENDPROC
PROCEDURE baseinset_assign
*********************************************************************
** Property: BaseInset (Assign)
**
** Gets or sets the distance between the cap and the line.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/06: BDurban - Coded
*********************************************************************
LPARAMETERS tnInset

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	This.SetStatus(GdipSetCustomLineCapBaseInset(This.Handle, m.tnInset))
CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL
ENDPROC
PROCEDURE clone
*********************************************************************
** Method: Clone
**
** Creates an exact copy of this CustomLineCap.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/06: BDurban - Coded
*********************************************************************

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	LOCAL loClonedCap, lhClonedCap
	m.lhClonedCap = 0
	m.loClonedCap = NULL
	This.SetStatus(GdipCloneCustomLineCap(This.Handle, @lhClonedCap))
	IF(m.lhobject <> 0)
		m.loClonedCap = This.CreateNew(This.Class)
		m.loClonedCap.Handle = m.lhClonedCap
	ENDIF
CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN m.loobject


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.CustomLineCap.Clone%28vs.80%29.aspx
** Parameters:
**  [None]
** Returns: object
*********************************************************************

ENDPROC
PROCEDURE declaredll

TRY

xfcCustomLineCapDeclareDLL(0)

CATCH

DECLARE Long Sleep IN WIN32API AS xfcCustomLineCapDeclareDLL Long

DECLARE LONG GdipCreateCustomLineCap IN GDIPLUS LONG PathtoFill, LONG PathStroke, LONG baseCap, SINGLE baseInset, LONG @customCap
DECLARE LONG GdipDeleteCustomLineCap IN GDIPLUS LONG customCap
DECLARE LONG GdipCloneCustomLineCap IN GDIPLUS LONG customCap, LONG @clonedCap
DECLARE LONG GdipSetCustomLineCapStrokeCaps IN GDIPLUS LONG customCap, LONG startCap, LONG endCap
DECLARE LONG GdipGetCustomLineCapStrokeCaps IN GDIPLUS LONG customCap, LONG @startCap, LONG @endCap
DECLARE LONG GdipSetCustomLineCapStrokeJoin IN GDIPLUS LONG customCap, LONG LnJoin
DECLARE LONG GdipGetCustomLineCapStrokeJoin IN GDIPLUS LONG customCap, LONG @LnJoin
DECLARE LONG GdipSetCustomLineCapBaseCap IN GDIPLUS LONG customCap, LONG baseCap
DECLARE LONG GdipGetCustomLineCapBaseCap IN GDIPLUS LONG customCap, LONG @baseCap
DECLARE LONG GdipSetCustomLineCapBaseInset IN GDIPLUS LONG customCap, SINGLE inset
DECLARE LONG GdipGetCustomLineCapBaseInset IN GDIPLUS LONG customCap, SINGLE @inset
DECLARE LONG GdipSetCustomLineCapWidthScale IN GDIPLUS LONG customCap, SINGLE widthScale
DECLARE LONG GdipGetCustomLineCapWidthScale IN GDIPLUS LONG customCap, SINGLE @widthScale

ENDTRY
ENDPROC
PROCEDURE getstrokecaps
*********************************************************************
** Method: GetStrokeCaps
**
** Gets the caps used to start and end lines that make up this custom cap.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/06: BDurban - Coded
*********************************************************************
LPARAMETERS tiStartCap AS EnumLineCap, tiEndCap AS EnumLineCap

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY

	This.SetStatus(GdipGetCustomLineCapStrokeCaps(This.Handle, @tiStartCap, @tiEndCap))

CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.CustomLineCap.GetStrokeCaps%28vs.80%29.aspx
** Parameters:
**  out LineCap startCap, out LineCap endCap
** Returns: void
*********************************************************************

ENDPROC
PROCEDURE new
LPARAMETERS toFillPath AS xfcGraphicsPath, toStrokePath AS xfcGraphicsPath, ;
			tiBaseCap AS EnumLineCap, ;
			tnBaseInset
			
RETURN This.CreateNew(This.Class, m.toFillPath, m.toStrokePath, m.tiBaseCap, m.tnBaseInset)
ENDPROC
PROCEDURE setstrokecaps
*********************************************************************
** Method: SetStrokeCaps
**
** Sets the caps used to start and end lines that make up this custom cap.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/06: BDurban - Coded
*********************************************************************
LPARAMETERS tiStartCap AS EnumLineCap, tiEndCap AS EnumLineCap

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY

	This.SetStatus(GdipSetCustomLineCapStrokeCaps(This.Handle, m.tiStartCap, m.tiEndCap))

CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.CustomLineCap.SetStrokeCaps%28vs.80%29.aspx
** Parameters:
**  LineCap startCap, LineCap endCap
** Returns: void
*********************************************************************

ENDPROC
PROCEDURE strokejoin_access
*********************************************************************
** Property: StrokeJoin (Access)
**
** Gets or sets the LineJoin enumeration that determines how lines that compose this
** CustomLineCap object are joined.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/06: BDurban - Coded
*********************************************************************

*!ToDo: Test this function

LOCAL liLineJoin
m.liLineJoin = 0

LOCAL loExc AS Exception
TRY
	This.SetStatus(GdipGetCustomLineCapStrokeJoin(This.Handle, @liLineJoin))

CATCH TO loExc
	THROW m.loExc
ENDTRY
RETURN m.liLineJoin

** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.CustomLineCap.StrokeJoin%28vs.80%29.aspx
** Returns: LineJoin
*********************************************************************

ENDPROC
PROCEDURE strokejoin_assign
*********************************************************************
** Property: StrokeJoin (Assign)
**
** Gets or sets the LineJoin enumeration that determines how lines that compose this
** CustomLineCap object are joined.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/06: BDurban - Coded
*********************************************************************
LPARAMETERS tiLineJoin

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	This.SetStatus(GdipSetCustomLineCapStrokeJoin(This.Handle, m.tiLineJoin))
CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL
ENDPROC
PROCEDURE widthscale_access
*********************************************************************
** Property: WidthScale (Access)
**
** Gets or sets the amount by which to scale this CustomLineCap Class object with respect
** to the width of the Pen object.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/06: BDurban - Coded
*********************************************************************

*!ToDo: Test this function

LOCAL lnWidthScale
m.lnWidthScale = 0.0

LOCAL loExc AS Exception
TRY
	This.SetStatus(GdipGetCustomLineCapWidthScale(This.Handle, @lnWidthScale))

CATCH TO loExc
	THROW m.loExc
ENDTRY
RETURN m.lnWidthScale

** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.CustomLineCap.WidthScale%28vs.80%29.aspx
** Returns: float
*********************************************************************

ENDPROC
PROCEDURE widthscale_assign
*********************************************************************
** Property: WidthScale (Assign)
**
** Gets or sets the amount by which to scale this CustomLineCap Class object with respect
** to the width of the Pen object.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/06: BDurban - Coded
*********************************************************************
LPARAMETERS tnWidthScale

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	This.SetStatus(GdipSetCustomLineCapWidthScale(This.Handle, m.tnWidthScale))
CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL
ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
basecap Gets or sets the LineCap enumeration on which this CustomLineCap is based.
baseinset Gets or sets the distance between the cap and the line.
strokejoin Gets or sets the LineJoin enumeration that determines how lines that compose this CustomLineCap object are joined.
widthscale Gets or sets the amount by which to scale this CustomLineCap Class object with respect to the width of the Pen object.
*clone Creates an exact copy of this CustomLineCap.
*getstrokecaps Gets the caps used to start and end lines that make up this custom cap.
*setstrokecaps Sets the caps used to start and end lines that make up this custom cap.
*basecap_access 
*basecap_assign 
*baseinset_access 
*baseinset_assign 
*strokejoin_access 
*strokejoin_assign 
*widthscale_access 
*widthscale_assign 
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED8]
drawing.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] xfccustomlinecap
[START RESERVED1]
 	 drawing.hﬁ„„M5 system.hÊ‰0•Ô4 gdiplusconstants.hÓÂÎi05[END RESERVED1]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1QZ0NRR8B
[CLASS] xfcdrawingbase
[CLASSLOC] drawing.vcx
[BASECLASS] custom
[OBJNAME] xfcgraphicscontainer
[START PROPERTIES]
basename = GraphicsContainer
handle = 0
_memberdata =      653<VFPData><memberdata name="createobjref" type="method" display="CreateObjRef"/><memberdata name="equals" type="method" display="Equals"/><memberdata name="gethashcode" type="method" display="GetHashCode"/><memberdata name="getlifetimeservice" type="method" display="GetLifetimeService"/><memberdata name="gettype" type="method" display="GetType"/><memberdata name="initializelifetimeservice" type="method" display="InitializeLifetimeService"/><memberdata name="tostring" type="method" display="ToString"/><memberdata name="finalize" type="method" display="Finalize"/><memberdata name="memberwiseclone" type="method" display="MemberwiseClone"/></VFPData>
Name = "xfcgraphicscontainer"
[END PROPERTIES]
[START PROTECTED]
_memberdata
[END PROTECTED]
[START METHODS]
PROCEDURE Destroy
*********************************************************************
** Method: Destroy
**
** History:
**  2006/03/07: Auto Generated
*********************************************************************

*!ToDo: Implement this function
*!ToDo: Test this function
RETURN NULL

LOCAL loExc AS Exception
TRY
** This.SetStatus(GdipSomeFunction???())
CATCH TO loExc
	THROW m.loExc
ENDTRY
RETURN
ENDPROC
PROCEDURE Init
*********************************************************************
** Method: GraphicsContainer
**
** Represents the internal data of a graphics container. This class is used when saving
** the state of a Graphics object using the BeginContainer and EndContainer methods.
** This class cannot be inherited.
**
** History:
**  2006/03/07: Auto Generated
*********************************************************************


*!ToDo: Implement this function
*!ToDo: Test this function
RETURN

LOCAL loExc AS Exception
TRY
	DODEFAULT()
	
	** This.SetStatus(GdipSomeFunction???())
CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN

** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.GraphicsContainer%28vs.80%29.aspx
** Parameters:

*********************************************************************

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
basename
handle
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED8]
drawing.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] xfcgraphicscontainer
[START RESERVED1]
 	 drawing.hﬁ„„M5 system.hÊ‰0•Ô4 gdiplusconstants.hÓÂÎi05[END RESERVED1]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1QZ0NRRDJ
[CLASS] xfcgpobject
[CLASSLOC] drawing.vcx
[BASECLASS] custom
[OBJNAME] xfcgraphicspath
[START PROPERTIES]
fillmode = 0
pathdata = 0
pointcount = 0
_memberdata =     2975<VFPData><memberdata name="addarc" type="method" display="AddArc"/><memberdata name="addbezier" type="method" display="AddBezier"/><memberdata name="addbeziers" type="method" display="AddBeziers"/><memberdata name="addclosedcurve" type="method" display="AddClosedCurve"/><memberdata name="addcurve" type="method" display="AddCurve"/><memberdata name="addellipse" type="method" display="AddEllipse"/><memberdata name="addline" type="method" display="AddLine"/><memberdata name="addlines" type="method" display="AddLines"/><memberdata name="addpath" type="method" display="AddPath"/><memberdata name="addpie" type="method" display="AddPie"/><memberdata name="addpolygon" type="method" display="AddPolygon"/><memberdata name="addrectangle" type="method" display="AddRectangle"/><memberdata name="addrectangles" type="method" display="AddRectangles"/><memberdata name="addstring" type="method" display="AddString"/><memberdata name="clearmarkers" type="method" display="ClearMarkers"/><memberdata name="clone" type="method" display="Clone"/><memberdata name="closeallfigures" type="method" display="CloseAllFigures"/><memberdata name="closefigure" type="method" display="CloseFigure"/><memberdata name="createobjref" type="method" display="CreateObjRef"/><memberdata name="dispose" type="method" display="Dispose"/><memberdata name="equals" type="method" display="Equals"/><memberdata name="flatten" type="method" display="Flatten"/><memberdata name="getbounds" type="method" display="GetBounds"/><memberdata name="gethashcode" type="method" display="GetHashCode"/><memberdata name="getlastpoint" type="method" display="GetLastPoint"/><memberdata name="getlifetimeservice" type="method" display="GetLifetimeService"/><memberdata name="gettype" type="method" display="GetType"/><memberdata name="initializelifetimeservice" type="method" display="InitializeLifetimeService"/><memberdata name="isoutlinevisible" type="method" display="IsOutlineVisible"/><memberdata name="isvisible" type="method" display="IsVisible"/><memberdata name="reset" type="method" display="Reset"/><memberdata name="reverse" type="method" display="Reverse"/><memberdata name="setmarkers" type="method" display="SetMarkers"/><memberdata name="startfigure" type="method" display="StartFigure"/><memberdata name="tostring" type="method" display="ToString"/><memberdata name="transform" type="method" display="Transform"/><memberdata name="warp" type="method" display="Warp"/><memberdata name="widen" type="method" display="Widen"/><memberdata name="finalize" type="method" display="Finalize"/><memberdata name="memberwiseclone" type="method" display="MemberwiseClone"/><memberdata name="fillmode" type="property" display="FillMode"/><memberdata name="pathdata" type="property" display="PathData"/><memberdata name="pathpoints" type="property" display="PathPoints"/><memberdata name="pathtypes" type="property" display="PathTypes"/><memberdata name="pointcount" type="property" display="PointCount"/></VFPData>
basename = GraphicsPath
lastresult = 0
Name = "xfcgraphicspath"
[END PROPERTIES]
[START PROTECTED]
_memberdata
[END PROTECTED]
[START METHODS]
PROCEDURE Destroy
*********************************************************************
** Method: Destroy
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/06: BDurban - Coded
*********************************************************************

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
This.SetStatus(GdipDeletePath(This.Handle))
CATCH TO loExc
	THROW m.loExc
ENDTRY
RETURN
ENDPROC
PROCEDURE Init
*********************************************************************
** Method: GraphicsPath
**
** Initializes a new instance of the GraphicsPath class with a FillMode enumeration
** of Alternate.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/06: BDurban - Coded
*********************************************************************
LPARAMETERS taoPts AS xfcPoint, taiTypes AS EnumPathPointType, ;
			tiFillMode AS EnumFillMode
*********** tiFillMode AS EnumFillMode
*********** [None]

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	LOCAL loPoint AS xfcPoint, lqPoints, liCount, lqTypes, lnCnt, lhPath

	DODEFAULT()
	This.DeclareDLL()
	
	EXTERNAL ARRAY taiTypes

	m.lqPoints = 0h
	m.liCount = 0
	m.lqTypes = 0h
	m.lhPath = 0
	
	*!ToDo: Make the parameter handling here better. We need to check if parameter 2 is an array.
	*!We may want to allow differenct parameters here also
	
	DO CASE
	CASE VARTYPE(m.taoPts)="Q" OR (VARTYPE(m.taoPts)="O" AND m.taoPts.BaseName = "PointF")
		m.loPoint = This.CreateNew("xfcPointF")
		m.lqPoints = loPoint.ToVarBinary(@taoPts, @liCount)
		m.tiFillMode = EVL(m.tiFillMode, FillModeAlternate)
		FOR lnCnt = 1 TO m.liCount
			m.lqTypes = m.lqTypes + BINTOC(m.taiTypes[m.lnCnt],"4rs")
		ENDFOR
		This.SetStatus(GdipCreatePath2(@lqPoints, @lqTypes, m.liCount, m.tiFillMode, @lhPath))
		
	CASE VARTYPE(m.taoPts)="O" AND m.taoPts.BaseName = "Point"
		m.loPoint = This.CreateNew("xfcPointF")
		m.lqPoints = loPoint.ToVarBinary(@taoPts, @liCount)
		m.tiFillMode = EVL(m.tiFillMode, FillModeAlternate)
		FOR m.lnCnt = 1 TO m.liCount
			m.lqTypes = m.lqTypes + BINTOC(m.taiTypes[m.lnCnt],"4rs")
		ENDFOR
		This.SetStatus(GdipCreatePath2I(@lqPoints, @lqTypes, m.liCount, m.tiFillMode, @lhPath))
		
	OTHERWISE
		m.tiFillMode = EVL(m.tiFillMode, FillModeAlternate)
		m.lnFuntionType = 3
		This.SetStatus(GdipCreatePath(m.tiFillMode, @lhPath))
		
	ENDCASE
	
	This.Handle = m.lhPath
	
CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN

** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.GraphicsPath.GraphicsPath%28vs.80%29.aspx
** Parameters:
**  [None]
**  FillMode fillMode
**  Point[] pts, byte[] types
**  PointF[] pts, byte[] types
**  Point[] pts, byte[] types, FillMode fillMode
**  PointF[] pts, byte[] types, FillMode fillMode
*********************************************************************

ENDPROC
PROCEDURE addarc
*********************************************************************
** Method: AddArc
**
** Appends an elliptical arc to the current figure.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/06: BDurban - Coded
*********************************************************************
LPARAMETERS tnX, tnY, tnWidth, tnHeight, tnStartAngle, tnSweepAngle
*********** toRect AS xfcRectangle, tnStartAngle, tnSweepAngle

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	LOCAL loRect AS xfcRectangle
	LOCAL llUsePrecision
	DO CASE
	CASE VARTYPE(m.tnX)="O" AND tnX.BaseName == "RectangleF"
		m.tnSweepAngle = m.tnWidth
		m.tnStartAngle = m.tnY
		m.oRect = m.tnX
		m.loRect.GetExtent(@tnX, @tnY, @tnWidth, @tnHeight)
		m.llUsePrecision = .T.
		
	CASE VARTYPE(m.tnX)="O" AND tnX.BaseName == "Rectangle"
		m.tnSweepAngle = m.tnWidth
		m.tnStartAngle = m.tnY
		m.oRect = m.tnX
		m.loRect.GetExtent(@tnX, @tnY, @tnWidth, @tnHeight)
		m.llUsePrecision = .F.
		
	CASE INT(m.tnX)=m.tnX AND INT(m.tnY)=m.tnY AND INT(m.tnHeight)=m.tnHeight AND INT(m.tnWidth)=m.tnWidth
		m.llUsePrecision = .F.
		
	OTHERWISE
	ENDCASE
	
	IF llUsePrecision
		This.SetStatus(GdipAddPathArc(This.Handle, m.tnX, m.tnY, m.tnWidth, m.tnHeight, m.tnStartAngle, m.tnSweepAngle))
	ELSE
		This.SetStatus(GdipAddPathArcI(m.This.Handle, m.tnX, m.tnY, m.tnWidth, m.tnHeight, m.tnStartAngle, m.tnSweepAngle))
	ENDIF

CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.GraphicsPath.AddArc%28vs.80%29.aspx
** Parameters:
**  Rectangle rect, float startAngle, float sweepAngle
**  RectangleF rect, float startAngle, float sweepAngle
**  int x, int y, int width, int height, float startAngle, float sweepAngle
**  float x, float y, float width, float height, float startAngle, float sweepAngle
** Returns: void
*********************************************************************

ENDPROC
PROCEDURE addbezier
*********************************************************************
** Method: AddBezier
**
** Adds a cubic Bezier curve to the current figure.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/08: BDurban - Coded
*********************************************************************
LPARAMETERS tnX1, tnY1, tnX2, tnY2, tnX3, tnY3, tnX4, tnY4
*********** toPt1 AS xfcPoint, toPt2 AS xfcPoint, toPt3 AS xfcPoint, toPt4 AS xfcPoint

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	DO CASE
	CASE VARTYPE(m.tnX)="O"
		m.loPt1 = m.tnX1
		m.loPt2 = m.tnY1
		m.loPt3 = m.tnX2
		m.loPt4 = m.tnY2
		m.loPt1.GetExtent(@tnX1,@tnY1)
		m.loPt1.GetExtent(@tnX1,@tnY1)
		m.loPt1.GetExtent(@tnX1,@tnY1)
		m.loPt1.GetExtent(@tnX1,@tnY1)
		IF m.loPt1.Basename=="PointF"
			This.SetStatus(GdipAddPathBezier(This.Handle, m.tnX1, m.tnY1, m.tnX2, m.tnY2, m.tnX3, m.tnY3, m.tnX4, m.tnY4))
		ELSE
			This.SetStatus(GdipAddPathBezierI(This.Handle, m.tnX1, m.tnY1, m.tnX2, m.tnY2, m.tnX3, m.tnY3, m.tnX4, m.tnY4))
		ENDIF
	OTHERWISE
		This.SetStatus(GdipAddPathBezier(This.Handle, m.tnX1, m.tnY1, m.tnX2, m.tnY2, m.tnX3, m.tnY3, m.tnX4, m.tnY4))
	ENDCASE

CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.GraphicsPath.AddBezier%28vs.80%29.aspx
** Parameters:
**  Point pt1, Point pt2, Point pt3, Point pt4
**  PointF pt1, PointF pt2, PointF pt3, PointF pt4
**  int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4
**  float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4
** Returns: void
*********************************************************************

ENDPROC
PROCEDURE addbeziers
*********************************************************************
** Method: AddBeziers
**
** Adds a sequence of connected cubic Bezier curves to the current figure.
**
** History:
**  2006/03/07: Auto Generated
**	2006/06/11: BDurban - Coded
*********************************************************************
LPARAMETERS taoPoints AS xfcPoint

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	
	LOCAL loPoint AS xfcPoint
	LOCAL lqPoints, liCount
	m.lqPoints = 0h
	m.liCount = 0
	
	** Check precision
	IF m.taoPoints.BaseName = "PointF"
		m.loPoint = This.CreateNew("xfcPointF")
		m.lqPoints = m.loPoint.ToVarBinary(@taoPoints, @liCount)
		This.SetStatus(GdipAddPathBeziers(This.Handle, @lqPoints, m.liCount))
	ELSE
		m.loPoint = This.CreateNew("xfcPoint")
		m.lqPoints = m.loPoint.ToVarBinary(@taoPoints, @liCount)
		This.SetStatus(GdipAddPathBeziersI(This.Handle, @lqPoints, m.liCount))
	ENDIF
	
CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.GraphicsPath.AddBeziers%28vs.80%29.aspx
** Parameters:
**  Point[] points
**  PointF[] points
** Returns: void
*********************************************************************

ENDPROC
PROCEDURE addclosedcurve
*********************************************************************
** Method: AddClosedCurve
**
** Adds a closed curve to this path. A cardinal spline curve is used because the curve
** travels through each of the points in the array.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/06: BDurban - Coded
*********************************************************************
LPARAMETERS taoPoints AS xfcPoint, ;
			tnTension

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY

	LOCAL lnFunctionType
	m.lnFunctionType = 0
	
	LOCAL loPoint AS xfcPoint, lqPoints, liCount
	m.liCount = 0
	
	DO CASE
	CASE VARTYPE(taoPoints)="O" AND taoPoints.BaseName=="PointF"
		m.loPoint = m.taoPoints
		m.lqPoints = m.loPoint.ToVarBinary(@taoPoints, @liCount)
		IF VARTYPE(m.tnTension)="N"
			This.SetStatus(GdipAddPathClosedCurve(This.Handle, m.lqPoints, m.liCount))
		ELSE
			This.SetStatus(GdipAddPathClosedCurve2(This.Handle, m.lqPoints, m.liCount, m.tnTension))
		ENDIF
		
	CASE VARTYPE(taoPoints)="O" AND taoPoints.BaseName=="Point"
		m.loPoint = m.taoPoints
		m.lqPoints = m.loPoint.ToVarBinary(@taoPoints, @liCount)
		IF VARTYPE(m.tnTension)="N"
			This.SetStatus(GdipAddPathClosedCurveI(This.Handle, m.lqPoints, m.liCount))
		ELSE
			This.SetStatus(GdipAddPathClosedCurve2I(This.Handle, m.lqPoints, m.liCount, m.tnTension))
		ENDIF
	ENDCASE

CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.GraphicsPath.AddClosedCurve%28vs.80%29.aspx
** Parameters:
**  Point[] points
**  PointF[] points
**  Point[] points, float tension
**  PointF[] points, float tension
** Returns: void
*********************************************************************

ENDPROC
PROCEDURE addcurve
*********************************************************************
** Method: AddCurve
**
** Adds a spline curve to the current figure. A cardinal spline curve is used because
** the curve travels through each of the points in the array.
**
** History:
**  2006/03/07: Auto Generated
**	2006/06/11: BDurban - Coded
**  2006/09/10: CChalom - Fixed
*********************************************************************
LPARAMETERS taoPoints AS xfcPoint, ;
			tiOffset, tiNumberOfSegments, tnTension
*********** taoPoints AS xfcPoint, tnTension

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY

	LOCAL loPoint AS xfcPoint
	LOCAL lqPoints, liCount, llUsePrecision
	m.lqPoints = 0h
	m.liCount = 0
	m.llUsePrecision = .F.
	
	** Check precision
	IF m.taoPoints(1).BaseName = "PointF"
		m.loPoint = This.CreateNew("xfcPointF")
		m.lqPoints = m.loPoint.ToVarBinary(@taoPoints, @liCount)
		m.llUsePrecision = .T.
	ELSE
		m.loPoint = This.CreateNew("xfcPoint")
		m.lqPoints = m.loPoint.ToVarBinary(@taoPoints, @liCount)
		m.llUsePrecision = .F.
	ENDIF


	LOCAL lnFunctionType
	m.lnFunctionType = 0
	
	DO CASE
	CASE VARTYPE(m.tiOffset)+VARTYPE(m.tiNumberOfSegments)+VARTYPE(m.tnTension)=="NNN"
		IF m.llUsePrecision
			This.SetStatus(GdipAddPathCurve3(This.Handle, @lqPoints, m.liCount, m.tiOffset, m.tiNumberOfSegments, m.tnTension))
		ELSE
			This.SetStatus(GdipAddPathCurve3I(This.Handle, @lqPoints, m.liCount, m.tiOffset, m.tiNumberOfSegments, m.tnTension))
		ENDIF
		
	CASE VARTYPE(m.tiOffset)=="N"
		m.tnTension = m.tiOffset
		IF m.llUsePrecision
			This.SetStatus(GdipAddPathCurve2(This.Handle, @lqPoints, m.liCount, m.tnTension))
		ELSE
			This.SetStatus(GdipAddPathCurve2I(This.Handle, @lqPoints, m.liCount, m.tnTension))
		ENDIF
	
	OTHERWISE
		IF m.llUsePrecision
			This.SetStatus(GdipAddPathCurve(This.Handle, @lqPoints, m.liCount))
		ELSE
			This.SetStatus(GdipAddPathCurveI(This.Handle, @lqPoints, m.liCount))
		ENDIF
	ENDCASE

CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.GraphicsPath.AddCurve%28vs.80%29.aspx
** Parameters:
**  Point[] points
**  PointF[] points
**  Point[] points, float tension
**  PointF[] points, float tension
**  Point[] points, int offset, int numberOfSegments, float tension
**  PointF[] points, int offset, int numberOfSegments, float tension
** Returns: void
*********************************************************************

ENDPROC
PROCEDURE addellipse
*********************************************************************
** Method: AddEllipse
**
** Adds an ellipse to the current path.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/08: BDurban - Coded
*********************************************************************
LPARAMETERS tnX, tnY, tnWidth, tnHeight
*********** toRect AS xfcRectangle

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	DO CASE
	CASE VARTYPE(m.tnX)="O" AND m.tnX.BaseName=="RectangleF"
		m.loRect = m.tnX
		m.loRect.GetExtent(@tnX,@tnY,@tnWidth,@tnHeight)
		This.SetStatus(GdipAddPathEllipse(This.Handle, m.tnX, m.tnY, m.tnWidth, m.tnHeight))
		
	CASE VARTYPE(m.tnX)="O" AND m.tnX.BaseName=="Rectangle"
		m.loRect = m.tnX
		m.loRect.GetExtent(@tnX,@tnY,@tnWidth,@tnHeight)
		This.SetStatus(GdipAddPathEllipseI(This.Handle, m.tnX, m.tnY, m.tnWidth, m.tnHeight))
		
	CASE INT(m.tnX)=m.tnX AND INT(m.tnY)=m.tnY AND INT(m.tnWidth)=m.tnWidth AND INT(m.tnHeight)=m.tnHeight
		This.SetStatus(GdipAddPathEllipseI(This.Handle, m.tnX, m.tnY, m.tnWidth, m.tnHeight))
		
	OTHERWISE
		This.SetStatus(GdipAddPathEllipse(This.Handle, m.tnX, m.tnY, m.tnWidth, m.tnHeight))
	ENDCASE
	
CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.GraphicsPath.AddEllipse%28vs.80%29.aspx
** Parameters:
**  Rectangle rect
**  RectangleF rect
**  int x, int y, int width, int height
**  float x, float y, float width, float height
** Returns: void
*********************************************************************

ENDPROC
PROCEDURE addline
*********************************************************************
** Method: AddLine
**
** Appends a line segment to this GraphicsPath object.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/08: BDurban - Coded
**  2006/09/10: CChalom - Fixed
*********************************************************************
LPARAMETERS tnX1, tnY1, tnX2, tnY2
*********** toPt1 AS xfcPoint, toPt2 AS xfcPoint

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	LOCAL loPoint1 AS xfcPoint, loPoint2 AS xfcPoint
	DO CASE
	CASE VARTYPE(m.tnX1)="O" AND m.tnX1.BaseName="PointF"
		m.loPoint1 = m.tnX1
		m.loPoint2 = m.tnY1
		m.loPoint1.GetExtent(@tnX1, @tnY1)
		m.loPoint2.GetExtent(@tnX2, @tnY2)
		This.SetStatus(GdipAddPathLine(This.Handle, m.tnX1, m.tnY1, m.tnX2, m.tnY2))
		
	CASE VARTYPE(m.tnX1)="O" AND m.tnX1.BaseName="Point"
		m.loPoint1 = m.tnX1
		m.loPoint2 = m.tnY1
		m.loPoint1.GetExtent(@tnX1, @tnY1)
		m.loPoint2.GetExtent(@tnX2, @tnY2)
		This.SetStatus(GdipAddPathLineI(This.Handle, m.tnX1, m.tnY1, m.tnX2, m.tnY2))
		
	CASE INT(m.tnX1)=m.tnX1 AND INT(m.tnY1)=m.tnY1 AND INT(m.tnX2)=m.tnX2 AND INT(m.tnY2)=m.tnY2
		This.SetStatus(GdipAddPathLineI(This.Handle, m.tnX1, m.tnY1, m.tnX2, m.tnY2))
		
	OTHERWISE
		This.SetStatus(GdipAddPathLine(This.Handle, m.tnX1, m.tnY1, m.tnX2, m.tnY2))
	ENDCASE

CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.GraphicsPath.AddLine%28vs.80%29.aspx
** Parameters:
**  Point pt1, Point pt2
**  PointF pt1, PointF pt2
**  int x1, int y1, int x2, int y2
**  float x1, float y1, float x2, float y2
** Returns: void
*********************************************************************

ENDPROC
PROCEDURE addlines
*********************************************************************
** Method: AddLines
**
** Appends a series of connected line segments to the end of this GraphicsPath object.
**
** History:
**  2006/03/07: Auto Generated
**	2006/06/11: BDurban - Coded
**  2006/08/27: BDurban/CChalom - Fixed array reference
*********************************************************************
LPARAMETERS taoPoints AS xfcPoint

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	
	LOCAL loPoint AS xfcPoint
	LOCAL lqPoints, liCount
	m.lqPoints = 0h
	m.liCount = 0
	
	** Check precision
	IF m.taoPoints[1].BaseName = "PointF"
		m.loPoint = This.CreateNew("xfcPointF")
		m.lqPoints = m.loPoint.ToVarBinary(@taoPoints, @liCount)
		This.SetStatus(GdipAddPathLine2(This.Handle, @lqPoints, m.liCount))
	ELSE
		m.loPoint = This.CreateNew("xfcPoint")
		m.lqPoints = m.loPoint.ToVarBinary(@taoPoints, @liCount)
		This.SetStatus(GdipAddPathLine2I(This.Handle, @lqPoints, m.liCount))
	ENDIF

CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.GraphicsPath.AddLines%28vs.80%29.aspx
** Parameters:
**  Point[] points
**  PointF[] points
** Returns: void
*********************************************************************

ENDPROC
PROCEDURE addpath
*********************************************************************
** Method: AddPath
**
** Appends the specified GraphicsPath object to this path.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/08: BDurban - Coded
*********************************************************************
LPARAMETERS toAddingPath AS xfcGraphicsPath, tlConnect

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	LOCAL lhAddingPath
	m.lhAddingPath = IIF(VARTYPE(m.toAddingPath)="O", m.toAddingPath.Handle, 0)
	This.SetStatus(GdipAddPathPath(This.Handle, m.lhAddingPath, IIF(m.tlConnect,1,0)))

CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.GraphicsPath.AddPath%28vs.80%29.aspx
** Parameters:
**  GraphicsPath addingPath, bool connect
** Returns: void
*********************************************************************

ENDPROC
PROCEDURE addpie
*********************************************************************
** Method: AddPie
**
** Adds the outline of a pie shape to this path.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/08: BDurban - Coded
*********************************************************************
LPARAMETERS tnX, tnY, tnWidth, tnHeight, tnStartAngle, tnSweepAngle
*********** toRect AS xfcRectangle, tnStartAngle, tnSweepAngle

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	LOCAL loRect AS Rectangle
	DO CASE
	CASE VARTYPE(m.tnX) = "O"
		m.loRect = m.tnX
		m.tnStartAngle = m.tnY
		m.tnSweepAngle = m.tnWidth
		m.loRect.GetExtent(@tnX, @tnY, @tnWidth, @tnHeight)
		IF m.loRect.BaseName = "RectangleF"
			This.SetStatus(GdipAddPathPie(This.Handle, m.tnX, m.tnY, m.tnWidth, m.tnHeight, m.tnStartAngle, m.tnSweepAngle))
		ELSE
			This.SetStatus(GdipAddPathPieI(This.Handle, m.tnX, m.tnY, m.tnWidth, m.tnHeight, m.tnStartAngle, m.tnSweepAngle))
		ENDIF
	OTHERWISE
		This.SetStatus(GdipAddPathPie(This.Handle, m.tnX, m.tnY, m.tnWidth, m.tnHeight, m.tnStartAngle, m.tnSweepAngle))
	ENDCASE
	
CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.GraphicsPath.AddPie%28vs.80%29.aspx
** Parameters:
**  Rectangle rect, float startAngle, float sweepAngle
**  int x, int y, int width, int height, float startAngle, float sweepAngle
**  float x, float y, float width, float height, float startAngle, float sweepAngle
** Returns: void
*********************************************************************

ENDPROC
PROCEDURE addpolygon
*********************************************************************
** Method: AddPolygon
**
** Adds a polygon to this path.
**
** History:
**  2006/03/07: Auto Generated
**	2006/06/11: BDurban - Coded
**	2006/10/14: BDurban - Tweaked for different array types
*********************************************************************
LPARAMETERS taoPoints AS xfcPoint

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY

	LOCAL loPoint AS xfcPoint
	LOCAL lqPoints, liCount
	m.lqPoints = 0h
	m.liCount = 0
	
	** Check precision
	IF VARTYPE(m.taoPoints)="O" AND m.taoPoints.BaseName == "Point"
		m.loPoint = This.CreateNew("xfcPoint")
		m.lqPoints = m.loPoint.ToVarBinary(@m.taoPoints, @m.liCount)
		This.SetStatus(GdipAddPathPolygonI(This.Handle, @m.lqPoints, m.liCount))
	ELSE
		m.loPoint = This.CreateNew("xfcPointF")
		m.lqPoints = m.loPoint.ToVarBinary(@m.taoPoints, @liCount)
		This.SetStatus(GdipAddPathPolygon(This.Handle, @m.lqPoints, m.liCount))
	ENDIF

CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.GraphicsPath.AddPolygon%28vs.80%29.aspx
** Parameters:
**  Point[] points
**  PointF[] points
** Returns: void
*********************************************************************

ENDPROC
PROCEDURE addrectangle
*********************************************************************
** Method: AddRectangle
**
** Adds a rectangle to this path.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/08: BDurban - Coded
*********************************************************************
LPARAMETERS tnX, tnY, tnWidth, tnHeight
*********** toRect AS xfcRectangle

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	LOCAL loRect AS Rectangle
	DO CASE
	CASE VARTYPE(m.tnX)="O" AND m.tnX.BaseName = "RectangleF"
		m.loRect = m.tnX
		m.loRect.GetExtent(@tnX, @tnY, @tnWidth, @tnHeight)
		This.SetStatus(GdipAddPathRectangle(This.Handle, m.tnX, m.tnY, m.tnWidth, m.tnHeight))
		
	CASE VARTYPE(m.tnX)="O" AND m.tnX.BaseName = "Rectangle"
		m.loRect = m.tnX
		m.loRect.GetExtent(@tnX, @tnY, @tnWidth, @tnHeight)
		This.SetStatus(GdipAddPathRectangleI(This.Handle, m.tnX, m.tnY, m.tnWidth, m.tnHeight))

	OTHERWISE
		This.SetStatus(GdipAddPathRectangleI(This.Handle, m.tnX, m.tnY, m.tnWidth, m.tnHeight))
	ENDCASE

CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.GraphicsPath.AddRectangle%28vs.80%29.aspx
** Parameters:
**  Rectangle rect
**  RectangleF rect
** Returns: void
*********************************************************************

ENDPROC
PROCEDURE addrectangles
*********************************************************************
** Method: AddRectangles
**
** Adds a series of rectangles to this path.
**
** History:
**  2006/03/07: Auto Generated
**  2006/07/08: BDurban - Coded
**  2006/08/27: BDurban/CChalom - Fixed array reference
*********************************************************************
LPARAMETERS taoRects AS xfcRectangle

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY

	LOCAL loRect AS xfcRect
	LOCAL lqRects, liCount
	m.loRects = 0h
	m.liCount = 0

	** Check precision
	IF m.taoRects[1].BaseName = "RectangleF"
		m.loRect = This.CreateNew("xfcRectangleF")
		m.lqRects = m.loRect.ToVarBinary(@taoRects, @liCount)
		This.SetStatus(GdipAddPathRectangles(This.Handle, @lqRects, m.liCount))
	ELSE
		m.loRect = This.CreateNew("xfcRectangle")
		m.lqRects = m.loRect.ToVarBinary(@taoRects, @liCount)
		This.SetStatus(GdipAddPathRectanglesI(This.Handle, @lqRects, m.liCount))
	ENDIF

CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL

** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.GraphicsPath.AddRectangles%28vs.80%29.aspx
** Parameters:
**  Rectangle[] rects
**  RectangleF[] rects
** Returns: void
*********************************************************************

ENDPROC
PROCEDURE addstring
*********************************************************************
** Method: AddString
**
** Adds a text string to this path.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/08: BDurban - Coded
*********************************************************************
LPARAMETERS tcS, toFamily AS xfcFontFamily, tiStyle, tnEmSize, toLayoutRect AS xfcRectangle, toFormat AS xfcStringFormat
*********** tcS, toFamily AS xfcFontFamily, tiStyle, tnEmSize, toOrigin AS xfcPoint, toFormat AS xfcStringFormat

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	LOCAL lhFamily, lhFormat, loPoint AS xfcPoint
	** These 2 parameters can be NULL
	m.lhFamily = IIF(VARTYPE(m.toFamily)="O", m.toFamily.Handle, 0)
	m.lhFormat = IIF(VARTYPE(m.toFormat)="O", m.toFormat.Handle, 0)
	
	DO CASE
	CASE VARTYPE(toLayoutRect) = "O" AND INLIST(m.toLayoutRect.BaseName, "PointF", "RectangleF")
		IF m.toLayoutRect.BaseName = "PointF"
			m.loPoint = m.toLayoutRect
			m.toLayoutRect = This.CreateNew("xfcRectangleF", m.loPoint.X, m.loPoint.Y, 0.00, 0.00)
		ENDIF
		This.SetStatus(GdipAddPathString(This.Handle, STRCONV(m.tcS+0h00,5), LEN(m.tcS), m.lhFamily, m.tiStyle, m.tnEmSize, m.toLayoutRect.ToVarBinary(), m.lhFormat))
		
	CASE VARTYPE(toLayoutRect) = "O" AND INLIST(m.toLayoutRect.BaseName, "Point", "Rectangle")
		IF m.toLayoutRect.BaseName = "Point"
			m.loPoint = m.toLayoutRect
			m.toLayoutRect = This.CreateNew("xfcRectangle", m.loPoint.X, m.loPoint.Y, 0.00, 0.00)
		ENDIF
		This.SetStatus(GdipAddPathStringI(This.Handle, STRCONV(m.tcS+0h00,5), LEN(m.tcS), m.lhFamily, m.tiStyle, m.tnEmSize, m.toLayoutRect.ToVarBinary(), m.lhFormat))
	ENDCASE

CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.GraphicsPath.AddString%28vs.80%29.aspx
** Parameters:
**  string s, FontFamily family, int style, float emSize, Point origin, StringFormat format
**  string s, FontFamily family, int style, float emSize, PointF origin, StringFormat format
**  string s, FontFamily family, int style, float emSize, Rectangle layoutRect, StringFormat format
**  string s, FontFamily family, int style, float emSize, RectangleF layoutRect, StringFormat format
** Returns: void
*********************************************************************

ENDPROC
PROCEDURE clearmarkers
*********************************************************************
** Method: ClearMarkers
**
** Clears all markers from this path.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/08: BDurban - Coded
*********************************************************************

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY

	This.SetStatus(GdipClearPathMarkers(This.Handle))

CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.GraphicsPath.ClearMarkers%28vs.80%29.aspx
** Parameters:
**  [None]
** Returns: void
*********************************************************************

ENDPROC
PROCEDURE clone
*********************************************************************
** Method: Clone
**
** Creates an exact copy of this path.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/08: BDurban - Coded
*********************************************************************

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	LOCAL loClonePath, lhClonePath
	m.lhClonePath = 0
	m.loClonePath = NULL
	This.SetStatus(GdipClonePath(This.Handle, @lhClonePath))
	IF(m.lhClonePath <> 0)
		m.loClonePath = This.CreateNew(This.Class)
		m.loClonePath.Handle = m.lhClonePath
	ENDIF
CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN m.loobject


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.GraphicsPath.Clone%28vs.80%29.aspx
** Parameters:
**  [None]
** Returns: object
*********************************************************************

ENDPROC
PROCEDURE closeallfigures
*********************************************************************
** Method: CloseAllFigures
**
** Closes all open figures in this path and starts a new figure. It closes each open
** figure by connecting a line from its endpoint to its starting point.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/08: BDurban - Coded
*********************************************************************

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY

	This.SetStatus(GdipClosePathFigures(This.Handle))

CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.GraphicsPath.CloseAllFigures%28vs.80%29.aspx
** Parameters:
**  [None]
** Returns: void
*********************************************************************

ENDPROC
PROCEDURE closefigure
*********************************************************************
** Method: CloseFigure
**
** Closes the current figure and starts a new figure. If the current figure contains
** a sequence of connected lines and curves, the method closes the loop by connecting
** a line from the endpoint to the starting point.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/08: BDurban - Coded
*********************************************************************

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY

	This.SetStatus(GdipClosePathFigure(This.Handle))

CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.GraphicsPath.CloseFigure%28vs.80%29.aspx
** Parameters:
**  [None]
** Returns: void
*********************************************************************

ENDPROC
PROCEDURE declaredll
TRY

xfcGraphicsPathDeclareDLL(0)

CATCH

DECLARE Long Sleep IN WIN32API AS xfcGraphicsPathDeclareDLL Long

DECLARE LONG GdipCreatePath IN GDIPLUS LONG brushmode, LONG @path
DECLARE LONG GdipCreatePath2 IN GDIPLUS STRING @pPoint, STRING @types, LONG Count, LONG brushmode, LONG @path
DECLARE LONG GdipCreatePath2I IN GDIPLUS STRING @pPoint, STRING @types, LONG Count, LONG brushmode, LONG @path
DECLARE LONG GdipClonePath IN GDIPLUS LONG path, LONG @clonePath
DECLARE LONG GdipDeletePath IN GDIPLUS LONG path
DECLARE LONG GdipResetPath IN GDIPLUS LONG path
DECLARE LONG GdipGetPointCount IN GDIPLUS LONG path, LONG @Count
DECLARE LONG GdipGetPathTypes IN GDIPLUS LONG path, STRING @types, LONG Count
DECLARE LONG GdipGetPathPoints IN GDIPLUS LONG path, STRING @pPoint, LONG Count
DECLARE LONG GdipGetPathPointsI IN GDIPLUS LONG path, STRING @pPoint, LONG Count
DECLARE LONG GdipGetPathFillMode IN GDIPLUS LONG path, LONG brushmode
DECLARE LONG GdipSetPathFillMode IN GDIPLUS LONG path, LONG brushmode
DECLARE LONG GdipGetPathData IN GDIPLUS LONG path, STRING @pdata
DECLARE LONG GdipStartPathFigure IN GDIPLUS LONG path
DECLARE LONG GdipClosePathFigure IN GDIPLUS LONG path
DECLARE LONG GdipClosePathFigures IN GDIPLUS LONG path
DECLARE LONG GdipSetPathMarker IN GDIPLUS LONG path
DECLARE LONG GdipClearPathMarkers IN GDIPLUS LONG path
DECLARE LONG GdipReversePath IN GDIPLUS LONG path
DECLARE LONG GdipGetPathLastPoint IN GDIPLUS LONG path, STRING @lastPoint
DECLARE LONG GdipAddPathLine IN GDIPLUS LONG path, SINGLE x1, SINGLE y1, SINGLE x2, SINGLE y2
DECLARE LONG GdipAddPathLine2 IN GDIPLUS LONG path, STRING @pPoint, LONG Count
DECLARE LONG GdipAddPathArc IN GDIPLUS LONG path, SINGLE x, SINGLE y, SINGLE nWidth, SINGLE Height, SINGLE startAngle, SINGLE sweepAngle
DECLARE LONG GdipAddPathBezier IN GDIPLUS LONG path, SINGLE x1, SINGLE y1, SINGLE x2, SINGLE y2, SINGLE x3, SINGLE y3, SINGLE x4, SINGLE y4
DECLARE LONG GdipAddPathBeziers IN GDIPLUS LONG path, STRING @pPoint, LONG Count
DECLARE LONG GdipAddPathCurve IN GDIPLUS LONG path, STRING @pPoint, LONG Count
DECLARE LONG GdipAddPathCurve2 IN GDIPLUS LONG path, STRING @pPoint, LONG Count, SINGLE tension
DECLARE LONG GdipAddPathCurve3 IN GDIPLUS LONG path, STRING @pPoint, LONG Count, LONG offset, LONG numberOfSegments, SINGLE tension
DECLARE LONG GdipAddPathClosedCurve IN GDIPLUS LONG path, STRING @pPoint, LONG Count
DECLARE LONG GdipAddPathClosedCurve2 IN GDIPLUS LONG path, STRING @pPoint, LONG Count, SINGLE tension
DECLARE LONG GdipAddPathRectangle IN GDIPLUS LONG path, SINGLE x, SINGLE y, SINGLE nWidth, SINGLE Height
DECLARE LONG GdipAddPathRectangles IN GDIPLUS LONG path, STRING @nRect, LONG Count
DECLARE LONG GdipAddPathEllipse IN GDIPLUS LONG path, SINGLE x, SINGLE y, SINGLE nWidth, SINGLE Height
DECLARE LONG GdipAddPathPie IN GDIPLUS LONG path, SINGLE x, SINGLE y, SINGLE nWidth, SINGLE Height, SINGLE startAngle, SINGLE sweepAngle
DECLARE LONG GdipAddPathPolygon IN GDIPLUS LONG path, STRING @pPoint, LONG Count
DECLARE LONG GdipAddPathPath IN GDIPLUS LONG path, LONG addingPath, LONG bConnect
DECLARE LONG GdipAddPathString IN GDIPLUS LONG path, STRING str, LONG length, LONG family, LONG style, SINGLE emSize, STRING @layoutRect, LONG StringFormat
DECLARE LONG GdipAddPathStringI IN GDIPLUS LONG path, STRING str, LONG length, LONG family, LONG style, SINGLE emSize, STRING @layoutRect, LONG StringFormat
DECLARE LONG GdipAddPathLineI IN GDIPLUS LONG path, LONG x1, LONG y1, LONG x2, LONG y2
DECLARE LONG GdipAddPathLine2I IN GDIPLUS LONG path, STRING @pPoint, LONG Count
DECLARE LONG GdipAddPathArcI IN GDIPLUS LONG path, LONG x, LONG y, LONG nWidth, LONG Height, SINGLE startAngle, SINGLE sweepAngle
DECLARE LONG GdipAddPathBezierI IN GDIPLUS LONG path, LONG x1, LONG y1, LONG x2, LONG y2, LONG x3, LONG y3, LONG x4, LONG y4
DECLARE LONG GdipAddPathBeziersI IN GDIPLUS LONG path, STRING @pPoint, LONG Count
DECLARE LONG GdipAddPathCurveI IN GDIPLUS LONG path, STRING @pPoint, LONG Count
DECLARE LONG GdipAddPathCurve2I IN GDIPLUS LONG path, STRING @pPoint, LONG Count, LONG tension
DECLARE LONG GdipAddPathCurve3I IN GDIPLUS LONG path, STRING @pPoint, LONG Count, LONG offset, LONG numberOfSegments, SINGLE tension
DECLARE LONG GdipAddPathClosedCurveI IN GDIPLUS LONG path, STRING @pPoint, LONG Count
DECLARE LONG GdipAddPathClosedCurve2I IN GDIPLUS LONG path, STRING @pPoint, LONG Count, SINGLE tension
DECLARE LONG GdipAddPathRectangleI IN GDIPLUS LONG path, LONG x, LONG y, LONG nWidth, LONG Height
DECLARE LONG GdipAddPathRectanglesI IN GDIPLUS LONG path, STRING @rects, LONG Count
DECLARE LONG GdipAddPathEllipseI IN GDIPLUS LONG path, LONG x, LONG y, LONG nWidth, LONG Height
DECLARE LONG GdipAddPathPieI IN GDIPLUS LONG path, LONG x, LONG y, LONG nWidth, LONG Height, SINGLE startAngle, SINGLE sweepAngle
DECLARE LONG GdipAddPathPolygonI IN GDIPLUS LONG path, STRING @pPoint, LONG Count
DECLARE LONG GdipFlattenPath IN GDIPLUS LONG path, LONG matrix, SINGLE flatness
DECLARE LONG GdipWindingModeOutline IN GDIPLUS LONG path, LONG matrix, SINGLE flatness
DECLARE LONG GdipWidenPath IN GDIPLUS LONG nativePath, LONG pen, LONG matrix, SINGLE flatness
DECLARE LONG GdipWarpPath IN GDIPLUS LONG path, LONG matrix, STRING @pPoint, LONG Count, SINGLE srcx, SINGLE srcy, SINGLE srcwidth, SINGLE srcheight, LONG WarpMd, SINGLE flatness
DECLARE LONG GdipTransformPath IN GDIPLUS LONG path, LONG matrix
DECLARE LONG GdipGetPathWorldBounds IN GDIPLUS LONG path, STRING @bounds, LONG matrix, LONG pen
DECLARE LONG GdipGetPathWorldBoundsI IN GDIPLUS LONG path, STRING @bounds, LONG matrix, LONG pen
DECLARE LONG GdipIsVisiblePathPoint IN GDIPLUS LONG path, SINGLE x, SINGLE y, LONG graphics, LONG @result
DECLARE LONG GdipIsVisiblePathPointI IN GDIPLUS LONG path, LONG x, LONG y, LONG graphics, LONG @result
DECLARE LONG GdipIsOutlineVisiblePathPoint IN GDIPLUS LONG path, SINGLE x, SINGLE y, LONG pen, LONG graphics, LONG @result
DECLARE LONG GdipIsOutlineVisiblePathPointI IN GDIPLUS LONG path, LONG x, LONG y, LONG pen, LONG graphics, LONG @result

ENDTRY
ENDPROC
PROCEDURE fillmode_access
*********************************************************************
** Property: FillMode (Access)
**
** Gets or sets a FillMode enumeration that determines how the interiors of shapes
** in this GraphicsPath object are filled.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/06: BDurban - Coded
*********************************************************************

*!ToDo: Test this function

LOCAL liFillMode
m.liFillMode = 0

LOCAL loExc AS Exception
TRY
	This.SetStatus(GdipGetPathFillMode(This.Handle, m.liFillmode))

CATCH TO loExc
	THROW m.loExc
ENDTRY
RETURN m.liFillMode

** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.GraphicsPath.FillMode%28vs.80%29.aspx
** Returns: FillMode
*********************************************************************

ENDPROC
PROCEDURE fillmode_assign
*********************************************************************
** Property: FillMode (Assign)
**
** Gets or sets a FillMode enumeration that determines how the interiors of shapes
** in this GraphicsPath object are filled.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/06: BDurban - Coded
*********************************************************************
LPARAMETERS tiFillMode

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	This.SetStatus(GdipSetPathFillMode(This.Handle, m.tiFillmode))
CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL
ENDPROC
PROCEDURE flatten
*********************************************************************
** Method: Flatten
**
** Converts each curve in this path into a sequence of connected line segments.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/08: BDurban - Coded
*********************************************************************
LPARAMETERS toMatrix AS xfcMatrix, ;
			tnFlatness

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	m.lnFlatness = EVL(m.lnFlatness, 0.00)
	This.SetStatus(GdipFlattenPath(This.Handle, m.toMatrix.Handle, m.lnFlatness))

CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.GraphicsPath.Flatten%28vs.80%29.aspx
** Parameters:
**  [None]
**  Matrix matrix
**  Matrix matrix, float flatness
** Returns: void
*********************************************************************

ENDPROC
PROCEDURE getbounds
*********************************************************************
** Method: GetBounds
**
** Returns a rectangle that bounds this GraphicsPath object.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/08: BDurban - Coded
*********************************************************************
LPARAMETERS toMatrix AS xfcMatrix, ;
			toPen AS xfcPen
*********** [None]

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	LOCAL loRectangleF
	m.loRectangleF = NULL
	
	LOCAL lhPen, lhMatrix, lqRect
	m.lqRect = EMPTY_RECTANGLEF

	** Optional Parameters
	m.lhMatrix = IIF(VARTYPE(m.toMatrix)="O", m.toMatrix.Handle, 0)
	m.lhPen = IIF(VARTYPE(m.toPen)="O", m.toPen.Handle, 0)
	
	This.SetStatus(GdipGetPathWorldBounds(This.Handle, @lqRect, m.lhMatrix, m.lhPen))
	*!*	This.SetStatus(GdipGetPathWorldBoundsI(This.Handle, @lcBounds, m.lhMatrix, m.lhPen))
	m.loRectangleF = This.CreateNew("xfcRectangleF", m.lqRect)
CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN m.loRectangleF


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.GraphicsPath.GetBounds%28vs.80%29.aspx
** Parameters:
**  [None]
**  Matrix matrix
**  Matrix matrix, Pen pen
** Returns: RectangleF
*********************************************************************

ENDPROC
PROCEDURE getlastpoint
*********************************************************************
** Method: GetLastPoint
**
** Gets the last point in the PathPoints array of this GraphicsPath object.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/08: BDurban - Coded
*********************************************************************

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	LOCAL loPoint AS xfcPointF, lqLastPoint
	m.loPoint = This.CreateNew("xfcPointF")
	m.lqLastPoint = m.loPoint.ToVarBinary()
	This.SetStatus(GdipGetPathLastPoint(This.Handle, @lqLastPoint))
	m.loPoint = m.loPoint.New(m.lqLastPoint)
CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN m.loPointF


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.GraphicsPath.GetLastPoint%28vs.80%29.aspx
** Parameters:
**  [None]
** Returns: PointF
*********************************************************************

ENDPROC
PROCEDURE isoutlinevisible
*********************************************************************
** Method: IsOutlineVisible
**
** Indicates whether the specified point is contained within (under) the outline of
** this GraphicsPath object when drawn with the specified Pen object.
**
** History:
**  2006/03/07: Auto Generated
**	2006/06/11: BDurban - Coded
*********************************************************************
LPARAMETERS tnX, tnY, toPen AS xfcPen, ;
			toGraphics AS xfcGraphics
*********** toPoint AS xfcPoint, toPen AS xfcPen [, toGraphics AS xfcGraphics]

*!ToDo: Test this function

LOCAL loPoint AS xfcPoint, lhGraphics, liResult

LOCAL loExc AS Exception
TRY
	DO CASE
	CASE VARTYPE(m.tnX) = "O"
		m.toGraphics = m.toPen
		m.toPen = m.tnY
		m.loPoint = m.tnX
		m.loPoint.GetExtent(@tnX,@tnY)
		m.llUsePrecision = m.loPoint.BaseName == "PointF"
	OTHERWISE
		m.llUsePrecision = NOT (INT(m.tnX)=m.tnX AND INT(m.tnY)=m.tnY)
	ENDCASE
	
	m.lhGraphics = IIF(VARTYPE(m.toGraphics)="O", m.toGraphics.Handle, 0)
	m.liResult = 0
	
	IF llUsePrecision
		This.SetStatus(GdipIsOutlineVisiblePathPoint(This.Handle, m.tnX, m.tnY, m.toPen.Handle, m.lhGraphics, @liResult))
	ELSE
		This.SetStatus(GdipIsOutlineVisiblePathPointI(This.Handle, m.tnX, m.tnY, m.toPen.Handle, m.lhGraphics, @liResult))
	ENDIF

CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN (m.liResult = 1)


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible%28vs.80%29.aspx
** Parameters:
**  Point point, Pen pen
**  PointF point, Pen pen
**  int x, int y, Pen pen
**  Point pt, Pen pen, Graphics graphics
**  PointF pt, Pen pen, Graphics graphics
**  float x, float y, Pen pen
**  int x, int y, Pen pen, Graphics graphics
**  float x, float y, Pen pen, Graphics graphics
** Returns: bool
*********************************************************************

ENDPROC
PROCEDURE isvisible
*********************************************************************
** Method: IsVisible
**
** Indicates whether the specified point is contained within this GraphicsPath object.
**
** History:
**  2006/03/07: Auto Generated
**	2006/06/11: BDurban - Coded
*********************************************************************
LPARAMETERS tnX, tnY, ;
			toGraphics AS xfcGraphics
*********** toPoint AS xfcPoint
*********** toPt AS xfcPoint, toGraphics AS xfcGraphics

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	LOCAL liResult, loPoint AS xfcPoint, lhGraphics
	m.liResult = 0
	
	IF VARTYPE(m.tnX) = "O"
		m.loPoint = m.tnX
		m.toGraphics = m.tnY
		m.loPoint.GetExtent(@tnX,@tnY)
	ENDIF
	
	IF VARTYPE(m.toGraphics) = "O"
		m.lhGraphics = m.toGraphics.Handle
	ELSE
		m.lhGraphics = 0
	ENDIF
	
	IF NOT (INT(m.tnX)=m.tnX AND INT(m.tnY)=m.tnY)
		This.SetStatus(GdipIsVisiblePathPoint(This.Handle, m.tnX, m.tnY, m.lhGraphics, @liResult))
	ELSE
		This.SetStatus(GdipIsVisiblePathPointI(This.Handle, m.tnX, m.tnY, m.lhGraphics, @liResult))
	ENDIF

CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN (m.liResult = 1)


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.GraphicsPath.IsVisible%28vs.80%29.aspx
** Parameters:
**  Point point
**  PointF point
**  int x, int y
**  Point pt, Graphics graphics
**  PointF pt, Graphics graphics
**  float x, float y
**  int x, int y, Graphics graphics
**  float x, float y, Graphics graphics
** Returns: bool
*********************************************************************

ENDPROC
PROCEDURE new
LPARAMETERS taoPts AS xfcPoint, taiTypes AS EnumPathPointType, ;
			tiFillMode AS EnumFillMode
*********** tiFillMode AS EnumFillMode
*********** [None]


RETURN This.CreateNew(This.Class, @taoPts, @taiTypes, m.tiFillMode)
ENDPROC
PROCEDURE pathdata_access
*********************************************************************
** Property: PathData (Access)
**
** Gets a PathData object that encapsulates arrays of points (points) and types (types)
** for this GraphicsPath object.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/06: BDurban - Coded
*********************************************************************

*!ToDo: Test this function

LOCAL loPathData, lhPathData
m.lhPathData = 0
m.loPathData = NULL

LOCAL loExc AS Exception
TRY
	This.SetStatus(GdipGetPathData(This.Handle, @lcPathData))
	IF(m.lhPathData <> 0)
		m.loPathData = This.CreateNew("xfcPathData")
		m.loPathData.Handle = m.lhPathData
	ENDIF
CATCH TO loExc
	THROW m.loExc
ENDTRY
RETURN m.loPathData

** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.GraphicsPath.PathData%28vs.80%29.aspx
** Returns: PathData
*********************************************************************

ENDPROC
PROCEDURE pathpoints_access
*********************************************************************
** Property: PathPoints (Access)
**
** Gets the points in the path.
**
** History:
**  2006/03/07: Auto Generated
**	2006/06/11: BDurban - Coded
**  2006/09/06: CChalom - Fixed in the creation of the PointF object
*********************************************************************
LPARAMETERS m.tiIndex

*!ToDo: Test this function

LOCAL lqPoints, lqPoint, loPoint AS xfcPointF

LOCAL loExc AS Exception
TRY
	m.liCount = 0
	m.loPoint = NULL
	m.tiIndex = NVL(m.tiIndex, 1)
	This.SetStatus(GdipGetPointCount(This.Handle, @liCount))
	IF ALEN(This.PathPoints,1) <> m.liCount
		DIMENSION This.PathPoints[MAX(m.liCount,1)]
		This.PathPoints = NULL
	ENDIF
	IF m.tiIndex > m.liCount
		*!ToDo: Error
		m.loPoint = NULL
	ELSE
		m.lqPoints = REPLICATE(EMPTY_POINTF ,m.liCount)
		This.SetStatus(GdipGetPathPoints(This.Handle, @lqPoints, m.liCount))
		*!*This.SetStatus(GdipGetPathPointsI(This.Handle, @lcPoints, m.liCount))
		m.lqPoint = SUBSTR(m.lqPoints, (m.tiIndex-1)*8+1, 8)
		m.loPoint = This.CreateNew("xfcPointF", m.lqPoint)
		This.PathPoints[m.tiIndex] = m.loPoint
	ENDIF
CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN m.loPoint

** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.GraphicsPath.PathPoints%28vs.80%29.aspx
** Returns: PointF[]
*********************************************************************

ENDPROC
PROCEDURE pathtypes_access
*********************************************************************
** Property: PathTypes (Access)
**
** Gets the types of the corresponding points in the PathPoints array.
**
** History:
**  2006/03/07: Auto Generated
**	2006/06/11: BDurban - Coded
*********************************************************************
LPARAMETERS m.tiIndex

*!ToDo: Test this function

LOCAL lqTypes, liType

LOCAL loExc AS Exception
TRY
	m.liCount = 0
	m.liByte = 0
	m.tiIndex = NVL(m.tiIndex, 1)
	This.SetStatus(GdipGetPointCount(This.Handle, @liCount))
	IF ALEN(This.PathTypes,1) <> m.liCount
		DIMENSION This.PathTypes[MAX(m.liCount,1)]
		This.PathTypes = 0
	ENDIF
	IF m.tiIndex > m.liCount
		*!ToDo: Error
		m.liType = 0
	ELSE
		m.lqTypes = REPLICATE(0h00,m.liCount)
		This.SetStatus(GdipGetPathTypes(This.Handle, @lqTypes, m.liCount))
		m.liType = ASC(SUBSTR(m.lqTypes, m.tiIndex, 1))
		This.PathTypes[m.tiIndex] = m.liType
	ENDIF
CATCH TO loExc
	THROW m.loExc
ENDTRY
RETURN m.liType

** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.GraphicsPath.PathTypes%28vs.80%29.aspx
** Returns: byte[]
*********************************************************************

ENDPROC
PROCEDURE pointcount_access
*********************************************************************
** Property: PointCount (Access)
**
** Gets the number of elements in the PathPoints or the PathTypes array.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/06: BDurban - Coded
*********************************************************************

*!ToDo: Test this function

LOCAL liCount
m.liCount = 0

LOCAL loExc AS Exception
TRY
	This.SetStatus(GdipGetPointCount(This.Handle, @liCount))

CATCH TO loExc
	THROW m.loExc
ENDTRY
RETURN m.liCount

** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.GraphicsPath.PointCount%28vs.80%29.aspx
** Returns: int
*********************************************************************

ENDPROC
PROCEDURE reset
*********************************************************************
** Method: Reset
**
** Empties the PathPoints and PathTypes arrays and sets the FillMode to Alternate.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/08: BDurban - Coded
*********************************************************************

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY

	This.SetStatus(GdipResetPath(This.Handle))

CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.GraphicsPath.Reset%28vs.80%29.aspx
** Parameters:
**  [None]
** Returns: void
*********************************************************************

ENDPROC
PROCEDURE reverse
*********************************************************************
** Method: Reverse
**
** Reverses the order of points in the PathPoints array of this GraphicsPath object.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/08: BDurban - Coded
*********************************************************************

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY

	This.SetStatus(GdipReversePath(This.Handle))

CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.GraphicsPath.Reverse%28vs.80%29.aspx
** Parameters:
**  [None]
** Returns: void
*********************************************************************

ENDPROC
PROCEDURE setmarkers
*********************************************************************
** Method: SetMarkers
**
** Sets a marker on this GraphicsPath object.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/08: BDurban - Coded
*********************************************************************

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY

	This.SetStatus(GdipSetPathMarker(This.Handle))

CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.GraphicsPath.SetMarkers%28vs.80%29.aspx
** Parameters:
**  [None]
** Returns: void
*********************************************************************

ENDPROC
PROCEDURE startfigure
*********************************************************************
** Method: StartFigure
**
** Starts a new figure without closing the current figure. All subsequent points added
** to the path are added to this new figure.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/08: BDurban - Coded
*********************************************************************

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY

	This.SetStatus(GdipStartPathFigure(This.Handle))

CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.GraphicsPath.StartFigure%28vs.80%29.aspx
** Parameters:
**  [None]
** Returns: void
*********************************************************************

ENDPROC
PROCEDURE transform
*********************************************************************
** Method: Transform
**
** Applies a transform matrix to this GraphicsPath object.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/08: BDurban - Coded
*********************************************************************
LPARAMETERS toMatrix AS xfcMatrix

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY

	This.SetStatus(GdipTransformPath(This.Handle, m.toMatrix.Handle))

CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.GraphicsPath.Transform%28vs.80%29.aspx
** Parameters:
**  Matrix matrix
** Returns: void
*********************************************************************

ENDPROC
PROCEDURE warp
*********************************************************************
** Method: Warp
**
** Applies a warp transform, defined by a rectangle and a parallelogram, to this GraphicsPath
** object.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/08: BDurban - Coded
*********************************************************************
LPARAMETERS taoDestPoints AS xfcPointF, toSrcRect AS xfcRectangleF, ;
			toMatrix AS xfcMatrix, ;
			tiWarpMode AS EnumWarpMode, ;
			tnFlatness

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	LOCAL loPoint AS xfcPoint, liCount, tqPoints
	LOCAL lnSrcx, lnSrcy, lnSrcwidth, lnSrcheight
	LOCAL lhMatrix
	m.loPoint = taoDestPoints.New()
	m.liCount = 0
	m.tqPoints = m.loPoint.ToVarBinary(@taoDestPoints, @liCount)
	m.toSrcRect.GetExtent(@lnSrcx, @lnSrcy, @lnSrcwidth, @lnSrcheight)
	m.lhMatrix = 0
	IF VARTYPE(m.toMatrix) = "O"
		m.lhMatrix = m.toMatrix.Handle
	ENDIF
	m.tnWarpMode = EVL(m.tnWarpMode, WarpModePerspective)
	m.tnFlatness = EVL(m.tnFlatness, 0.00)
	
	This.SetStatus(GdipWarpPath(This.Handle, m.lhMatrix, mlqPoints, m.liCount, m.lnSrcx, m.lnSrcy, m.lnSrcwidth, m.lnSrcheight, m.tiWarpMode, m.tnFlatness))

CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.GraphicsPath.Warp%28vs.80%29.aspx
** Parameters:
**  PointF[] destPoints, RectangleF srcRect
**  PointF[] destPoints, RectangleF srcRect, Matrix matrix
**  PointF[] destPoints, RectangleF srcRect, Matrix matrix, WarpMode warpMode
**  PointF[] destPoints, RectangleF srcRect, Matrix matrix, WarpMode warpMode, float flatness
** Returns: void
*********************************************************************

ENDPROC
PROCEDURE widen
*********************************************************************
** Method: Widen
**
** Replaces this path with curves that enclose the area that is filled when this path
** is drawn by the specified pen.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/08: BDurban - Coded
*********************************************************************
LPARAMETERS toPen AS xfcPen, ;
			toMatrix AS xfcMatrix, ;
			tnFlatness

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	LOCAL m.lhMatrix
	m.lhMatrix = 0
	
	IF VARTYPE(m.toMatrix) = "O"
		m.lhMatrix = m.tomatrix.Handle
	ENDIF
	m.tnFlatness = EVL(m.tnFLatness, 0.00)
	
	This.SetStatus(GdipWidenPath(This.Handle, m.toPen.Handle, m.lhMatrix, m.tnFlatness))

CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.GraphicsPath.Widen%28vs.80%29.aspx
** Parameters:
**  Pen pen
**  Pen pen, Matrix matrix
**  Pen pen, Matrix matrix, float flatness
** Returns: void
*********************************************************************

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
fillmode Gets or sets a FillMode enumeration that determines how the interiors of shapes in this GraphicsPath object are filled.
pathdata Gets a PathData object that encapsulates arrays of points (points) and types (types) for this GraphicsPath object.
pointcount Gets the number of elements in the PathPoints or the PathTypes array.
^pathpoints[1,0] Gets the points in the path.
^pathtypes[1,0] Gets the types of the corresponding points in the PathPoints array.
*addarc Appends an elliptical arc to the current figure.
*addbezier Adds a cubic Bezier curve to the current figure.
*addbeziers Adds a sequence of connected cubic Bezier curves to the current figure.
*addclosedcurve Adds a closed curve to this path. A cardinal spline curve is used because the curve travels through each of the points in the array.
*addcurve Adds a spline curve to the current figure. A cardinal spline curve is used because the curve travels through each of the points in the array.
*addellipse Adds an ellipse to the current path.
*addline Appends a line segment to this GraphicsPath object.
*addlines Appends a series of connected line segments to the end of this GraphicsPath object.
*addpath Appends the specified GraphicsPath object to this path.
*addpie Adds the outline of a pie shape to this path.
*addpolygon Adds a polygon to this path.
*addrectangle Adds a rectangle to this path.
*addrectangles Adds a series of rectangles to this path.
*addstring Adds a text string to this path.
*clearmarkers Clears all markers from this path.
*clone Creates an exact copy of this path.
*closeallfigures Closes all open figures in this path and starts a new figure. It closes each open figure by connecting a line from its endpoint to its starting point.
*closefigure Closes the current figure and starts a new figure. If the current figure contains a sequence of connected lines and curves, the method closes the loop by connecting a line from the endpoint to the starting point.
*flatten Converts each curve in this path into a sequence of connected line segments.
*getbounds Returns a rectangle that bounds this GraphicsPath object.
*getlastpoint Gets the last point in the PathPoints array of this GraphicsPath object.
*isoutlinevisible Indicates whether the specified point is contained within (under) the outline of this GraphicsPath object when drawn with the specified Pen object.
*isvisible Indicates whether the specified point is contained within this GraphicsPath object.
*reset Empties the PathPoints and PathTypes arrays and sets the FillMode to Alternate.
*reverse Reverses the order of points in the PathPoints array of this GraphicsPath object.
*setmarkers Sets a marker on this GraphicsPath object.
*startfigure Starts a new figure without closing the current figure. All subsequent points added to the path are added to this new figure.
*transform Applies a transform matrix to this GraphicsPath object.
*warp Applies a warp transform, defined by a rectangle and a parallelogram, to this GraphicsPath object.
*widen Replaces this path with curves that enclose the area that is filled when this path is drawn by the specified pen.
*fillmode_access 
*fillmode_assign 
*pathdata_access 
*pathpoints_access 
*pathtypes_access 
*pointcount_access 
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED8]
drawing.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] xfcgraphicspath
[START RESERVED1]
 	 drawing.hFZ„M5 system.hN[0•Ô4 gdiplusconstants.hV\Îi05[END RESERVED1]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1QZ0NRS8C
[CLASS] xfcgpobject
[CLASSLOC] drawing.vcx
[BASECLASS] custom
[OBJNAME] xfcgraphicspathiterator
[START PROPERTIES]
count = 0
subpathcount = 0
basename = GraphicsPathIterator
_memberdata =     1293<VFPData><memberdata name="copydata" type="method" display="CopyData"/><memberdata name="createobjref" type="method" display="CreateObjRef"/><memberdata name="dispose" type="method" display="Dispose"/><memberdata name="enumerate" type="method" display="Enumerate"/><memberdata name="equals" type="method" display="Equals"/><memberdata name="gethashcode" type="method" display="GetHashCode"/><memberdata name="getlifetimeservice" type="method" display="GetLifetimeService"/><memberdata name="gettype" type="method" display="GetType"/><memberdata name="hascurve" type="method" display="HasCurve"/><memberdata name="initializelifetimeservice" type="method" display="InitializeLifetimeService"/><memberdata name="nextmarker" type="method" display="NextMarker"/><memberdata name="nextpathtype" type="method" display="NextPathType"/><memberdata name="nextsubpath" type="method" display="NextSubpath"/><memberdata name="rewind" type="method" display="Rewind"/><memberdata name="tostring" type="method" display="ToString"/><memberdata name="finalize" type="method" display="Finalize"/><memberdata name="memberwiseclone" type="method" display="MemberwiseClone"/><memberdata name="count" type="property" display="Count"/><memberdata name="subpathcount" type="property" display="SubpathCount"/></VFPData>
lastresult = 0
Name = "xfcgraphicspathiterator"
[END PROPERTIES]
[START PROTECTED]
_memberdata
[END PROTECTED]
[START METHODS]
PROCEDURE Destroy
*********************************************************************
** Method: Destroy
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/08: BDurban - Coded
*********************************************************************

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
This.SetStatus(GdipDeletePathIter(This.Handle))
CATCH TO loExc
	THROW m.loExc
ENDTRY
RETURN
ENDPROC
PROCEDURE Init
*********************************************************************
** Method: GraphicsPathIterator
**
** Initializes a new instance of the GraphicsPathIterator class with the specified
** GraphicsPath object.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/08: BDurban - Coded
*********************************************************************
LPARAMETERS toPath AS xfcGraphicsPath

LOCAL loExc AS Exception
TRY
	DODEFAULT()
	LOCAL lhPath, lhIterator
	m.lhIterator = 0
	m.lhPath = IIF(VARTYPE(m.toPath)="O", m.toPath.Handle, 0)
	This.SetStatus(GdipCreatePathIter(@lhIterator, m.lhPath))
	This.Handle = m.lhIterator
CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN

** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.GraphicsPathIterator.GraphicsPathIterator%28vs.80%29.aspx
** Parameters:
**  GraphicsPath path
*********************************************************************

ENDPROC
PROCEDURE copydata
*********************************************************************
** Method: CopyData
**
** Copies the PathPoints property and cref="P:System.Drawing.Drawing2D.GraphicsPath.PathTypes"/>
** property arrays of the associated GraphicsPath object into the two specified arrays.
**
** History:
**  2006/03/07: Auto Generated
*********************************************************************
LPARAMETERS taoPoints AS @xfcPointF, tqTypes AS @VarBinary, tiStartIndex, tiEndIndex

*!ToDo: Implement this function
*!ToDo: Test this function
ERROR 1999	&& Function not implemented
RETURN NULL

LOCAL loExc AS Exception
TRY
	LOCAL liValue
	m.liValue = 0
	This.SetStatus(GdipPathIterCopyData(This.Handle, @liResultCount, @lcPoints, @lcTypes, m.liStartIndex, m.liEndIndex))

CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN m.liValue


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.GraphicsPathIterator.CopyData%28vs.80%29.aspx
** Parameters:
**  ref PointF[] points, ref byte[] types, int startIndex, int endIndex
** Returns: int
*********************************************************************

ENDPROC
PROCEDURE count_access
*********************************************************************
** Property: Count (Access)
**
** Gets the number of points in the path.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/08: BDurban - Coded
*********************************************************************

*!ToDo: Test this function

LOCAL liCount
m.liCount = 0

LOCAL loExc AS Exception
TRY
	This.SetStatus(GdipPathIterGetCount(This.Handle, @liCount))

CATCH TO loExc
	THROW m.loExc
ENDTRY
RETURN m.liCount

** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.GraphicsPathIterator.Count%28vs.80%29.aspx
** Returns: int
*********************************************************************

ENDPROC
PROCEDURE declaredll
TRY

xfcGraphicsPathIteratorDeclareDLL(0)

CATCH

DECLARE Long Sleep IN WIN32API AS xfcGraphicsPathIteratorDeclareDLL Long

DECLARE LONG GdipCreatePathIter IN GDIPLUS LONG @iterator, LONG path
DECLARE LONG GdipDeletePathIter IN GDIPLUS LONG iterator
DECLARE LONG GdipPathIterNextSubpath IN GDIPLUS LONG iterator, LONG @resultCount, LONG @startIndex, LONG @endIndex, LONG @isClosed
DECLARE LONG GdipPathIterNextSubpathPath IN GDIPLUS LONG iterator, LONG @resultCount, LONG path, LONG @isClosed
DECLARE LONG GdipPathIterNextPathType IN GDIPLUS LONG iterator, LONG @resultCount, STRING @pathType, LONG @startIndex, LONG @endIndex
DECLARE LONG GdipPathIterNextMarker IN GDIPLUS LONG iterator, LONG @resultCount, LONG @startIndex, LONG @endIndex
DECLARE LONG GdipPathIterNextMarkerPath IN GDIPLUS LONG iterator, LONG @resultCount, LONG path
DECLARE LONG GdipPathIterGetCount IN GDIPLUS LONG iterator, LONG @Count
DECLARE LONG GdipPathIterGetSubpathCount IN GDIPLUS LONG iterator, LONG @Count
DECLARE LONG GdipPathIterHasCurve IN GDIPLUS LONG iterator, LONG @hasCurve
DECLARE LONG GdipPathIterRewind IN GDIPLUS LONG iterator
DECLARE LONG GdipPathIterEnumerate IN GDIPLUS LONG iterator, LONG @resultCount, STRING @pPoint, STRING @types, LONG Count
DECLARE LONG GdipPathIterCopyData IN GDIPLUS LONG iterator, LONG @resultCount, STRING @pPoint, STRING @types, LONG startIndex, LONG endIndex

ENDTRY
ENDPROC
PROCEDURE enumerate
*********************************************************************
** Method: Enumerate
**
** Copies the PathPoints property and PathTypes property arrays of the associated GraphicsPath
** object into the two specified arrays.
**
** History:
**  2006/03/07: Auto Generated
*********************************************************************
LPARAMETERS taoPoints AS xfcPointF, taiTypes AS Byte

*!ToDo: Implement this function
*!ToDo: Test this function
ERROR 1999	&& Function not implemented
RETURN NULL

LOCAL loExc AS Exception
TRY
	LOCAL liCount, liResultCount
	m.liCount = 0
	m.liResultCount = 0
	This.SetStatus(GdipPathIterEnumerate(THIs.Handle, @liResultCount, @lcPoints, @lcTypes, m.liCount))

CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN m.liCount


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.GraphicsPathIterator.Enumerate%28vs.80%29.aspx
** Parameters:
**  ref PointF[] points, ref byte[] types
** Returns: int
*********************************************************************

ENDPROC
PROCEDURE hascurve
*********************************************************************
** Method: HasCurve
**
** Indicates whether the path associated with this GraphicsPathIterator object contains
** a curve.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/08: BDurban - Coded
*********************************************************************

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	LOCAL liHasCurve
	m.liHasCurve = FALSE
	This.SetStatus(GdipPathIterHasCurve(This.Handle, @liHasCurve))

CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN (m.liHasCurve=TRUE)


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.GraphicsPathIterator.HasCurve%28vs.80%29.aspx
** Parameters:
**  [None]
** Returns: bool
*********************************************************************

ENDPROC
PROCEDURE new
LPARAMETERS toPath AS xfcGraphicsPath

RETURN This.CreateNew(This.Class, m.toPath)
ENDPROC
PROCEDURE nextmarker
*********************************************************************
** Method: NextMarker
**
** Moves the iterator to the next marker in the path.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/11: BDurban - Coded
*********************************************************************
LPARAMETERS tiStartIndex, tiEndIndex
*********** toPath AS xfcGraphicsPath

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	LOCAL liResultCount
	m.liResultCount = 0
	
	DO CASE
	CASE VARTYPE(m.tiStartIndex)="O" AND m.tiStartIndex.BaseName == "GraphicsPath"
		m.loPath = m.tiStartIndex
		This.SetStatus(GdipPathIterNextMarkerPath(This.Handle, @liResultCount, m.loPath.Handle))
		
	OTHERWISE
		This.SetStatus(GdipPathIterNextMarker(This.Handle, @liResultCount, @tiStartIndex, @tiEndIndex))
		
	ENDCASE

CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN m.liResultCount


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.GraphicsPathIterator.NextMarker%28vs.80%29.aspx
** Parameters:
**  GraphicsPath path
**  out int startIndex, out int endIndex
** Returns: int
*********************************************************************

ENDPROC
PROCEDURE nextpathtype
*********************************************************************
** Method: NextPathType
**
** Gets the starting index and the ending index of the next group of data points that
** all have the same type.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/11: BDurban - Coded
*********************************************************************
LPARAMETERS tiPathType, tiStartIndex, tiEndIndex

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	LOCAL liResultCount, lqPathType
	m.liResultCount = 0
	m.lqPathType = 0h00
	This.SetStatus(GdipPathIterNextPathType(This.Handle, @liResultCount, @lqPathType, @tiStartIndex, @tiEndIndex))
	
	m.tiPathType = ASC(lqPathType)

CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN m.liResultCount


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.GraphicsPathIterator.NextPathType%28vs.80%29.aspx
** Parameters:
**  out byte pathType, out int startIndex, out int endIndex
** Returns: int
*********************************************************************

ENDPROC
PROCEDURE nextsubpath
*********************************************************************
** Method: NextSubpath
**
** Moves the subpath to the next subpath in the specified GraphicsPath object.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/08: BDurban - Coded
*********************************************************************
LPARAMETERS tiStartIndex, tiEndIndex, tlIsClosed
*********** toPath AS xfcGraphicsPath, tBool AS out

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	LOCAL liResultCount, liIsClosed
	LOCAL loPath AS xfcGraphicsPath
	m.liResultCount = 0
	
	DO CASE
	CASE VARTYPE(m.tiStartIndex)="O"
		m.loPath = m.tiStartIndex
		m.tlIsClosed = m.tiEndIndex
		This.SetStatus(GdipPathIterNextSubpathPath(This.Handle, @liResultCount, m.lhPath, @liIsClosed))
		m.tlIsClosed = (m.liIsClosed=TRUE)
	
	OTHERWISE
		This.SetStatus(GdipPathIterNextSubpath(This.Handle, @liResultCount, @tiStartIndex, @tiEndIndex, @liIsClosed))
		m.tlIsClosed = (m.liIsClosed=TRUE)
	ENDCASE

CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN m.liResultCount


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.GraphicsPathIterator.NextSubpath%28vs.80%29.aspx
** Parameters:
**  GraphicsPath path, out bool isClosed
**  out int startIndex, out int endIndex, out bool isClosed
** Returns: int
*********************************************************************

ENDPROC
PROCEDURE rewind
*********************************************************************
** Method: Rewind
**
** Rewinds this GraphicsPathIterator object to the beginning of its associated path.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/08: BDurban - Coded
*********************************************************************

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY

	This.SetStatus(GdipPathIterRewind(This.Handle))

CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.GraphicsPathIterator.Rewind%28vs.80%29.aspx
** Parameters:
**  [None]
** Returns: void
*********************************************************************

ENDPROC
PROCEDURE subpathcount_access
*********************************************************************
** Property: SubpathCount (Access)
**
** Gets the number of subpaths in the path.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/08: BDurban - Coded
*********************************************************************

*!ToDo: Test this function

LOCAL liCount
m.liCount = 0

LOCAL loExc AS Exception
TRY
	This.SetStatus(GdipPathIterGetSubpathCount(This.Handle, @liCount))

CATCH TO loExc
	THROW m.loExc
ENDTRY
RETURN m.liCount

** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.GraphicsPathIterator.SubpathCount%28vs.80%29.aspx
** Returns: int
*********************************************************************

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
count Gets the number of points in the path.
subpathcount Gets the number of subpaths in the path.
basename
*copydata Copies the PathPoints property and cref="P:System.Drawing.Drawing2D.GraphicsPath.PathTypes"/> property arrays of the associated GraphicsPath object into the two specified arrays.
*enumerate Copies the PathPoints property and PathTypes property arrays of the associated GraphicsPath object into the two specified arrays.
*hascurve Indicates whether the path associated with this GraphicsPathIterator object contains a curve.
*nextmarker Moves the iterator to the next marker in the path.
*nextpathtype Gets the starting index and the ending index of the next group of data points that all have the same type.
*nextsubpath Moves the subpath to the next subpath in the specified GraphicsPath object.
*rewind Rewinds this GraphicsPathIterator object to the beginning of its associated path.
*count_access 
*subpathcount_access 
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED8]
drawing.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] xfcgraphicspathiterator
[START RESERVED1]
 	 drawing.hﬁ„„M5 system.hÊ‰0•Ô4 gdiplusconstants.hÓÂÎi05[END RESERVED1]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1QZ0NRSNJ
[CLASS] xfcdrawingbase
[CLASSLOC] drawing.vcx
[BASECLASS] custom
[OBJNAME] xfcgraphicsstate
[START PROPERTIES]
basename = GraphicsState
handle = 0
_memberdata =      653<VFPData><memberdata name="createobjref" type="method" display="CreateObjRef"/><memberdata name="equals" type="method" display="Equals"/><memberdata name="gethashcode" type="method" display="GetHashCode"/><memberdata name="getlifetimeservice" type="method" display="GetLifetimeService"/><memberdata name="gettype" type="method" display="GetType"/><memberdata name="initializelifetimeservice" type="method" display="InitializeLifetimeService"/><memberdata name="tostring" type="method" display="ToString"/><memberdata name="finalize" type="method" display="Finalize"/><memberdata name="memberwiseclone" type="method" display="MemberwiseClone"/></VFPData>
Name = "xfcgraphicsstate"
[END PROPERTIES]
[START PROTECTED]
_memberdata
[END PROTECTED]
[START METHODS]
PROCEDURE Destroy
*********************************************************************
** Method: Destroy
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/01: BDurban - Coded
*********************************************************************
RETURN
ENDPROC
PROCEDURE Init
*********************************************************************
** Method: GraphicsState
**
** Represents the state of a Graphics object. This object is returned by a call to
** the BeginContainer methods. This class cannot be inherited.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/01: BDurban - Coded
*********************************************************************

** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.GraphicsState%28vs.80%29.aspx
** Parameters:

*********************************************************************

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
basename
handle
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED8]
drawing.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] xfcgraphicsstate
[START RESERVED1]
 	 drawing.hﬁ„„M5 system.hÊ‰0•Ô4 gdiplusconstants.hÓÂÎi05[END RESERVED1]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1QZ0NRTK3
[CLASS] xfcgpobject
[CLASSLOC] drawing.vcx
[BASECLASS] custom
[OBJNAME] xfcmatrix
[START PROPERTIES]
isidentity = 0
isinvertible = 0
offsetx = 0
offsety = 0
_memberdata =     1723<VFPData><memberdata name="clone" type="method" display="Clone"/><memberdata name="createobjref" type="method" display="CreateObjRef"/><memberdata name="dispose" type="method" display="Dispose"/><memberdata name="equals" type="method" display="Equals"/><memberdata name="gethashcode" type="method" display="GetHashCode"/><memberdata name="getlifetimeservice" type="method" display="GetLifetimeService"/><memberdata name="gettype" type="method" display="GetType"/><memberdata name="initializelifetimeservice" type="method" display="InitializeLifetimeService"/><memberdata name="invert" type="method" display="Invert"/><memberdata name="multiply" type="method" display="Multiply"/><memberdata name="reset" type="method" display="Reset"/><memberdata name="rotate" type="method" display="Rotate"/><memberdata name="rotateat" type="method" display="RotateAt"/><memberdata name="scale" type="method" display="Scale"/><memberdata name="shear" type="method" display="Shear"/><memberdata name="tostring" type="method" display="ToString"/><memberdata name="transformpoints" type="method" display="TransformPoints"/><memberdata name="transformvectors" type="method" display="TransformVectors"/><memberdata name="translate" type="method" display="Translate"/><memberdata name="finalize" type="method" display="Finalize"/><memberdata name="memberwiseclone" type="method" display="MemberwiseClone"/><memberdata name="elements" type="property" display="Elements"/><memberdata name="isidentity" type="property" display="IsIdentity"/><memberdata name="isinvertible" type="property" display="IsInvertible"/><memberdata name="offsetx" type="property" display="OffsetX"/><memberdata name="offsety" type="property" display="OffsetY"/></VFPData>
basename = Matrix
lastresult = 0
Name = "xfcmatrix"
[END PROPERTIES]
[START PROTECTED]
_memberdata
[END PROTECTED]
[START METHODS]
PROCEDURE Destroy
*********************************************************************
** Method: Destroy
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/08: BDurban - Coded
*********************************************************************

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
This.SetStatus(GdipDeleteMatrix(This.Handle))
CATCH TO loExc
	THROW m.loExc
ENDTRY
RETURN
ENDPROC
PROCEDURE Init
*********************************************************************
** Method: Matrix
**
** Initializes a new instance of the Matrix class.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/02: BDurban - Coded
*********************************************************************
LPARAMETERS tnM11, tnM12, tnM21, tnM22, tnDx, tnDy
*********** toRect AS xfcRectangle, taoPlgpts AS xfcPoint

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	DODEFAULT()
	
	LOCAL lhMatrix, lqPoints, liCount, loPoint AS xfcPoint
	m.lhMatrix = 0
	m.liCount = 0
	m.lqPoints = 0h
	
	DO CASE
	CASE VARTYPE(m.tnM11)+VARTYPE(m.tnM12)+VARTYPE(m.tnM21)+VARTYPE(m.tnM22) == "NNNN"
		This.SetStatus(GdipCreateMatrix2(m.tnM11, m.tnM12, m.tnM21, m.tnM22, m.tnDx, m.tnDy, @lhMatrix))
		
	CASE VARTYPE(m.tnM11) = "O" AND m.tnM11.ClassName = "RectangleF" AND TYPE("m.tnM12[1]") = "O"
		m.loRect = m.tnM11
		m.loPoint = This.CreateNew("xfcPointF")
		m.lqPoints = m.loPoint.ToVarBinary(@tnM12, @liCount)
		IF m.liCount = 3
			This.SetStatus(GdipCreateMatrix3(m.loRect.ToVarBinary(), m.lqPoints, @lhMatrix))
		ENDIF
		
	CASE VARTYPE(m.tnM11) = "O" AND m.tnM11.ClassName = "Rectangle" AND TYPE("m.tnM12[1]") = "O"
		m.loRect = m.tnM11
		m.loPoint = This.CreateNew("xfcPoint")
		m.lqPoints = m.loPoint.ToVarBinary(@tnM12, @liCount)
		IF m.liCount = 3
			This.SetStatus(GdipCreateMatrix3I(m.loRect.ToVarBinary(), m.lqPoints, @lhMatrix))
		ENDIF
		
	OTHERWISE
		This.SetStatus(GdipCreateMatrix(@lhMatrix))
		
	ENDCASE
	
	This.Handle = m.lhMatrix
	
CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN

** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.Matrix.Matrix%28vs.80%29.aspx
** Parameters:
**  [None]
**  Rectangle rect, Point[] plgpts
**  RectangleF rect, PointF[] plgpts
**  float m11, float m12, float m21, float m22, float dx, float dy
*********************************************************************

ENDPROC
PROCEDURE clone
*********************************************************************
** Method: Clone
**
** Creates an exact copy of this Matrix object.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/02: BDurban - Coded
*********************************************************************

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	LOCAL loMatrix, lhMatrix
	m.lhMatrix = 0
	m.loMatrix = NULL
	This.SetStatus(GdipCloneMatrix(This.Handle, @lhMatrix))
	IF(m.lhMatrix <> 0)
		m.loMatrix = This.CreateNew(This.Class)
		m.loMatrix.Handle = m.lhMatrix
	ENDIF
CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN m.loMatrix


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.Matrix.Clone%28vs.80%29.aspx
** Parameters:
**  [None]
** Returns: Matrix
*********************************************************************

ENDPROC
PROCEDURE declaredll

TRY

xfcMatrixDeclareDLL(0)

CATCH

DECLARE Long Sleep IN WIN32API AS xfcMatrixDeclareDLL Long

DECLARE LONG GdipCreateMatrix IN GDIPLUS LONG @matrix
DECLARE LONG GdipCreateMatrix2 IN GDIPLUS SINGLE m11, SINGLE m12, SINGLE m21, SINGLE m22, SINGLE dx, SINGLE dy, LONG @matrix
DECLARE LONG GdipCreateMatrix3 IN GDIPLUS STRING Rect, STRING dstplg, LONG @matrix
DECLARE LONG GdipCreateMatrix3I IN GDIPLUS STRING Rect, STRING dstplg, LONG @matrix
DECLARE LONG GdipCloneMatrix IN GDIPLUS LONG matrix, LONG @cloneMatrix
DECLARE LONG GdipDeleteMatrix IN GDIPLUS LONG matrix
DECLARE LONG GdipSetMatrixElements IN GDIPLUS LONG matrix, SINGLE m11, SINGLE m12, SINGLE m21, SINGLE m22, SINGLE dx, SINGLE dy
DECLARE LONG GdipMultiplyMatrix IN GDIPLUS LONG matrix, LONG matrix2, LONG order
DECLARE LONG GdipTranslateMatrix IN GDIPLUS LONG matrix, SINGLE offsetX, SINGLE offsetY, LONG order
DECLARE LONG GdipScaleMatrix IN GDIPLUS LONG matrix, SINGLE scaleX, SINGLE scaleY, LONG order
DECLARE LONG GdipRotateMatrix IN GDIPLUS LONG matrix, SINGLE angle, LONG order
DECLARE LONG GdipShearMatrix IN GDIPLUS LONG matrix, SINGLE shearX, SINGLE shearY, LONG order
DECLARE LONG GdipInvertMatrix IN GDIPLUS LONG matrix
DECLARE LONG GdipTransformMatrixPoints IN GDIPLUS LONG matrix, STRING @pts, LONG Count
DECLARE LONG GdipTransformMatrixPointsI IN GDIPLUS LONG matrix, STRING @pts, LONG Count
DECLARE LONG GdipVectorTransformMatrixPoints IN GDIPLUS LONG matrix, STRING @pts, LONG Count
DECLARE LONG GdipVectorTransformMatrixPointsI IN GDIPLUS LONG matrix, STRING @pts, LONG Count
DECLARE LONG GdipGetMatrixElements IN GDIPLUS LONG matrix, String @matrixOut
DECLARE LONG GdipIsMatrixInvertible IN GDIPLUS LONG matrix, LONG @result
DECLARE LONG GdipIsMatrixIdentity IN GDIPLUS LONG matrix, LONG @result
DECLARE LONG GdipIsMatrixEqual IN GDIPLUS LONG matrix, LONG matrix2, LONG @result

ENDTRY
ENDPROC
PROCEDURE elements_access
*********************************************************************
** Property: Elements (Access)
**
** Gets an array of floating-point values that represents the elements of this Matrix
** object.
**
** History:
**  2006/03/07: Auto Generated
**	2006/08/05: BDurban - Coded
*********************************************************************
LPARAMETERS tiIndex

*!ToDo: Test this function

LOCAL leValue, lqMatrix
m.leValue = 0.0

LOCAL loExc AS Exception
TRY
	DIMENSION This.Elements[6]
	This.Elements = 0.0
	
	m.lqMatrix = REPLICATE(EMPTY_FLOAT,6)
	This.SetStatus(GdipGetMatrixElements(This.Handle, @m.lqMatrix))
	
	DO CASE
	CASE VARTYPE(m.tiIndex) = "Q"
		m.leValue = m.lqMatrix
		
	CASE VARTYPE(m.tiIndex) = "N"
		IF BETWEEN(m.tiIndex,1,6)
			m.leValue = CTOBIN(SUBSTR(m.lqMatrix, (m.tiIndex-1)*4+1, 4), "n")
		ELSE
			*!ToDo: Error
		ENDIF
	OTHERWISE
		*!ToDo: Error
	ENDCASE

CATCH TO loExc
	THROW m.loExc
ENDTRY
RETURN m.leValue

** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.Matrix.Elements%28vs.80%29.aspx
** Returns: float[]
*********************************************************************

ENDPROC
PROCEDURE equals
*********************************************************************
** Method: Equals
**
** Tests whether the specified object is a Matrix object and is identical to this Matrix
** object.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/11: BDurban - Coded
*********************************************************************
LPARAMETERS toMatrix2 AS xfcMatrix

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	LOCAL liResult
	m.liResult = FALSE
	This.SetStatus(GdipIsMatrixEqual(This.Handle, m.toMatrix2.Handle, @liResult))

CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN (m.liResult = TRUE)


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.Matrix.Equals%28vs.80%29.aspx
** Parameters:
**  object obj
** Returns: bool
*********************************************************************

ENDPROC
PROCEDURE gethashcode
*********************************************************************
** Method: GetHashCode
**
** Returns a hash code.
**
** History:
**  2006/03/07: Auto Generated
*********************************************************************

*!ToDo: Implement this function
*!ToDo: Test this function
ERROR 1999	&& Function not implemented
RETURN NULL

LOCAL loExc AS Exception
TRY
	LOCAL liValue
	m.liValue = 0
	** This.SetStatus(GdipSomeFunction???())

CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN m.liValue


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.Matrix.GetHashCode%28vs.80%29.aspx
** Parameters:
**  [None]
** Returns: int
*********************************************************************

ENDPROC
PROCEDURE invert
*********************************************************************
** Method: Invert
**
** Inverts this Matrix object, if it is invertible.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/11: BDurban - Coded
*********************************************************************

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY

	This.SetStatus(GdipInvertMatrix(This.Handle))

CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.Matrix.Invert%28vs.80%29.aspx
** Parameters:
**  [None]
** Returns: void
*********************************************************************

ENDPROC
PROCEDURE isidentity_access
*********************************************************************
** Property: IsIdentity (Access)
**
** Gets a value indicating whether this Matrix object is the identity matrix.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/11: BDurban - Coded
*********************************************************************

*!ToDo: Test this function

LOCAL liResult
m.liResult = FALSE

LOCAL loExc AS Exception
TRY
	This.SetStatus(GdipIsMatrixIdentity(This.Handle, @liResult))

CATCH TO loExc
	THROW m.loExc
ENDTRY
RETURN (m.liResult = TRUE)

** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.Matrix.IsIdentity%28vs.80%29.aspx
** Returns: bool
*********************************************************************

ENDPROC
PROCEDURE isinvertible_access
*********************************************************************
** Property: IsInvertible (Access)
**
** Gets a value indicating whether this Matrix object is invertible.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/11: BDurban - Coded
*********************************************************************

*!ToDo: Test this function

LOCAL liResult
m.liResult = FALSE

LOCAL loExc AS Exception
TRY
	This.SetStatus(GdipIsMatrixInvertible(This.Handle, @liResult))

CATCH TO loExc
	THROW m.loExc
ENDTRY
RETURN (m.liResult = TRUE)

** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.Matrix.IsInvertible%28vs.80%29.aspx
** Returns: bool
*********************************************************************

ENDPROC
PROCEDURE multiply
*********************************************************************
** Method: Multiply
**
** Multiplies this Matrix object by the specified Matrix object by prepending the specified
** Matrix.
**
** History:
**  2006/03/07: Auto Generated
**	2006/04/25: BDurban - Coded
*********************************************************************
LPARAMETERS toMatrix AS xfcMatrix, tiOrder AS EnumMatrixOrder

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	m.tiOrder = EVL(tiOrder, 0)
	This.SetStatus(GdipMultiplyMatrix(This.Handle, m.toMatrix.Handle, m.tiOrder))

CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.Matrix.Multiply%28vs.80%29.aspx
** Parameters:
**  Matrix matrix
**  Matrix matrix, MatrixOrder order
** Returns: void
*********************************************************************

ENDPROC
PROCEDURE new
LPARAMETERS tnM11, tnM12, tnM21, tnM22, tnDx, tnDy
RETURN This.CreateNew(This.Class, m.tnM11, m.tnM12, m.tnM21, m.tnM22, m.tnDx, m.tnDy)
ENDPROC
PROCEDURE offsetx_access
*********************************************************************
** Property: OffsetX (Access)
**
** Gets the x translation value (the dx value, or the element in the third row and
** first column) of this Matrix object.
**
** History:
**  2006/03/07: Auto Generated
**	2006/08/05: BDurban - Coded
*********************************************************************

*!ToDo: Test this function

RETURN This.Elements[5]

** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.Matrix.OffsetX%28vs.80%29.aspx
** Returns: float
*********************************************************************

ENDPROC
PROCEDURE offsety_access
*********************************************************************
** Property: OffsetY (Access)
**
** Gets the y translation value (the dy value, or the element in the third row and
** second column) of this Matrix.
**
** History:
**  2006/03/07: Auto Generated
**	2006/08/05: BDurban - Coded
*********************************************************************

*!ToDo: Test this function

RETURN This.Elements[6]

** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.Matrix.OffsetY%28vs.80%29.aspx
** Returns: float
*********************************************************************

ENDPROC
PROCEDURE reset
*********************************************************************
** Method: Reset
**
** Resets this Matrix object to have the elements of the identity matrix.
**
** History:
**  2006/03/07: Auto Generated
**  2006/08/03: CChalom - Coded
*********************************************************************
*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	This.SetStatus(GdipSetMatrixElements(This.Handle, 1, 0, 0, 1, 0, 0))
CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.Matrix.Reset%28vs.80%29.aspx
** Parameters:
**  [None]
** Returns: void
*********************************************************************

ENDPROC
PROCEDURE rotate
*********************************************************************
** Method: Rotate
**
** Applies a clockwise rotation of the specified angle about the origin to this Matrix
** object.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/11: BDurban - Coded
*********************************************************************
LPARAMETERS tnAngle, ;
			tiOrder AS EnumMatrixOrder

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	m.tiOrder = EVL(m.tiOrder, MatrixOrderPrepend)
	This.SetStatus(GdipRotateMatrix(This.Handle, m.tnAngle, m.tiOrder))

CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.Matrix.Rotate%28vs.80%29.aspx
** Parameters:
**  float angle
**  float angle, MatrixOrder order
** Returns: void
*********************************************************************

ENDPROC
PROCEDURE rotateat
*********************************************************************
** Method: RotateAt
**
** Applies a clockwise rotation about the specified point to this Matrix object by
** prepending the rotation.
**
** History:
** 2006/03/07: Auto Generated
** 2006/08/05: CChalom - Coded
*********************************************************************
LPARAMETERS tnAngle, toPoint AS xfcPointF, tiOrder AS EnumMatrixOrder
*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
m.tiOrder = EVL(m.tiOrder, MatrixOrderPrepend)
IF m.tiOrder == MatrixOrderPrepend
	This.SetStatus(GdipTranslateMatrix(This.Handle, toPoint.X, toPoint.Y, m.tiOrder))
	This.SetStatus(GdipRotateMatrix(This.Handle, m.tnAngle, m.tiOrder))
	This.SetStatus(GdipTranslateMatrix(This.Handle, - toPoint.X, -toPoint.Y, m.tiOrder))
ELSE
	This.SetStatus(GdipTranslateMatrix(This.Handle, - toPoint.X, -toPoint.Y, m.tiOrder))
	This.SetStatus(GdipRotateMatrix(This.Handle, m.tnAngle, m.tiOrder))
	This.SetStatus(GdipTranslateMatrix(This.Handle, toPoint.X, toPoint.Y, m.tiOrder))
ENDIF
CATCH TO loExc
	THROW m.loExc
ENDTRY
RETURN NULL

** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.Matrix.RotateAt%28vs.80%29.aspx
** Parameters:
** float angle, PointF point
** float angle, PointF point, MatrixOrder order
** Returns: void
*********************************************************************

ENDPROC
PROCEDURE scale
*********************************************************************
** Method: Scale
**
** Applies the specified scale vector to this Matrix object by prepending the scale
** vector.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/11: BDurban - Coded
*********************************************************************
LPARAMETERS tnScaleX, tnScaleY, ;
			tiOrder AS EnumMatrixOrder

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	m.tiOrder = EVL(m.tiOrder, MatrixOrderPrepend)
	This.SetStatus(GdipScaleMatrix(This.Handle, m.tnScaleX, m.tnScaleY, m.tiOrder))

CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.Matrix.Scale%28vs.80%29.aspx
** Parameters:
**  float scaleX, float scaleY
**  float scaleX, float scaleY, MatrixOrder order
** Returns: void
*********************************************************************

ENDPROC
PROCEDURE shear
*********************************************************************
** Method: Shear
**
** Applies the specified shear vector to this Matrix by prepending the shear vector.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/11: BDurban - Coded
*********************************************************************
LPARAMETERS tnShearX, tnShearY, ;
			tiOrder AS EnumMatrixOrder

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	m.tiOrder = EVL(m.tiOrder, MatrixOrderPrepend)
	This.SetStatus(GdipShearMatrix(This.Handle, m.tnShearX, m.tnShearY, m.tiOrder))

CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.Matrix.Shear%28vs.80%29.aspx
** Parameters:
**  float shearX, float shearY
**  float shearX, float shearY, MatrixOrder order
** Returns: void
*********************************************************************

ENDPROC
PROCEDURE transformpoints
*********************************************************************
** Method: TransformPoints
**
** Applies the geometric transform this Matrix object represents to an array of points.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/11: BDurban - Coded
*********************************************************************
LPARAMETERS taoPts AS xfcPoint

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	LOCAL loPoint AS xfcPoint, lqPoints, liCount
	DO CASE
	CASE VARTYPE(m.taoPts)="O" AND m.taoPts.BaseName == "PointF"
		m.loPoint = This.CreateNew("xfcPointF")
		m.lqPoints = m.loPoint.ToVarBinary(@m.taoPts, @liCount)
		This.SetStatus(GdipTransformMatrixPoints(This.Handle, m.lqPoints, m.liCount))
		
	CASE VARTYPE(m.taoPts)="O" AND m.taoPts.BaseName == "Point"
		m.loPoint = This.CreateNew("xfcPoint")
		m.lqPoints = m.loPoint.ToVarBinary(@m.taoPts, @liCount)
		This.SetStatus(GdipTransformMatrixPointsI(This.Handle, m.lqPoints, m.liCount))
	
	OTHERWISE
		*!ToDo: Error handling?

	ENDCASE
	m.loPoint = NULL

CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.Matrix.TransformPoints%28vs.80%29.aspx
** Parameters:
**  Point[] pts
**  PointF[] pts
** Returns: void
*********************************************************************

ENDPROC
PROCEDURE transformvectors
*********************************************************************
** Method: TransformVectors
**
** Multiplies each vector in an array by the matrix. The translation elements of this
** matrix (third row) are ignored.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/11: BDurban - Coded
*********************************************************************
LPARAMETERS taoPts AS xfcPoint

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	LOCAL loPoint AS xfcPoint, lqPoints, liCount
	DO CASE
	CASE VARTYPE(m.taoPts)="O" AND m.taoPts.BaseName == "PointF"
		m.loPoint = This.CreateNew("xfcPointF")
		m.lqPoints = m.loPoint.ToVarBinary(@m.taoPts, @liCount)
		This.SetStatus(GdipVectorTransformMatrixPoints(This.Handle, m.lqPoints, m.liCount))
		
	CASE VARTYPE(m.taoPts)="O" AND m.taoPts.BaseName == "Point"
		m.loPoint = This.CreateNew("xfcPoint")
		m.lqPoints = m.loPoint.ToVarBinary(@m.taoPts, @liCount)
		This.SetStatus(GdipVectorTransformMatrixPointsI(This.Handle, m.lqPoints, m.liCount))
	
	OTHERWISE
		*!ToDo: Error handling?

	ENDCASE

CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.Matrix.TransformVectors%28vs.80%29.aspx
** Parameters:
**  Point[] pts
**  PointF[] pts
** Returns: void
*********************************************************************

ENDPROC
PROCEDURE translate
*********************************************************************
** Method: Translate
**
** Applies the specified translation vector to this Matrix object by prepending the
** translation vector.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/11: BDurban - Coded
*********************************************************************
LPARAMETERS tnOffsetX, tnOffsetY, ;
			tiOrder AS EnumMatrixOrder

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	m.tiOrder = EVL(m.tiOrder, MatrixOrderPrepend)
	This.SetStatus(GdipTranslateMatrix(This.Handle, m.tnOffsetX, m.tnOffsetY, m.tiOrder))

CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.Matrix.Translate%28vs.80%29.aspx
** Parameters:
**  float offsetX, float offsetY
**  float offsetX, float offsetY, MatrixOrder order
** Returns: void
*********************************************************************

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
isidentity Gets a value indicating whether this Matrix object is the identity matrix.
isinvertible Gets a value indicating whether this Matrix object is invertible.
offsetx Gets the x translation value (the dx value, or the element in the third row and first column) of this Matrix object.
offsety Gets the y translation value (the dy value, or the element in the third row and second column) of this Matrix.
^elements[1,0] Gets an array of floating-point values that represents the elements of this Matrix object.
*clone Creates an exact copy of this Matrix object.
*invert Inverts this Matrix object, if it is invertible.
*multiply Multiplies this Matrix object by the specified Matrix object by prepending the specified Matrix.
*reset Resets this Matrix object to have the elements of the identity matrix.
*rotate Applies a clockwise rotation of the specified angle about the origin to this Matrix object.
*rotateat Applies a clockwise rotation about the specified point to this Matrix object by prepending the rotation.
*scale Applies the specified scale vector to this Matrix object by prepending the scale vector.
*shear Applies the specified shear vector to this Matrix by prepending the shear vector.
*transformpoints Applies the geometric transform this Matrix object represents to an array of points.
*transformvectors Multiplies each vector in an array by the matrix. The translation elements of this matrix (third row) are ignored.
*translate Applies the specified translation vector to this Matrix object by prepending the translation vector.
*elements_access 
*isidentity_access 
*isinvertible_access 
*offsetx_access 
*offsety_access 
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED8]
drawing.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] xfcmatrix
[START RESERVED1]
 	 drawing.h—„M5 system.h“0•Ô4 gdiplusconstants.h”Îi05[END RESERVED1]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1QZ0NRU3M
[CLASS] xfcdrawingbase
[CLASSLOC] drawing.vcx
[BASECLASS] custom
[OBJNAME] xfcpathdata
[START PROPERTIES]
basename = PathData
_count = 0
_memberdata =      523<VFPData><memberdata name="equals" type="method" display="Equals"/><memberdata name="gethashcode" type="method" display="GetHashCode"/><memberdata name="gettype" type="method" display="GetType"/><memberdata name="tostring" type="method" display="ToString"/><memberdata name="finalize" type="method" display="Finalize"/><memberdata name="memberwiseclone" type="method" display="MemberwiseClone"/><memberdata name="points" type="property" display="Points"/><memberdata name="types" type="property" display="Types"/></VFPData>
Name = "xfcpathdata"
[END PROPERTIES]
[START PROTECTED]
_count
_memberdata
[END PROTECTED]
[START METHODS]
PROCEDURE Init
*********************************************************************
** Method: PathData
**
** Initializes a new instance of the PathData class.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/11: BDurban - Coded
*********************************************************************
LPARAMETERS lqBinary

*!ToDo: Test this function
LOCAL lnLoop, lqPoint, liOffset

LOCAL loExc AS Exception
TRY
	DODEFAULT()
	
	DO CASE
	CASE VARTYPE(m.lqBinary) = "Q"
		m.liOffset = 1
	
		This._count = CTOBIN(SUBSTR(m.lqBinary,1,4),"4rs")
		m.liOffset = m.liOffset + 1
		
		IF This._count < 1
			DIMENSION This.Points[1], This.Types[1]
			This._count = 0
			This.Points = NULL
			This.Types = NULL
		ELSE	
			DIMENSION This.Points[This._count], This.Types[This._count]		
			FOR m.lnLoop = 1 TO This._count
				lqPoint = SUBSTR(m.lqBinary, m.liOffset, LEN(EMPTY_POINTF))
				This.Points[m.lnLoop]=This.CreateNew("xfcPointF",m.lqPoint)
				m.liOffset = m.liOffset + LEN(EMPTY_POINTF)
			ENDFOR
				
			FOR m.lnLoop = 1 TO This._count
				This.Types[m.lnLoop]=ASC(SUBSTR(m.lqBinary, m.liOffset, 1))
				m.liOffset = m.liOffset + 1
			ENDFOR
		ENDIF
		
	OTHERWISE
		DIMENSION This.Points[1], This.Types[1]
		This._count = 0
		This.Points = NULL
		This.Types = NULL
	ENDCASE
	
CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN

** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.PathData.PathData%28vs.80%29.aspx
** Parameters:
**  [None]
*********************************************************************

ENDPROC
PROCEDURE new
LPARAMETERS lqBinary

RETURN THis.CreateNew(This.Class, m.lqBinary)
ENDPROC
PROCEDURE points_assign
*********************************************************************
** Property: Points (Assign)
**
** Gets or sets an array of PointF structures that represents the points through which
** the path is constructed.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/11: BDurban - Coded
*********************************************************************
LPARAMETERS toPnt AS xfcPointF, tiIndex1

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	DO CASE
	CASE ISNULL(m.tiIndex)
		This.Points = m.toPnt
		
	CASE VARTYPE(m.toPnt)="O" AND m.toPnt.BaseName=="PointF"
		IF m.tiIndex > This._count
			This._count = m.tiIndex
		ENDIF
		This.Points[m.tiIndex] = m.toPnt
	OTHERWISE
		*!ToDo: Error handling?
	ENDCASE
CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL

ENDPROC
PROCEDURE tovarbinary
*********************************************************************
** Method: ToVarbinary
**
** Returns a binary representation of this PathData class
**
** History:
**  2006/05/11: BDurban - Coded
**  2006/07/08: BDurban - Changed method name
*********************************************************************
LOCAL lqBinary, liCount, lnLoop, loPnt AS xfcPointF, liType AS Byte

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	
	m.liCount = This._count
	m.lqBinary = BINTOC(m.liCount, "4rs")

	FOR m.lnLoop = 1 TO m.liCount
		m.lqBinary = m.lqBinary + This.Points[m.lnLoop].ToVarbinary()
	ENDFOR

	FOR m.lnLoop = 1 TO m.liCount
		m.lqBinary = m.lqBinary + CHR(This.Types[m.lnLoop])
	ENDFOR
	
CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN m.lqBinary

ENDPROC
PROCEDURE types_assign
*********************************************************************
** Property: Types (Assign)
**
** Gets or sets the types of the corresponding points in the path.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/11: BDurban - Coded
*********************************************************************
LPARAMETERS tiType AS Byte, tiIndex1

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	DO CASE
	CASE ISNULL(m.tiIndex)
		This.Types = m.tiType
	OTHERWISE
		*!ToDo: Error handling?
	ENDCASE
CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
basename
_count
*tovarbinary 
^points[1,0] Gets or sets an array of PointF structures that represents the points through which the path is constructed.
*points_assign 
^types[1,0] Gets or sets the types of the corresponding points in the path.
*types_assign 
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED8]
drawing.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] xfcpathdata
[START RESERVED1]
 	 drawing.hﬁ„„M5 system.hÊ‰0•Ô4 gdiplusconstants.hÓÂÎi05[END RESERVED1]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1QZ0NRUVU
[CLASS] xfcdrawingbase
[CLASSLOC] drawing.vcx
[BASECLASS] custom
[OBJNAME] xfcregiondata
[START PROPERTIES]
data = 0
_memberdata =      461<VFPData><memberdata name="equals" type="method" display="Equals"/><memberdata name="gethashcode" type="method" display="GetHashCode"/><memberdata name="gettype" type="method" display="GetType"/><memberdata name="tostring" type="method" display="ToString"/><memberdata name="finalize" type="method" display="Finalize"/><memberdata name="memberwiseclone" type="method" display="MemberwiseClone"/><memberdata name="data" type="property" display="Data"/></VFPData>
basename = RegionData
Name = "xfcregiondata"
[END PROPERTIES]
[START PROTECTED]
_memberdata
[END PROTECTED]
[START METHODS]
PROCEDURE Init
*********************************************************************
** Method: RegionData
**
** Encapsulates the data that makes up a Region object. This class cannot be inherited.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/03: BDurban - Coded
*********************************************************************

*!ToDo: Test this function

RETURN

** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.RegionData%28vs.80%29.aspx
** Parameters:

*********************************************************************

ENDPROC
PROCEDURE data_assign
*********************************************************************
** Property: Data (Assign)
**
** Gets or sets an array of bytes that specify the Region object.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/03: BDurban - Coded
*********************************************************************
LPARAMETERS tqBinary

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	This.Data = 0h+m.tqBinary
CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL

** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.RegionData.Data%28vs.80%29.aspx
** Parameters: byte[]
*********************************************************************

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
data Gets or sets an array of bytes that specify the Region object.
_memberdata XML Metadata for customizable properties
basename
*data_assign 
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED8]
drawing.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] xfcregiondata
[START RESERVED1]
 	 drawing.hﬁ„„M5 system.hÊ‰0•Ô4 gdiplusconstants.hÓÂÎi05[END RESERVED1]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1QZ1BY2H8
[CLASS] xfccustomlinecap
[CLASSLOC] drawing2d.vcx
[BASECLASS] custom
[OBJNAME] xfcadjustablearrowcap
[START PROPERTIES]
filled = 0
middleinset = 0
lastresult = 0
_memberdata =     1425<VFPData><memberdata name="clone" type="method" display="Clone"/><memberdata name="createobjref" type="method" display="CreateObjRef"/><memberdata name="dispose" type="method" display="Dispose"/><memberdata name="equals" type="method" display="Equals"/><memberdata name="gethashcode" type="method" display="GetHashCode"/><memberdata name="getlifetimeservice" type="method" display="GetLifetimeService"/><memberdata name="getstrokecaps" type="method" display="GetStrokeCaps"/><memberdata name="gettype" type="method" display="GetType"/><memberdata name="initializelifetimeservice" type="method" display="InitializeLifetimeService"/><memberdata name="setstrokecaps" type="method" display="SetStrokeCaps"/><memberdata name="tostring" type="method" display="ToString"/><memberdata name="finalize" type="method" display="Finalize"/><memberdata name="memberwiseclone" type="method" display="MemberwiseClone"/><memberdata name="basecap" type="property" display="BaseCap"/><memberdata name="baseinset" type="property" display="BaseInset"/><memberdata name="filled" type="property" display="Filled"/><memberdata name="height" type="property" display="Height"/><memberdata name="middleinset" type="property" display="MiddleInset"/><memberdata name="strokejoin" type="property" display="StrokeJoin"/><memberdata name="width" type="property" display="Width"/><memberdata name="widthscale" type="property" display="WidthScale"/></VFPData>
basename = AdjustableArrowCap
Name = "xfcadjustablearrowcap"
[END PROPERTIES]
[START METHODS]
PROCEDURE Init
*********************************************************************
** Method: AdjustableArrowCap
**
** Initializes a new instance of the AdjustableArrowCap class with the specified width
** and height.
**
** History:
**  2006/03/07: Auto Generated
*********************************************************************
LPARAMETERS tnWidth, tnHeight, ;
			tlIsFilled

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	DODEFAULT()
	LOCAL m.lhCap, m.liIsFilled
	m.tnWidth = EVL(m.tnWidth, 1.0)
	m.tnHeight = EVL(m.tnHeight, 1.0)
	m.liIsFilled = IIF(tlIsFilled, TRUE, FALSE)
	m.lhCap = 0
	This.SetStatus(GdipCreateAdjustableArrowCap(m.tnHeight, m.tnWidth, m.liIsFilled, @lhCap))
	This.Handle = m.lhCap
CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN

** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.AdjustableArrowCap.AdjustableArrowCap%28vs.80%29.aspx
** Parameters:
**  float width, float height
**  float width, float height, bool isFilled
*********************************************************************

ENDPROC
PROCEDURE declaredll
DODEFAULT()
TRY

xfcAdjustableArrowCapDeclareDLL(0)

CATCH

DECLARE Long Sleep IN WIN32API AS xfcAdjustableArrowCapDeclareDLL Long

DECLARE LONG GdipCreateAdjustableArrowCap IN GDIPLUS SINGLE height, SINGLE width, LONG isFilled, LONG @cap
DECLARE LONG GdipSetAdjustableArrowCapHeight IN GDIPLUS LONG cap, SINGLE height
DECLARE LONG GdipGetAdjustableArrowCapHeight IN GDIPLUS LONG cap, SINGLE @height
DECLARE LONG GdipSetAdjustableArrowCapWidth IN GDIPLUS LONG cap, SINGLE width
DECLARE LONG GdipGetAdjustableArrowCapWidth IN GDIPLUS LONG cap, SINGLE @width
DECLARE LONG GdipSetAdjustableArrowCapMiddleInset IN GDIPLUS LONG cap, SINGLE middleInset
DECLARE LONG GdipGetAdjustableArrowCapMiddleInset IN GDIPLUS LONG cap, SINGLE @middleInset
DECLARE LONG GdipSetAdjustableArrowCapFillState IN GDIPLUS LONG cap, LONG bFillState
DECLARE LONG GdipGetAdjustableArrowCapFillState IN GDIPLUS LONG cap, LONG @bFillState

ENDTRY
ENDPROC
PROCEDURE filled_access
*********************************************************************
** Property: Filled (Access)
**
** Gets or sets whether the arrow cap is filled.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/13: BDurban - Coded
*********************************************************************

*!ToDo: Test this function

LOCAL liFillState
m.liFillState = FALSE

LOCAL loExc AS Exception
TRY
	This.SetStatus(GdipGetAdjustableArrowCapFillState(This.Handle, @liFillState))
CATCH TO loExc
	THROW m.loExc
ENDTRY
RETURN (m.liFillState = TRUE)

** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.AdjustableArrowCap.Filled%28vs.80%29.aspx
** Returns: bool
*********************************************************************

ENDPROC
PROCEDURE filled_assign
*********************************************************************
** Property: Filled (Assign)
**
** Gets or sets whether the arrow cap is filled.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/13: BDurban - Coded
*********************************************************************
LPARAMETERS tlFillState

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	This.SetStatus(GdipSetAdjustableArrowCapFillState(This.Handle, IIF(m.tlFillState, TRUE, FALSE)))
CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL
ENDPROC
PROCEDURE height_access
*********************************************************************
** Property: Height (Access)
**
** Gets or sets the height of the arrow cap.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/13: BDurban - Coded
*********************************************************************

*!ToDo: Test this function

LOCAL lnHeight
m.lnHeight = 0.0

LOCAL loExc AS Exception
TRY
	This.SetStatus(GdipGetAdjustableArrowCapHeight(This.Handle, @lnHeight))

CATCH TO loExc
	THROW m.loExc
ENDTRY
RETURN m.lnHeight

** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.AdjustableArrowCap.Height%28vs.80%29.aspx
** Returns: float
*********************************************************************

ENDPROC
PROCEDURE height_assign
*********************************************************************
** Property: Height (Assign)
**
** Gets or sets the height of the arrow cap.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/13: BDurban - Coded
*********************************************************************
LPARAMETERS tnHeight

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	This.SetStatus(GdipSetAdjustableArrowCapHeight(This.Handle, m.tnHeight))
CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL
ENDPROC
PROCEDURE middleinset_access
*********************************************************************
** Property: MiddleInset (Access)
**
** Gets or sets the number of units between the outline of the arrow cap and the fill.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/13: BDurban - Coded
*********************************************************************

*!ToDo: Test this function

LOCAL tnMiddleInset
m.tnMiddleInset = 0.0

LOCAL loExc AS Exception
TRY
	This.SetStatus(GdipGetAdjustableArrowCapMiddleInset(This.Handle, @tnMiddleInset))

CATCH TO loExc
	THROW m.loExc
ENDTRY
RETURN m.tnMiddleInset

** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.AdjustableArrowCap.MiddleInset%28vs.80%29.aspx
** Returns: float
*********************************************************************

ENDPROC
PROCEDURE middleinset_assign
*********************************************************************
** Property: MiddleInset (Assign)
**
** Gets or sets the number of units between the outline of the arrow cap and the fill.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/13: BDurban - Coded
*********************************************************************
LPARAMETERS tnMiddleInset

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	This.SetStatus(GdipSetAdjustableArrowCapMiddleInset(This.Handle, m.tnMiddleInset))
CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL
ENDPROC
PROCEDURE width_access
*********************************************************************
** Property: Width (Access)
**
** Gets or sets the width of the arrow cap.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/13: BDurban - Coded
*********************************************************************

*!ToDo: Test this function

LOCAL lnWidth
m.lnWidth = 0.0

LOCAL loExc AS Exception
TRY
	This.SetStatus(GdipGetAdjustableArrowCapWidth(This.Handle, @lnWidth))

CATCH TO loExc
	THROW m.loExc
ENDTRY
RETURN m.lnWidth

** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.AdjustableArrowCap.Width%28vs.80%29.aspx
** Returns: float
*********************************************************************

ENDPROC
PROCEDURE width_assign
*********************************************************************
** Property: Width (Assign)
**
** Gets or sets the width of the arrow cap.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/13: BDurban - Coded
*********************************************************************
LPARAMETERS tnWidth

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	This.SetStatus(GdipSetAdjustableArrowCapWidth(This.Handle, m.tnWidth))
CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL
ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
filled Gets or sets whether the arrow cap is filled.
middleinset Gets or sets the number of units between the outline of the arrow cap and the fill.
*filled_access 
*filled_assign 
*height_access 
*height_assign 
*middleinset_access 
*middleinset_assign 
*width_access 
*width_assign 
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED8]
drawing.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] xfcadjustablearrowcap
[START RESERVED1]
 	 drawing.hﬁ„„M5 system.hÊ‰0•Ô4 gdiplusconstants.hÓÂÎi05[END RESERVED1]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1QZ1BYHBI
[CLASS] xfcbrush
[CLASSLOC] drawing.vcx
[BASECLASS] custom
[OBJNAME] xfchatchbrush
[START PROPERTIES]
backgroundcolor = 0
foregroundcolor = 0
hatchstyle = 0
_memberdata =      993<VFPData><memberdata name="clone" type="method" display="Clone"/><memberdata name="createobjref" type="method" display="CreateObjRef"/><memberdata name="dispose" type="method" display="Dispose"/><memberdata name="equals" type="method" display="Equals"/><memberdata name="gethashcode" type="method" display="GetHashCode"/><memberdata name="getlifetimeservice" type="method" display="GetLifetimeService"/><memberdata name="gettype" type="method" display="GetType"/><memberdata name="initializelifetimeservice" type="method" display="InitializeLifetimeService"/><memberdata name="tostring" type="method" display="ToString"/><memberdata name="finalize" type="method" display="Finalize"/><memberdata name="memberwiseclone" type="method" display="MemberwiseClone"/><memberdata name="backgroundcolor" type="property" display="BackgroundColor"/><memberdata name="foregroundcolor" type="property" display="ForegroundColor"/><memberdata name="hatchstyle" type="property" display="HatchStyle"/></VFPData>
basename = HatchBrush
lastresult = 0
Name = "xfchatchbrush"
[END PROPERTIES]
[START METHODS]
PROCEDURE Destroy
*********************************************************************
** Method: Destroy
**
** History:
**  2006/03/07: Auto Generated
**	2006/03/30: BDurban - Coded
*********************************************************************

*!ToDo: Test this function
RETURN DODEFAULT()

ENDPROC
PROCEDURE Init
*********************************************************************
** Method: HatchBrush
**
** Initializes a new instance of the HatchBrush class with the specified HatchStyle
** enumeration and foreground color.
**
** History:
**  2006/03/07: Auto Generated
**	2006/03/30: BDurban - Coded
*********************************************************************
LPARAMETERS tiHatchstyle AS EnumHatchStyle, toForeColor AS xfcColor, toBackColor AS xfcColor
*********** tiHatchstyle AS EnumHatchStyle, toForeColor AS xfcColor

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	LOCAL lhBrush,liColor2
	
	DODEFAULT()
	This.DeclareDLL()
	lhBrush = 0
	
	IF VARTYPE(tiHatchstyle) = "N"
		m.liColor2 = 0x00
		IF VARTYPE(m.toBackColor) = "O"
			m.liColor2 = m.toBackColor.Argb
		ENDIF
		This.SetStatus(GdipCreateHatchBrush(m.tiHatchstyle, m.toForeColor.Argb, m.liColor2, @lhBrush))
		This.Handle = m.lhBrush
	ENDIF

CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN

** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.HatchBrush.HatchBrush%28vs.80%29.aspx
** Parameters:
**  HatchStyle hatchstyle, Color foreColor
**  HatchStyle hatchstyle, Color foreColor, Color backColor
*********************************************************************

ENDPROC
PROCEDURE backgroundcolor_access
*********************************************************************
** Property: BackgroundColor (Access)
**
** Gets the color of spaces between the hatch lines drawn by this HatchBrush object.
**
** History:
**  2006/03/07: Auto Generated
**	2006/03/30: BDurban - Coded
*********************************************************************

*!ToDo: Test this function

LOCAL loColor, liArgb
m.liArgb = 0
m.loColor = NULL

LOCAL loExc AS Exception
TRY
	This.SetStatus(GdipGetHatchBackgroundColor(This.Handle, @liArgb))
		m.loColor = This.CreateNew("xfcColor")
		m.loColor.FromARGB(m.liArgb)
CATCH TO loExc
	THROW m.loExc
ENDTRY
RETURN m.loColor

** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.HatchBrush.BackgroundColor%28vs.80%29.aspx
** Returns: Color
*********************************************************************

ENDPROC
PROCEDURE clone
*********************************************************************
** Method: Clone
**
** Creates an exact copy of this HatchBrush object.
**
** History:
**  2006/03/07: Auto Generated
**	2006/03/30: BDurban - Coded
*********************************************************************

*!ToDo: Test this function
RETURN DODEFAULT()


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.HatchBrush.Clone%28vs.80%29.aspx
** Parameters:
**  [None]
** Returns: object
*********************************************************************

ENDPROC
PROCEDURE declaredll
DODEFAULT()

DECLARE LONG GdipCreateHatchBrush IN GDIPLUS LONG style, LONG forecolr, LONG backcolr, LONG @brush
DECLARE LONG GdipGetHatchStyle IN GDIPLUS LONG brush, LONG @style
DECLARE LONG GdipGetHatchForegroundColor IN GDIPLUS LONG brush, LONG @forecolr
DECLARE LONG GdipGetHatchBackgroundColor IN GDIPLUS LONG brush, LONG @backcolr

ENDPROC
PROCEDURE foregroundcolor_access
*********************************************************************
** Property: ForegroundColor (Access)
**
** Gets the color of hatch lines drawn by this HatchBrush object.
**
** History:
**  2006/03/07: Auto Generated
**	2006/03/30: BDurban - Coded
*********************************************************************

*!ToDo: Test this function

LOCAL loColor, liArgb
m.liArgb = 0
m.loColor = NULL

LOCAL loExc AS Exception
TRY
	This.SetStatus(GdipGetHatchForegroundColor(This.Handle, @liArgb))
		m.loColor = This.CreateNew("xfcColor")
		m.loColor.FromARGB(m.liArgb)
CATCH TO loExc
	THROW m.loExc
ENDTRY
RETURN m.loColor

** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.HatchBrush.ForegroundColor%28vs.80%29.aspx
** Returns: Color
*********************************************************************

ENDPROC
PROCEDURE getlaststatus
LOCAL lnLastStatus
m.lnLastStatus = This.LastResult
This.LastResult = 0

RETURN m.lnLastStatus
ENDPROC
PROCEDURE hatchstyle_access
*********************************************************************
** Property: HatchStyle (Access)
**
** Gets the hatch style of this HatchBrush object.
**
** History:
**  2006/03/07: Auto Generated
**	2006/03/30: BDurban - Coded
*********************************************************************

*!ToDo: Test this function

LOCAL liHatchStyle
m.liHatchStyle = 0

LOCAL loExc AS Exception
TRY
	This.SetStatus(GdipGetHatchStyle(This.Handle, @liHatchstyle))
CATCH TO loExc
	THROW m.loExc
ENDTRY
RETURN m.liHatchStyle

** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.HatchBrush.HatchStyle%28vs.80%29.aspx
** Returns: HatchStyle
*********************************************************************

ENDPROC
PROCEDURE new
LPARAMETERS tiHatchstyle AS EnumHatchStyle, toForeColor AS xfcColor, toBackColor AS xfcColor

RETURN This.CreateNew(This.Class, m.tiHatchstyle, m.toForeColor, m.toBackColor)

ENDPROC
PROCEDURE setstatus
LPARAMETERS tnStatus
IF This.LastResult = 0
	This.LastResult = m.tnStatus
ENDIF

RETURN m.tnStatus
ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
backgroundcolor Gets the color of spaces between the hatch lines drawn by this HatchBrush object.
foregroundcolor Gets the color of hatch lines drawn by this HatchBrush object.
hatchstyle Gets the hatch style of this HatchBrush object.
*backgroundcolor_access 
*foregroundcolor_access 
*hatchstyle_access 
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED8]
drawing.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] xfchatchbrush
[START RESERVED1]
 	 drawing.hﬁ„„M5 system.hÊ‰0•Ô4 gdiplusconstants.hÓÂÎi05[END RESERVED1]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1QZ1BYKKP
[CLASS] xfcbrush
[CLASSLOC] drawing.vcx
[BASECLASS] custom
[OBJNAME] xfclineargradientbrush
[START PROPERTIES]
blend = 0
gammacorrection = 0
interpolationcolors = 0
rectangle = 0
transform = 0
wrapmode = 0
_memberdata =     1817<VFPData><memberdata name="clone" type="method" display="Clone"/><memberdata name="createobjref" type="method" display="CreateObjRef"/><memberdata name="dispose" type="method" display="Dispose"/><memberdata name="equals" type="method" display="Equals"/><memberdata name="gethashcode" type="method" display="GetHashCode"/><memberdata name="getlifetimeservice" type="method" display="GetLifetimeService"/><memberdata name="gettype" type="method" display="GetType"/><memberdata name="initializelifetimeservice" type="method" display="InitializeLifetimeService"/><memberdata name="multiplytransform" type="method" display="MultiplyTransform"/><memberdata name="resettransform" type="method" display="ResetTransform"/><memberdata name="rotatetransform" type="method" display="RotateTransform"/><memberdata name="scaletransform" type="method" display="ScaleTransform"/><memberdata name="setblendtriangularshape" type="method" display="SetBlendTriangularShape"/><memberdata name="setsigmabellshape" type="method" display="SetSigmaBellShape"/><memberdata name="tostring" type="method" display="ToString"/><memberdata name="translatetransform" type="method" display="TranslateTransform"/><memberdata name="finalize" type="method" display="Finalize"/><memberdata name="memberwiseclone" type="method" display="MemberwiseClone"/><memberdata name="blend" type="property" display="Blend"/><memberdata name="gammacorrection" type="property" display="GammaCorrection"/><memberdata name="interpolationcolors" type="property" display="InterpolationColors"/><memberdata name="linearcolors" type="property" display="LinearColors"/><memberdata name="rectangle" type="property" display="Rectangle"/><memberdata name="transform" type="property" display="Transform"/><memberdata name="wrapmode" type="property" display="WrapMode"/></VFPData>
basename = LinearGradientBrush
lastresult = 0
Name = "xfclineargradientbrush"
[END PROPERTIES]
[START METHODS]
PROCEDURE Destroy
*********************************************************************
** Method: Destroy
**
** History:
**  2006/03/07: Auto Generated
**	2006/03/29: BDurban - Coded
*********************************************************************

*!ToDo: Test this function

RETURN DODEFAULT()
ENDPROC
PROCEDURE Init
*********************************************************************
** Method: LinearGradientBrush
**
** Initializes a new instance of the LinearGradientBrush class with the specified points
** and colors.
**
** History:
**  2006/03/07: Auto Generated
**	2006/03/29: BDurban - Coded
*********************************************************************
LPARAMETERS toRect AS xfcRectangle, toColor1 AS xfcColor, toColor2 AS xfcColor, tnAngle, tlIsAngleScaleable
*********** toRect AS xfcRectangle, toColor1 AS xfcColor, toColor2 AS xfcColor, tiLinearGradientMode AS EnumLinearGradientMode
*********** toPoint1 AS xfcPoint, toPoint2 AS xfcPoint, toColor1 AS xfcColor, toColor2 AS xfcColor

** Note: This overload is not supported. You must specify the IsAngleScalable parameter because
** we cannot differentiate between this overload and the LinearGradientMode overload
*********** toRect AS xfcRectangle, toColor1 AS xfcColor, toColor2 AS xfcColor, tnAngle

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	DODEFAULT()
	This.DeclareDLL()

	LOCAL lhLineGradient, liWrapMode, liLinearGradientMode
	LOCAL loPoint1 AS xfcPointF
	LOCAL loPoint2 AS xfcPointF
	m.lhLineGradient = 0
	m.liWrapMode = 0	&& WrapModeTile
	m.tiLinearGradientMode = 0

	DO CASE
	CASE VARTYPE(toRect) == "O" AND toRect.BaseName = "PointF"
		m.loPoint1 = m.toRect
		m.loPoint2 = m.toColor1
		m.toColor1 = m.toColor2
		m.toColor2 = m.tnAngle
		This.SetStatus(GdipCreateLineBrush(m.loPoint1.ToVarBinary(), m.loPoint1.ToVarBinary(), m.toColor1.Argb, m.toColor2.Argb, m.liWrapMode, @lhLineGradient))
		
	CASE VARTYPE(toRect) == "O" AND toRect.BaseName = "Point"
		m.loPoint1 = m.toRect
		m.loPoint2 = m.toColor1
		m.toColor1 = m.toColor2
		m.toColor2 = m.tnAngle
		This.SetStatus(GdipCreateLineBrushI(m.loPoint1.ToVarBinary(), m.loPoint1.ToVarBinary(), m.toColor1.Argb, m.toColor2.Argb, m.liWrapMode, @lhLineGradient))
	
	CASE VARTYPE(toRect) == "O" AND toRect.BaseName = "RectangleF" AND PCOUNT()=4
		m.liLinearGradientMode = m.tnAngle
		This.SetStatus(GdipCreateLineBrushFromRect(m.toRect.ToVarBinary(), m.toColor1.Argb, m.toColor2.Argb, m.liLinearGradientMode, m.liWrapMode, @lhLineGradient))
	
	CASE VARTYPE(toRect) == "O" AND toRect.BaseName = "Rectangle" AND PCOUNT()=4
		m.liLinearGradientMode = m.tnAngle
		This.SetStatus(GdipCreateLineBrushFromRectI(m.toRect.ToVarBinary(), m.toColor1.Argb, m.toColor2.Argb, m.liLinearGradientMode, m.liWrapMode, @lhLineGradient))

	CASE VARTYPE(toRect) == "O" AND toRect.BaseName = "RectangleF" AND PCOUNT()=5
		This.SetStatus(GdipCreateLineBrushFromRectWithAngle(m.toRect.ToVarBinary(), m.toColor1.Argb, m.toColor2.Argb, m.tnAngle, IIF(m.tlIsAngleScaleable,1,0), m.liWrapMode, @lhLineGradient))
		
	CASE VARTYPE(toRect) == "O" AND toRect.BaseName = "Rectangle" AND PCOUNT()=5
		This.SetStatus(GdipCreateLineBrushFromRectWithAngleI(m.toRect.ToVarBinary(), m.toColor1.Argb, m.toColor2.Argb, m.tnAngle, IIF(m.tlIsAngleScaleable,1,0), m.liWrapMode, @lhLineGradient))
		
	ENDCASE
	
	This.Handle = m.lhLineGradient
CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN

** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.LinearGradientBrush.LinearGradientBrush%28vs.80%29.aspx
** Parameters:
**  Point point1, Point point2, Color color1, Color color2
**  PointF point1, PointF point2, Color color1, Color color2
**  Rectangle rect, Color color1, Color color2, LinearGradientMode linearGradientMode
**  Rectangle rect, Color color1, Color color2, float angle
**  RectangleF rect, Color color1, Color color2, LinearGradientMode linearGradientMode
**  RectangleF rect, Color color1, Color color2, float angle
**  Rectangle rect, Color color1, Color color2, float angle, bool isAngleScaleable
**  RectangleF rect, Color color1, Color color2, float angle, bool isAngleScaleable
*********************************************************************

ENDPROC
PROCEDURE blend_access
*********************************************************************
** Property: Blend (Access)
**
** Gets or sets a Blend object that specifies positions and factors that define a custom
** falloff for the gradient.
**
** History:
**  2006/03/07: Auto Generated
**	2006/06/13: BDurban - Coded
*********************************************************************

*!ToDo: Test this function
LOCAL lqFactors, lqPositions, liCount, loBlend aS xfcBlend

LOCAL loExc AS Exception
TRY
	This.SetStatus(GdipGetLineBlendCount(This.Handle, @liCount))
	m.lqFactors = REPLICATE(EMPTY_FLOAT, m.liCount)
	m.lqPositions = REPLICATE(EMPTY_FLOAT, m.liCount)
	This.SetStatus(GdipGetLineBlend(This.Handle, @lqFactors, @lqPositions, m.liCount))
	m.loBlend = THIs.CreateNew("xfcBlend", m.liCount, m.lqFactors, m.lqPositions)
CATCH TO loExc
	THROW m.loExc
ENDTRY
RETURN m.loBlend

** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.LinearGradientBrush.Blend%28vs.80%29.aspx
** Returns: Blend
*********************************************************************

ENDPROC
PROCEDURE blend_assign
*********************************************************************
** Property: Blend (Assign)
**
** Gets or sets a Blend object that specifies positions and factors that define a custom
** falloff for the gradient.
**
** History:
**  2006/03/07: Auto Generated
**	2006/06/13: BDurban - Coded
*********************************************************************
LPARAMETERS toBlend AS xfcBlend

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	LOCAL lqFactors, lqPositions, liCount
	IF VARTYPE(m.toBlend) = "O"
		m.lqFactors = m.toBlend.Factors(0h)
		m.lqPositions = m.toBlend.Positions(0h)
		m.liCount = LEN(m.lqFactors)/4
		This.SetStatus(GdipSetLineBlend(This.Handle, @lqFactors, @lqPositions, m.liCount))
	ENDIF
CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL
ENDPROC
PROCEDURE declaredll
DODEFAULT()
TRY

xfcLinearGradientBrushDeclareDLL(0)

CATCH

DECLARE Long Sleep IN WIN32API AS xfcLinearGradientBrushDeclareDLL Long

DECLARE LONG GdipCreateLineBrush IN GDIPLUS STRING @point1, STRING @point2, LONG color1, LONG color2, LONG WrapMd, LONG @lineGradient
DECLARE LONG GdipCreateLineBrushI IN GDIPLUS STRING @point1, STRING @point2, LONG color1, LONG color2, LONG WrapMd, LONG @lineGradient
DECLARE LONG GdipCreateLineBrushFromRect IN GDIPLUS STRING @nRect, LONG color1, LONG color2, LONG mode, LONG WrapMd, LONG @lineGradient
DECLARE LONG GdipCreateLineBrushFromRectI IN GDIPLUS STRING @nRect, LONG color1, LONG color2, LONG mode, LONG WrapMd, LONG @lineGradient
DECLARE LONG GdipCreateLineBrushFromRectWithAngle IN GDIPLUS STRING @nRect, LONG color1, LONG color2, SINGLE angle, LONG isAngleScalable, LONG WrapMd, LONG @lineGradient
DECLARE LONG GdipCreateLineBrushFromRectWithAngleI IN GDIPLUS STRING @nRect, LONG color1, LONG color2, SINGLE angle, LONG isAngleScalable, LONG WrapMd, LONG @lineGradient
DECLARE LONG GdipSetLineColors IN GDIPLUS LONG brush, LONG color1, LONG color2
DECLARE LONG GdipGetLineColors IN GDIPLUS LONG brush, String @cColors
DECLARE LONG GdipGetLineRect IN GDIPLUS LONG brush, STRING @nRect
DECLARE LONG GdipGetLineRectI IN GDIPLUS LONG brush, STRING @nRect
DECLARE LONG GdipSetLineGammaCorrection IN GDIPLUS LONG brush, LONG useGammaCorrection
DECLARE LONG GdipGetLineGammaCorrection IN GDIPLUS LONG brush, LONG @useGammaCorrection
DECLARE LONG GdipGetLineBlendCount IN GDIPLUS LONG brush, LONG @Count
DECLARE LONG GdipGetLineBlend IN GDIPLUS LONG brush, STRING @blend, STRING @positions, LONG Count
DECLARE LONG GdipSetLineBlend IN GDIPLUS LONG brush, STRING @blend, STRING @positions, LONG Count
DECLARE LONG GdipGetLinePresetBlendCount IN GDIPLUS LONG brush, LONG @Count
DECLARE LONG GdipGetLinePresetBlend IN GDIPLUS LONG brush, STRING @blend, STRING @positions, LONG Count
DECLARE LONG GdipSetLinePresetBlend IN GDIPLUS LONG brush, STRING blend, STRING positions, LONG Count
DECLARE LONG GdipSetLineSigmaBlend IN GDIPLUS LONG brush, SINGLE FOCUS, SINGLE theScale
DECLARE LONG GdipSetLineLinearBlend IN GDIPLUS LONG brush, SINGLE FOCUS, SINGLE theScale
DECLARE LONG GdipSetLineWrapMode IN GDIPLUS LONG brush, LONG WrapMd
DECLARE LONG GdipGetLineWrapMode IN GDIPLUS LONG brush, LONG @WrapMd
DECLARE LONG GdipGetLineTransform IN GDIPLUS LONG brush, LONG @matrix
DECLARE LONG GdipSetLineTransform IN GDIPLUS LONG brush, LONG matrix
DECLARE LONG GdipResetLineTransform IN GDIPLUS LONG brush
DECLARE LONG GdipMultiplyLineTransform IN GDIPLUS LONG brush, LONG matrix, LONG order
DECLARE LONG GdipTranslateLineTransform IN GDIPLUS LONG brush, SINGLE dx, SINGLE dy, LONG order
DECLARE LONG GdipScaleLineTransform IN GDIPLUS LONG brush, SINGLE sx, SINGLE sy, LONG order
DECLARE LONG GdipRotateLineTransform IN GDIPLUS LONG brush, SINGLE angle, LONG order

ENDTRY
ENDPROC
PROCEDURE gammacorrection_access
*********************************************************************
** Property: GammaCorrection (Access)
**
** Gets or sets a value indicating whether gamma correction is enabled for this LinearGradientBrush
** object.
**
** History:
**  2006/03/07: Auto Generated
**	2006/03/29:	BDurban - Coded
*********************************************************************

*!ToDo: Test this function

LOCAL liUseGammaCorrection
m.liUseGammaCorrection = 0

LOCAL loExc AS Exception
TRY
	This.SetStatus(GdipGetLineGammaCorrection(This.Handle, @liUseGammaCorrection))
CATCH TO loExc
	THROW m.loExc
ENDTRY
RETURN (m.liUseGammaCorrection=1)

** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.LinearGradientBrush.GammaCorrection%28vs.80%29.aspx
** Returns: bool
*********************************************************************

ENDPROC
PROCEDURE gammacorrection_assign
*********************************************************************
** Property: GammaCorrection (Assign)
**
** Gets or sets a value indicating whether gamma correction is enabled for this LinearGradientBrush
** object.
**
** History:
**  2006/03/07: Auto Generated
**	2006/03/29:	BDurban - Coded
*********************************************************************
LPARAMETERS tlValue

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	This.SetStatus(GdipSetLineGammaCorrection(This.Handle, IIF(m.tlValue, 1, 0)))
CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL
ENDPROC
PROCEDURE interpolationcolors_access
*********************************************************************
** Property: InterpolationColors (Access)
**
** Gets or sets a ColorBlend object that defines a multicolor linear gradient.
**
** History:
**  2006/03/07: Auto Generated
**	2006/06/13: BDurban - Coded
*********************************************************************

*!ToDo: Test this function

LOCAL lqColors, lqPositions, liCount, loBlend aS xfcColorBlend

LOCAL loExc AS Exception
TRY
	This.SetStatus(GdipGetLinePresetBlendCount(This.Handle, @liCount))
	m.lqColors = REPLICATE(EMPTY_LONG, m.liCount)
	m.lqPositions = REPLICATE(EMPTY_FLOAT, m.liCount)
	This.SetStatus(GdipGetLinePresetBlend(This.Handle, @lqColors, @lqPositions, m.liCount))
	m.loBlend = THIs.CreateNew("xfcColorBlend", m.liCount, m.lqColors, m.lqPositions)
CATCH TO loExc
	THROW m.loExc
ENDTRY
RETURN m.loBlend

** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.LinearGradientBrush.InterpolationColors%28vs.80%29.aspx
** Returns: ColorBlend
*********************************************************************

ENDPROC
PROCEDURE interpolationcolors_assign
*********************************************************************
** Property: InterpolationColors (Assign)
**
** Gets or sets a ColorBlend object that defines a multicolor linear gradient.
**
** History:
**  2006/03/07: Auto Generated
**	2006/06/13: BDurban - Coded
*********************************************************************
LPARAMETERS toColorBlend AS xfcColorBlend

*!ToDo: Test this function
LOCAL lqColors, lqPositions, liCount

LOCAL loExc AS Exception
TRY
	IF VARTYPE(m.toColorBlend) = "O"
		m.lqColors = m.toColorBlend.Colors(0h)
		m.lqPositions = m.toColorBlend.Positions(0h)
		m.liCount = LEN(m.lqColors)/4
		This.SetStatus(GdipSetLinePresetBlend(This.Handle, m.lqColors, m.lqPositions, m.liCount))
	ENDIF
CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL

ENDPROC
PROCEDURE linearcolors_access
*********************************************************************
** Property: LinearColors (Access)
**
** Gets or sets the starting and ending colors of the gradient.
**
** History:
**  2006/03/07: Auto Generated
**	2006/04/24: BDurban - Coded
*********************************************************************
LPARAMETERS tnIndex

*!ToDo: Test this function

LOCAL lcColors, liArgb
m.liArgb = 0
m.lcColors = 0h0000000000000000

LOCAL loExc AS Exception
TRY
	m.tnIndex = EVL(m.tnIndex, 1)
	This.SetStatus(GdipGetLineColors(This.Handle, @lcColors))
	m.liArgb = CTOBIN(SUBSTR(m.lcColors,(tnIndex-1)*4+1,4),"4rs")
	m.loColor = This.CreateNew("xfcColor", m.liArgb)
CATCH TO loExc
	THROW m.loExc
ENDTRY
RETURN m.loColor

** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.LinearGradientBrush.LinearColors%28vs.80%29.aspx
** Returns: Color[]
*********************************************************************

ENDPROC
PROCEDURE linearcolors_assign
*********************************************************************
** Property: LinearColors (Assign)
**
** Gets or sets the starting and ending colors of the gradient.
**
** History:
**  2006/03/07: Auto Generated
**	2006/04/25: BDurban - Coded
*********************************************************************
LPARAMETERS toColor AS xfcColor, tnIndex

*!ToDo: Test this function
LOCAL liArgb1, liArgb2, loOtherColor AS xfcColor

LOCAL loExc AS Exception
TRY
	IF VARTYPE(m.toColor)="O"
		IF tnIndex = 2
			m.loOtherColor = This.LinearColors_ACCESS[1]
			m.liArgb1 = m.loOtherColor.ToArgb()
			m.liArgb2 = m.toColor.ToArgb()
		ELSE
			m.liArgb1 = m.toColor.ToArgb()
			m.loOtherColor = This.LinearColors_ACCESS[2]
			m.liArgb2 = m.loOtherColor.ToArgb()
		ENDIF
		This.SetStatus(GdipSetLineColors(This.Handle, m.liArgb1, m.liArgb2))
	ENDIF
CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL

ENDPROC
PROCEDURE multiplytransform
*********************************************************************
** Method: MultiplyTransform
**
** Multiplies the Matrix object that represents the local geometric transform of this
** LinearGradientBrush by the specified Matrix by prepending the specified Matrix.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/04: BDurban - Coded
*********************************************************************
LPARAMETERS toMatrix AS xfcMatrix, ;
			tiOrder AS EnumMatrixOrder

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	m.tiOrder = EVL(m.tiOrder, MatrixOrderPrepend)
	This.SetStatus(GdipMultiplyLineTransform(This.Handle, m.toMatrix.Handle, m.tiOrder))

CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.LinearGradientBrush.MultiplyTransform%28vs.80%29.aspx
** Parameters:
**  Matrix matrix
**  Matrix matrix, MatrixOrder order
** Returns: void
*********************************************************************

ENDPROC
PROCEDURE new
LPARAMETERS toRect AS xfcRectangle, toColor1 AS xfcColor, toColor2 AS xfcColor, tnAngleOrMode, tlIsAngleScaleable

IF PCOUNT()=5
	RETURN This.CreateNew(This.Class, m.toRect, m.toColor1, m.toColor2, m.tnAngleOrMode, m.tlIsAngleScaleable)
ELSE
	RETURN This.CreateNew(This.Class, m.toRect, m.toColor1, m.toColor2, m.tnAngleOrMode)
ENDIF

ENDPROC
PROCEDURE rectangle_access
*********************************************************************
** Property: Rectangle (Access)
**
** Gets a rectangular region that defines the starting and ending points of the gradient.
**
** History:
**  2006/03/07: Auto Generated
**	2006/03/29:	BDurban - Coded
*********************************************************************

*!ToDo: Test this function

LOCAL loRectangleF, lcRect
m.loRectangleF = NULL

LOCAL loExc AS Exception
TRY
	m.lqRect = 0h+REPLICATE(BINTOC(0.0,"F"),4)
	This.SetStatus(GdipGetLineRect(This.Handle, @lqRect))
	** ToDo:
	** Return a RectangleF here, the same as .NET, since we don't know the type
	** Maybe we could hold on to the type used to create this object to determine
	** the return type here
	** This.SetStatus(GdipGetLineRectI(This.Handle, @lcRect))
	m.loRectangleF = This.CreateNew("xfcRectangleF", m.lqRect)
CATCH TO loExc
	THROW m.loExc
ENDTRY
RETURN m.loRectangleF

** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.LinearGradientBrush.Rectangle%28vs.80%29.aspx
** Returns: RectangleF
*********************************************************************

ENDPROC
PROCEDURE resettransform
*********************************************************************
** Method: ResetTransform
**
** Resets the Transform property to identity.
**
** History:
**  2006/03/07: Auto Generated
**	2006/03/28:	BDurban - Coded
*********************************************************************

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	This.SetStatus(GdipResetLineTransform(This.Handle))
CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.LinearGradientBrush.ResetTransform%28vs.80%29.aspx
** Parameters:
**  [None]
** Returns: void
*********************************************************************

ENDPROC
PROCEDURE rotatetransform
*********************************************************************
** Method: RotateTransform
**
** Rotates the local geometric transform by the specified amount. This method prepends
** the rotation to the transform.
**
** History:
**  2006/03/07: Auto Generated
**	2006/03/28:	BDurban - Coded
*********************************************************************
LPARAMETERS tnAngle ;
			,tiOrder AS EnumMatrixOrder

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	m.toOrder = EVL(m.tiOrder, MatrixOrderPrepend)
	This.SetStatus(GdipRotateLineTransform(This.Handle, m.tnAngle, m.tiOrder))
CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.LinearGradientBrush.RotateTransform%28vs.80%29.aspx
** Parameters:
**  float angle
**  float angle, MatrixOrder order
** Returns: void
*********************************************************************

ENDPROC
PROCEDURE scaletransform
*********************************************************************
** Method: ScaleTransform
**
** Scales the local geometric transform by the specified amounts. This method prepends
** the scaling matrix to the transform.
**
** History:
**  2006/03/07: Auto Generated
**	2006/03/28:	BDurban - Coded
*********************************************************************
LPARAMETERS tnSx, tnSy ;
			, tiOrder AS EnumMatrixOrder

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	m.tiOrder = EVL(m.tiOrder, MatrixOrderPrepend)
	This.SetStatus(GdipScaleLineTransform(m.lhBrush, m.tnSx, m.tnSy, m.tiOrder))
CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.LinearGradientBrush.ScaleTransform%28vs.80%29.aspx
** Parameters:
**  float sx, float sy
**  float sx, float sy, MatrixOrder order
** Returns: void
*********************************************************************

ENDPROC
PROCEDURE setblendtriangularshape
*********************************************************************
** Method: SetBlendTriangularShape
**
** Creates a linear gradient with a center color and a linear falloff to a single color
** on both ends.
**
** History:
**  2006/03/07: Auto Generated
**	2006/03/28:	BDurban - Coded
*********************************************************************
LPARAMETERS tnFocus ;
			, tnScale

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	m.tnScale = EVL(m.tnScale, 0.0)
	This.SetStatus(GdipSetLineLinearBlend(This.Handle, m.tnFocus, m.tnScale))
CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.LinearGradientBrush.SetBlendTriangularShape%28vs.80%29.aspx
** Parameters:
**  float focus
**  float focus, float scale
** Returns: void
*********************************************************************

ENDPROC
PROCEDURE setsigmabellshape
*********************************************************************
** Method: SetSigmaBellShape
**
** Creates a gradient falloff based on a bell-shaped curve.
**
** History:
**  2006/03/07: Auto Generated
**	2006/03/28:	BDurban - Coded
*********************************************************************
LPARAMETERS tnFocus ;
			, tnScale

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	m.tnScale = EVL(m.tnScale, 0.0)
	This.SetStatus(GdipSetLineSigmaBlend(This.Handle, m.tnFocus, m.tnScale))

CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.LinearGradientBrush.SetSigmaBellShape%28vs.80%29.aspx
** Parameters:
**  float focus
**  float focus, float scale
** Returns: void
*********************************************************************

ENDPROC
PROCEDURE transform_access
*********************************************************************
** Property: Transform (Access)
**
** Gets or sets a Matrix object that defines a local geometric transform for this LinearGradientBrush
** object.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/04: BDurban - Coded
*********************************************************************

*!ToDo: Test this function

LOCAL loMatrix AS xfcMatrix, lhMatrix
m.lhMatrix = 0
m.loMatrix = NULL

LOCAL loExc AS Exception
TRY
	This.SetStatus(GdipGetLineTransform(This.Handle, @lhMatrix))
	IF(m.lhMatrix <> 0)
		m.loMatrix = This.CreateNew("xfcMatrix")
		m.loMatrix.Handle = m.lhMatrix
	ENDIF
CATCH TO loExc
	THROW m.loExc
ENDTRY
RETURN m.loMatrix

** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.LinearGradientBrush.Transform%28vs.80%29.aspx
** Returns: Matrix
*********************************************************************

ENDPROC
PROCEDURE transform_assign
*********************************************************************
** Property: Transform (Assign)
**
** Gets or sets a Matrix object that defines a local geometric transform for this LinearGradientBrush
** object.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/04: BDurban - Coded
*********************************************************************
LPARAMETERS toMatrix AS xfcMatrix

*!ToDo: Test this function
LOCAL lhHandle

LOCAL loExc AS Exception
TRY
	m.lhHandle = IIF(VARTYPE(m.toMatrix)="O", m.toMatrix.Handle, 0)
	This.SetStatus(GdipSetLineTransform(This.Handle, m.lhHandle))
CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL
ENDPROC
PROCEDURE translatetransform
*********************************************************************
** Method: TranslateTransform
**
** Translates the local geometric transform by the specified dimensions. This method
** prepends the translation to the transform.
**
** History:
**  2006/03/07: Auto Generated
**	2006/03/29:	BDurban - Coded
*********************************************************************
LPARAMETERS tnDx, tnDy ;
			, tiOrder AS EnumMatrixOrder

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	m.tiOrder = EVL(m.tiOrder, MatrixOrderPrepend)
	This.SetStatus(GdipTranslateLineTransform(This.Handle, m.tnDx, m.tnDy, m.tiOrder))
CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.LinearGradientBrush.TranslateTransform%28vs.80%29.aspx
** Parameters:
**  float dx, float dy
**  float dx, float dy, MatrixOrder order
** Returns: void
*********************************************************************

ENDPROC
PROCEDURE wrapmode_access
*********************************************************************
** Property: WrapMode (Access)
**
** Gets or sets a WrapMode enumeration that indicates the wrap mode for this LinearGradientBrush.
**
** History:
**  2006/03/07: Auto Generated
**	2006/03/29:	BDurban - Coded
*********************************************************************

*!ToDo: Test this function

LOCAL liWrapMode
m.liWrapMode = 0

LOCAL loExc AS Exception
TRY
	This.SetStatus(GdipGetLineWrapMode(This.Handle, @liWrapmode))

CATCH TO loExc
	THROW m.loExc
ENDTRY
RETURN m.liWrapMode

** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.LinearGradientBrush.WrapMode%28vs.80%29.aspx
** Returns: WrapMode
*********************************************************************

ENDPROC
PROCEDURE wrapmode_assign
*********************************************************************
** Property: WrapMode (Assign)
**
** Gets or sets a WrapMode enumeration that indicates the wrap mode for this LinearGradientBrush.
**
** History:
**  2006/03/07: Auto Generated
**	2006/03/29:	BDurban - Coded
*********************************************************************
LPARAMETERS tiWrapMode

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	This.SetStatus(GdipSetLineWrapMode(This.Handle, m.tiWrapMode))
CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL
ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
blend Gets or sets a Blend object that specifies positions and factors that define a custom falloff for the gradient.
gammacorrection Gets or sets a value indicating whether gamma correction is enabled for this LinearGradientBrush object.
interpolationcolors Gets or sets a ColorBlend object that defines a multicolor linear gradient.
rectangle Gets a rectangular region that defines the starting and ending points of the gradient.
transform Gets or sets a Matrix object that defines a local geometric transform for this LinearGradientBrush object.
wrapmode Gets or sets a WrapMode enumeration that indicates the wrap mode for this LinearGradientBrush.
*multiplytransform Multiplies the Matrix object that represents the local geometric transform of this LinearGradientBrush by the specified Matrix by prepending the specified Matrix.
*resettransform Resets the Transform property to identity.
*rotatetransform Rotates the local geometric transform by the specified amount. This method prepends the rotation to the transform.
*scaletransform Scales the local geometric transform by the specified amounts. This method prepends the scaling matrix to the transform.
*setblendtriangularshape Creates a linear gradient with a center color and a linear falloff to a single color on both ends.
*setsigmabellshape Creates a gradient falloff based on a bell-shaped curve.
*translatetransform Translates the local geometric transform by the specified dimensions. This method prepends the translation to the transform.
*blend_access 
*blend_assign 
*gammacorrection_access 
*gammacorrection_assign 
*interpolationcolors_access 
*interpolationcolors_assign 
*rectangle_access 
*transform_access 
*transform_assign 
*wrapmode_access 
*wrapmode_assign 
^linearcolors[2,0] Gets or sets the starting and ending colors of the gradient.
*linearcolors_access 
*linearcolors_assign 
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED8]
drawing.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] xfclineargradientbrush
[START RESERVED1]
 	 drawing.hﬁ„„M5 system.hÊ‰0•Ô4 gdiplusconstants.hÓÂÎi05[END RESERVED1]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1QZ1BYOQ0
[CLASS] xfcbrush
[CLASSLOC] drawing.vcx
[BASECLASS] custom
[OBJNAME] xfcpathgradientbrush
[START PROPERTIES]
blend = 0
centercolor = 0
centerpoint = 0
focusscales = 0
interpolationcolors = 0
rectangle = 0
transform = 0
wrapmode = 0
_memberdata =     1953<VFPData><memberdata name="clone" type="method" display="Clone"/><memberdata name="createobjref" type="method" display="CreateObjRef"/><memberdata name="dispose" type="method" display="Dispose"/><memberdata name="equals" type="method" display="Equals"/><memberdata name="gethashcode" type="method" display="GetHashCode"/><memberdata name="getlifetimeservice" type="method" display="GetLifetimeService"/><memberdata name="gettype" type="method" display="GetType"/><memberdata name="initializelifetimeservice" type="method" display="InitializeLifetimeService"/><memberdata name="multiplytransform" type="method" display="MultiplyTransform"/><memberdata name="resettransform" type="method" display="ResetTransform"/><memberdata name="rotatetransform" type="method" display="RotateTransform"/><memberdata name="scaletransform" type="method" display="ScaleTransform"/><memberdata name="setblendtriangularshape" type="method" display="SetBlendTriangularShape"/><memberdata name="setsigmabellshape" type="method" display="SetSigmaBellShape"/><memberdata name="tostring" type="method" display="ToString"/><memberdata name="translatetransform" type="method" display="TranslateTransform"/><memberdata name="finalize" type="method" display="Finalize"/><memberdata name="memberwiseclone" type="method" display="MemberwiseClone"/><memberdata name="blend" type="property" display="Blend"/><memberdata name="centercolor" type="property" display="CenterColor"/><memberdata name="centerpoint" type="property" display="CenterPoint"/><memberdata name="focusscales" type="property" display="FocusScales"/><memberdata name="interpolationcolors" type="property" display="InterpolationColors"/><memberdata name="rectangle" type="property" display="Rectangle"/><memberdata name="surroundcolors" type="property" display="SurroundColors"/><memberdata name="transform" type="property" display="Transform"/><memberdata name="wrapmode" type="property" display="WrapMode"/></VFPData>
basename = PathGradientBrush
lastresult = 0
Name = "xfcpathgradientbrush"
[END PROPERTIES]
[START METHODS]
PROCEDURE Init
*********************************************************************
** Method: PathGradientBrush
**
** Initializes a new instance of the PathGradientBrush class with the specified path.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/10: BDurban - Coded
**  2006/09/06: CChalom - Fixed (liCount=0;  m.taoPoints(1) in DOCASE)
*********************************************************************
LPARAMETERS taoPoints AS xfcPoint, ;
			tiWrapMode AS EnumWrapMode
*********** toPath AS xfcGraphicsPath

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	DODEFAULT()
	LOCAL loPoint AS xfcPoint, lqPoints, lhPolyGradient
	LOCAL loPath AS xfcGraphicsPath
	m.tiWrapMode = EVL(m.tiWrapMode, WrapModeTile)
	m.lhPolyGradient = 0
	m.liCount = 0

	DO CASE
	CASE VARTYPE(m.taoPoints)="O" AND m.taoPoints(1).BaseName = "PointF"
		m.loPoint = This.CreateNew("xfcPointF")
		m.lqPoints = m.loPoint.ToVarBinary(@taoPoints, @liCount)
		This.SetStatus(GdipCreatePathGradient(@lqPoints, m.liCount, m.tiWrapMode, @lhPolyGradient))
		
	CASE VARTYPE(m.taoPoints)="O" AND m.taoPoints(1).BaseName = "Point"
		m.loPoint = This.CreateNew("xfcPoint")
		m.lqPoints = m.loPoint.ToVarBinary(@taoPoints, @liCount)
		This.SetStatus(GdipCreatePathGradient(@lqPoints, m.liCount, m.tiWrapMode, @lhPolyGradient))
	
	CASE VARTYPE(m.taoPoints)="O" AND m.taoPoints.BaseName = "GraphicsPath"
		m.loPath = m.taoPoints
		This.SetStatus(GdipCreatePathGradientFromPath(m.loPath.Handle, @lhPolyGradient))
		
	ENDCASE
	
	This.Handle = m.lhPolyGradient
	
CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN

** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.PathGradientBrush.PathGradientBrush%28vs.80%29.aspx
** Parameters:
**  GraphicsPath path
**  Point[] points
**  PointF[] points
**  Point[] points, WrapMode wrapMode
**  PointF[] points, WrapMode wrapMode
*********************************************************************

ENDPROC
PROCEDURE blend_access
*********************************************************************
** Property: Blend (Access)
**
** Gets or sets a Blend object that specifies positions and factors that define a custom
** falloff for the gradient.
**
** History:
**  2006/03/07: Auto Generated
**	2006/06/09: BDurban - Coded
*********************************************************************

*!ToDo: Test this function

LOCAL loBlend AS xfcBlend
LOCAL liCount, lqFactors, lqPositions
m.lhBlend = 0
m.loBlend = NULL

LOCAL loExc AS Exception
TRY
	m.liCount = 0
	This.SetStatus(GdipGetPathGradientBlendCount(This.Handle, @liCount))
	m.lqFactors = REPLICATE(EMPTY_FLOAT, m.liCount)
	m.lqPositions = REPLICATE(EMPTY_FLOAT, m.liCount)
	IF This.SetStatus(GdipGetPathGradientBlend(This.Handle, @lqFactors, @lqPositions, m.liCount)) = StatusOk
		m.loBlend = This.CreateNew("xfcBlend", m.liCount, m.lqFactors, m.lqPositions)
	ENDIF
CATCH TO loExc
	THROW m.loExc
ENDTRY
RETURN m.loBlend

** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.PathGradientBrush.Blend%28vs.80%29.aspx
** Returns: Blend
*********************************************************************

ENDPROC
PROCEDURE blend_assign
*********************************************************************
** Property: Blend (Assign)
**
** Gets or sets a Blend object that specifies positions and factors that define a custom
** falloff for the gradient.
**
** History:
**  2006/03/07: Auto Generated
**	2006/06/13: BDurban - Coded
*********************************************************************
LPARAMETERS toBlend AS xfcBlend

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	LOCAL lqFactors, lqPositions, liCount
	IF VARTYPE(m.toBlend) = "O"
		m.lqFactors = m.toBlend.Factors(0h)
		m.lqPositions = m.toBlend.Positions(0h)
		m.liCount = LEN(m.lqFactors)/4
		This.SetStatus(GdipSetPathGradientBlend(This.Handle, m.lqFactors, m.lqPositions, m.liCount))
	ENDIF
CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL

ENDPROC
PROCEDURE centercolor_access
*********************************************************************
** Property: CenterColor (Access)
**
** Gets or sets the color at the center of the path gradient.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/10: BDurban - Coded
*********************************************************************

*!ToDo: Test this function

LOCAL loColor, liArgb
m.liArgb = 0
m.loColor = NULL

LOCAL loExc AS Exception
TRY
	This.SetStatus(GdipGetPathGradientCenterColor(This.Handle, @liArgb))
	m.loColor = This.CreateNew("xfcColor", m.liArgb)
CATCH TO loExc
	THROW m.loExc
ENDTRY
RETURN m.loColor

** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.PathGradientBrush.CenterColor%28vs.80%29.aspx
** Returns: Color
*********************************************************************

ENDPROC
PROCEDURE centercolor_assign
*********************************************************************
** Property: CenterColor (Assign)
**
** Gets or sets the color at the center of the path gradient.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/10: BDurban - Coded
*********************************************************************
LPARAMETERS toColor

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	IF VARTYPE(m.toColor) = "O"
		This.SetStatus(GdipSetPathGradientCenterColor(This.Handle, m.toColor.ToArgb()))
	ENDIF
CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL
ENDPROC
PROCEDURE centerpoint_access
*********************************************************************
** Property: CenterPoint (Access)
**
** Gets or sets the center point of the path gradient.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/10: BDurban - Coded
*********************************************************************

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	LOCAL loPointF AS xfcPointF, lqPoint
	m.loPointF = NULL
	m.lqPoint = EMPTY_POINTF

	This.SetStatus(GdipGetPathGradientCenterPoint(This.Handle, @lqPoint))
*!*	This.SetStatus(GdipGetPathGradientCenterPointI(This.Handle, @lcPoints))
	m.loPointF = This.CreateNew("xfcPointF", m.lqPoint)
CATCH TO loExc
	THROW m.loExc
ENDTRY
RETURN m.loPointF

** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.PathGradientBrush.CenterPoint%28vs.80%29.aspx
** Returns: PointF
*********************************************************************

ENDPROC
PROCEDURE centerpoint_assign
*********************************************************************
** Property: CenterPoint (Assign)
**
** Gets or sets the center point of the path gradient.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/10: BDurban - Coded
*********************************************************************
LPARAMETERS toPointF AS xfcPointF

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	IF VARTYPE(toPointF) = "O"
		DO CASE
		CASE m.toPointF.BaseName = "xfcPointF"
			This.SetStatus(GdipSetPathGradientCenterPoint(This.Handle, m.toPoint.ToVarBinary()))
		CASE m.toPointF.BaseName = "xfcPoint"
			This.SetStatus(GdipSetPathGradientCenterPointI(This.Handle, m.toPoint.ToVarBinary()))
		OTHERWISE
			*!ToDo: Error handling?
		ENDCASE
	ENDIF
CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL
ENDPROC
PROCEDURE declaredll
DODEFAULT()

TRY

xfcPathGradientBrushDeclareDLL(0)

CATCH

DECLARE Long Sleep IN WIN32API AS xfcPathGradientBrushDeclareDLL Long

DECLARE LONG GdipCreatePathGradient IN GDIPLUS STRING @pPoint, LONG Count, LONG WrapMd, LONG @polyGradient
DECLARE LONG GdipCreatePathGradientI IN GDIPLUS STRING @pPoint, LONG Count, LONG WrapMd, LONG @polyGradient
DECLARE LONG GdipCreatePathGradientFromPath IN GDIPLUS LONG path, LONG @polyGradient
DECLARE LONG GdipGetPathGradientCenterColor IN GDIPLUS LONG brush, LONG @lColors
DECLARE LONG GdipSetPathGradientCenterColor IN GDIPLUS LONG brush, LONG lColors
DECLARE LONG GdipGetPathGradientSurroundColorsWithCount IN GDIPLUS LONG brush, STRING @argb, LONG @Count
DECLARE LONG GdipSetPathGradientSurroundColorsWithCount IN GDIPLUS LONG brush, STRING @argb, LONG @Count
DECLARE LONG GdipGetPathGradientPath IN GDIPLUS LONG brush, LONG path
DECLARE LONG GdipSetPathGradientPath IN GDIPLUS LONG brush, LONG path
DECLARE LONG GdipGetPathGradientCenterPoint IN GDIPLUS LONG brush, STRING @pPoint
DECLARE LONG GdipGetPathGradientCenterPointI IN GDIPLUS LONG brush, STRING @pPoint
DECLARE LONG GdipSetPathGradientCenterPoint IN GDIPLUS LONG brush, STRING pPoint
DECLARE LONG GdipSetPathGradientCenterPointI IN GDIPLUS LONG brush, STRING pPoint
DECLARE LONG GdipGetPathGradientRect IN GDIPLUS LONG brush, STRING @nRect
DECLARE LONG GdipGetPathGradientRectI IN GDIPLUS LONG brush, STRING @nRect
DECLARE LONG GdipGetPathGradientPointCount IN GDIPLUS LONG brush, LONG @Count
DECLARE LONG GdipGetPathGradientSurroundColorCount IN GDIPLUS LONG brush, LONG @Count
DECLARE LONG GdipSetPathGradientGammaCorrection IN GDIPLUS LONG brush, LONG useGammaCorrection
DECLARE LONG GdipGetPathGradientGammaCorrection IN GDIPLUS LONG brush, LONG @useGammaCorrection
DECLARE LONG GdipGetPathGradientBlendCount IN GDIPLUS LONG brush, LONG @Count
DECLARE LONG GdipGetPathGradientBlend IN GDIPLUS LONG brush, STRING @blend, STRING @positions, LONG Count
DECLARE LONG GdipSetPathGradientBlend IN GDIPLUS LONG brush, STRING @blend, STRING @positions, LONG Count
DECLARE LONG GdipGetPathGradientPresetBlendCount IN GDIPLUS LONG brush, LONG @Count
DECLARE LONG GdipGetPathGradientPresetBlend IN GDIPLUS LONG brush, LONG @blend, SINGLE @positions, LONG Count
DECLARE LONG GdipSetPathGradientPresetBlend IN GDIPLUS LONG brush, LONG @blend, SINGLE @positions, LONG Count
DECLARE LONG GdipSetPathGradientSigmaBlend IN GDIPLUS LONG brush, SINGLE FOCUS, SINGLE sscale
DECLARE LONG GdipSetPathGradientLinearBlend IN GDIPLUS LONG brush, SINGLE FOCUS, SINGLE sscale
DECLARE LONG GdipGetPathGradientWrapMode IN GDIPLUS LONG brush, LONG @WrapMd
DECLARE LONG GdipSetPathGradientWrapMode IN GDIPLUS LONG brush, LONG WrapMd
DECLARE LONG GdipGetPathGradientTransform IN GDIPLUS LONG brush, LONG matrix
DECLARE LONG GdipSetPathGradientTransform IN GDIPLUS LONG brush, LONG matrix
DECLARE LONG GdipResetPathGradientTransform IN GDIPLUS LONG brush
DECLARE LONG GdipMultiplyPathGradientTransform IN GDIPLUS LONG brush, LONG matrix, LONG order
DECLARE LONG GdipTranslatePathGradientTransform IN GDIPLUS LONG brush, SINGLE dx, SINGLE dy, LONG order
DECLARE LONG GdipScalePathGradientTransform IN GDIPLUS LONG brush, SINGLE sx, SINGLE sy, LONG order
DECLARE LONG GdipRotatePathGradientTransform IN GDIPLUS LONG brush, SINGLE angle, LONG order
DECLARE LONG GdipGetPathGradientFocusScales IN GDIPLUS LONG brush, SINGLE @xScale, SINGLE @yScale
DECLARE LONG GdipSetPathGradientFocusScales IN GDIPLUS LONG brush, SINGLE xScale, SINGLE yScale

ENDTRY
ENDPROC
PROCEDURE focusscales_access
*********************************************************************
** Property: FocusScales (Access)
**
** Gets or sets the focus point for the gradient falloff.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/10: BDurban - Coded
*********************************************************************

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	LOCAL loPointF AS xfcPointF, lnXScale, lnYScale
	m.loPointF = NULL
	STORE 0 TO m.lnXScale, m.lnYScale

	This.SetStatus(GdipGetPathGradientFocusScales(This.Handle, @lnXScale, @lnYScale))
	m.loPointF = This.CreateNew("xfcPointF")
CATCH TO loExc
	THROW m.loExc
ENDTRY
RETURN m.loPointF

** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.PathGradientBrush.FocusScales%28vs.80%29.aspx
** Returns: PointF
*********************************************************************

ENDPROC
PROCEDURE focusscales_assign
*********************************************************************
** Property: FocusScales (Assign)
**
** Gets or sets the focus point for the gradient falloff.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/10: BDurban - Coded
*********************************************************************
LPARAMETERS toPointF AS xfcPointF

*!ToDo: Test this function
LOCAL lnXScale, lnYScale

LOCAL loExc AS Exception
TRY
	IF VARTYPE(m.toPointF) = "O"
		STORE 0 TO m.lnXScale, m.lnYScale
		m.toPointF.GetExtent(@m.lnXScale, @m.lnYScale)
		This.SetStatus(GdipSetPathGradientFocusScales(This.Handle, m.lnXScale, m.lnYScale))
	ENDIF
CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL
ENDPROC
PROCEDURE interpolationcolors_access
*********************************************************************
** Property: InterpolationColors (Access)
**
** Gets or sets a ColorBlend object that defines a multicolor linear gradient.
**
** History:
**  2006/03/07: Auto Generated
**	2006/06/13: BDurban - Coded
*********************************************************************

*!ToDo: Test this function

LOCAL lqColors, lqPositions, liCount, loBlend aS xfcColorBlend

LOCAL loExc AS Exception
TRY
	This.SetStatus(GdipGetPathGradientPresetBlendCount(This.Handle, @liCount))
	m.lqColors = REPLICATE(EMPTY_LONG, m.liCount)
	m.lqPositions = REPLICATE(EMPTY_FLOAT, m.liCount)
	This.SetStatus(GdipGetPathGradientPresetBlend(This.Handle, @lqColors, @lqPositions, m.liCount))
	m.loBlend = This.CreateNew("xfcColorBlend", m.liCount, m.lqColors, m.lqPositions)
CATCH TO loExc
	THROW m.loExc
ENDTRY
RETURN m.loBlend

** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.PathGradientBrush.InterpolationColors%28vs.80%29.aspx
** Returns: ColorBlend
*********************************************************************

ENDPROC
PROCEDURE interpolationcolors_assign
*********************************************************************
** Property: InterpolationColors (Assign)
**
** Gets or sets a ColorBlend object that defines a multicolor linear gradient.
**
** History:
**  2006/03/07: Auto Generated
**	2006/06/13: BDurban - Coded
*********************************************************************
LPARAMETERS toColorBlend AS xfcColorBlend

*!ToDo: Test this function
LOCAL lqColors, lqPositions, liCount

LOCAL loExc AS Exception
TRY
	IF VARTYPE(toColorBlend) = "O"
		m.lqColors = m.toColorBlend.Colors(0h)
		m.lqPositions = m.toColorBlend.Positions(0h)
		m.liCount = LEN(m.lqColors)/4
		This.SetStatus(GdipSetPathGradientPresetBlend(This.Handle, m.lqColors, m.lqPositions, m.liCount))
	ENDIF
CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL

ENDPROC
PROCEDURE multiplytransform
*********************************************************************
** Method: MultiplyTransform
**
** Multiplies the Matrix object that represents the local geometric transform of this
** PathGradientBrush by the specified Matrix by prepending the specified Matrix.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/10: BDurban - Coded
*********************************************************************
LPARAMETERS toMatrix AS xfcMatrix, ;
			tiOrder AS EnumMatrixOrder

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	m.tiOrder = EVL(m.tiOrder, MatrixOrderPrepend)
	This.SetStatus(GdipMultiplyPathGradientTransform(This.Handle, m.toMatrix.Handle, m.tiOrder))

CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.PathGradientBrush.MultiplyTransform%28vs.80%29.aspx
** Parameters:
**  Matrix matrix
**  Matrix matrix, MatrixOrder order
** Returns: void
*********************************************************************

ENDPROC
PROCEDURE new
LPARAMETERS taoPoints AS xfcPoint, ;
			tiWrapMode AS EnumWrapMode
*********** toPath AS xfcGraphicsPath

RETURN This.CreateNew(This.Class, @taoPoints, tiWrapMode)
ENDPROC
PROCEDURE rectangle_access
*********************************************************************
** Property: Rectangle (Access)
**
** Gets a bounding rectangle for this PathGradientBrush object.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/10: BDurban - Coded
*********************************************************************

*!ToDo: Test this function

LOCAL loRectangleF AS xfcRectangleF
m.loRectangleF = NULL

LOCAL loExc AS Exception
TRY
	LOCAL lqRect
	m.lqRect = EMPTY_RECTANGLE
	This.SetStatus(GdipGetPathGradientRect(This.Handle, @lqRect))
*!*	This.SetStatus(GdipGetPathGradientRectI(This.Handle, @lqRect))
	m.loRectangleF = This.CreateNew("xfcRectangleF", lqRect)
CATCH TO loExc
	THROW m.loExc
ENDTRY
RETURN m.loRectangleF

** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.PathGradientBrush.Rectangle%28vs.80%29.aspx
** Returns: RectangleF
*********************************************************************

ENDPROC
PROCEDURE resettransform
*********************************************************************
** Method: ResetTransform
**
** Resets the Transform property to identity.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/10: BDurban - Coded
*********************************************************************

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY

	This.SetStatus(GdipResetPathGradientTransform(This.Handle))

CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.PathGradientBrush.ResetTransform%28vs.80%29.aspx
** Parameters:
**  [None]
** Returns: void
*********************************************************************

ENDPROC
PROCEDURE rotatetransform
*********************************************************************
** Method: RotateTransform
**
** Applies a clockwise rotation of the specified angle to the local geometric transform.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/10: BDurban - Coded
*********************************************************************
LPARAMETERS tnAngle, ;
			tiOrder AS EnumMatrixOrder

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	m.tiOrder = EVL(m.tiOrder, MatrixOrderPrepend)
	This.SetStatus(GdipRotatePathGradientTransform(This.Handle, m.tnAngle, m.tiOrder))

CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.PathGradientBrush.RotateTransform%28vs.80%29.aspx
** Parameters:
**  float angle
**  float angle, MatrixOrder order
** Returns: void
*********************************************************************

ENDPROC
PROCEDURE scaletransform
*********************************************************************
** Method: ScaleTransform
**
** Scales the local geometric transform by the specified amounts. This method prepends
** the scaling matrix to the transform.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/10: BDurban - Coded
*********************************************************************
LPARAMETERS tnSx, tnSy, ;
			tiOrder AS EnumMatrixOrder

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	m.tiOrder = EVL(m.tiOrder, MatrixOrderPrepend)
	This.SetStatus(GdipScalePathGradientTransform(This.Handle, m.tnSx, m.tnSy, m.tiOrder))

CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.PathGradientBrush.ScaleTransform%28vs.80%29.aspx
** Parameters:
**  float sx, float sy
**  float sx, float sy, MatrixOrder order
** Returns: void
*********************************************************************

ENDPROC
PROCEDURE setblendtriangularshape
*********************************************************************
** Method: SetBlendTriangularShape
**
** Creates a gradient with a center color and a linear falloff to one surrounding color.
**
** History:
**  2006/03/07: Auto Generated
**	2006/06/09: BDurban - Coded
*********************************************************************
LPARAMETERS tnFocus, ;
			tnScale

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	m.tnScale = EVL(m.tnScale, 0)
	This.SetStatus(GdipSetPathGradientLinearBlend(This.Handle, m.tnFocus, m.tnScale))

CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.PathGradientBrush.SetBlendTriangularShape%28vs.80%29.aspx
** Parameters:
**  float focus
**  float focus, float scale
** Returns: void
*********************************************************************

ENDPROC
PROCEDURE setsigmabellshape
*********************************************************************
** Method: SetSigmaBellShape
**
** Creates a gradient falloff between the center color and the first surrounding color
** based on a bell-shaped curve.
**
** History:
**  2006/03/07: Auto Generated
**	2006/06/13: BDurban - Coded
*********************************************************************
LPARAMETERS tnFocus, ;
			tnScale

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	m.tnScale = EVL(m.tnScale, 0.0)
	This.SetStatus(GdipSetPathGradientSigmaBlend(This.Handle, m.tnFocus, m.tnScale))

CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.PathGradientBrush.SetSigmaBellShape%28vs.80%29.aspx
** Parameters:
**  float focus
**  float focus, float scale
** Returns: void
*********************************************************************

ENDPROC
PROCEDURE surroundcolors_access
*********************************************************************
** Property: SurroundColors (Access)
**
** Gets or sets an array of colors that correspond to the points in the path this PathGradientBrush
** object fills.
**
** History:
**  2006/03/07: Auto Generated
**	2006/06/09: BDurban - Coded
**  2006/09/06: CChalom - Fixed
*********************************************************************
LPARAMETERS tiIndex

*!ToDo: Test this function
LOCAL loColor AS xfcColor
LOCAL liCount, lqColors, liArgb

LOCAL loExc AS Exception
TRY
	m.liCount = 0
	m.loColor = NULL
	This.SetStatus(GdipGetPathGradientSurroundColorCount(This.Handle, @liCount))
	m.tiIndex = EVL(m.tiIndex, 1)
	
	IF m.tiIndex > m.liCount
		*! ToDo ERROR
	ELSE
		m.lqColors = REPLICATE(0h00000000,liCount)
		This.SetStatus(GdipGetPathGradientSurroundColorsWithCount(This.Handle, @lqColors, @liCount))
		
		m.liArgb = CTOBIN(SUBSTR(m.lqColors, (m.tiIndex-1)*4+1, 4), "4rs")
		m.loColor = This.CreateNew("xfcColor", liArgb)
	ENDIF
	
CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN m.loColor


LOCAL loColor[1], liArgb
m.liArgb = 0
m.loColor[1] = NULL

LOCAL loExc AS Exception
TRY
	LOCAL lnFunctionType
	m.lnFunctionType = 0
	
	DO CASE
	CASE m.lnFunctionType = 1
		This.SetStatus(GdipGetPathGradientSurroundColorsWithCount(This.Handle, @liColor, @liCount))
	CASE m.lnFunctionType = 2
		This.SetStatus(GdipGetPathGradientSurroundColorCount(This.Handle, @liCount))
	ENDCASE
		m.loColor[1] = This.CreateNew("xfcColor[]")
		m.loColor[1].FromARGB(m.liArgb)
CATCH TO loExc
	THROW m.loExc
ENDTRY
RETURN m.loColor[1]

** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.PathGradientBrush.SurroundColors%28vs.80%29.aspx
** Returns: Color[]
*********************************************************************
ENDPROC
PROCEDURE surroundcolors_assign
*********************************************************************
** Property: SurroundColors (Assign)
**
** Gets or sets an array of colors that correspond to the points in the path this PathGradientBrush
** object fills.
**
** History:
**  2006/03/07: Auto Generated
**	2006/06/09: BDurban - Coded
*********************************************************************
LPARAMETERS toColor AS xfcColor, tiIndex

*!ToDo: Test this function
LOCAL loColor AS xfcColor
LOCAL liCount, lqColors

LOCAL loExc AS Exception
TRY
	IF VARTYPE(m.toColor) = "O"
		liCount = 0
		This.SetStatus(GdipGetPathGradientSurroundColorCount(This.Handle, @liCount))
		
		IF m.tiIndex > m.liCount
			*! ToDo ERROR
		ELSE
			m.lqColors = REPLICATE(0h00000000,liCount)
			This.SetStatus(GdipGetPathGradientSurroundColorsWithCount(This.Handle, @lqColors, @liCount))
			m.lqColors = STUFF(m.lqColors, (m.tiIndex-1)*4+1, 4, BINTOC(toColor.ToArgb(),"4rs"))
			This.SetStatus(GdipSetPathGradientSurroundColorsWithCount(This.Handle, @lqColors, @liCount))
		ENDIF
	ENDIF	
CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL

ENDPROC
PROCEDURE transform_access
*********************************************************************
** Property: Transform (Access)
**
** Gets or sets a Matrix object that defines a local geometric transform for this PathGradientBrush
** object.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/10: BDurban - Coded
*********************************************************************

*!ToDo: Test this function

LOCAL loMatrix AS xfcMatrix, lhMatrix
m.lhMatrix = 0
m.loMatrix = NULL

LOCAL loExc AS Exception
TRY
	This.SetStatus(GdipGetPathGradientTransform(This.Handle, m.lhMatrix))
	IF(m.lhMatrix <> 0)
		m.loMatrix = This.CreateNew("xfcMatrix")
		m.loMatrix.Handle = m.lhMatrix
	ENDIF
CATCH TO loExc
	THROW m.loExc
ENDTRY
RETURN m.loMatrix

** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.PathGradientBrush.Transform%28vs.80%29.aspx
** Returns: Matrix
*********************************************************************

ENDPROC
PROCEDURE transform_assign
*********************************************************************
** Property: Transform (Assign)
**
** Gets or sets a Matrix object that defines a local geometric transform for this PathGradientBrush
** object.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/10: BDurban - Coded
*********************************************************************
LPARAMETERS toMatrix

*!ToDo: Test this function
LOCAL lhHandle

LOCAL loExc AS Exception
TRY
	m.lhHandle = IIF(VARTYPE(m.toMatrix)="O",m.toMatrix.Handle,0)
	This.SetStatus(GdipSetPathGradientTransform(This.Handle, m.lhHandle))
CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL
ENDPROC
PROCEDURE translatetransform
*********************************************************************
** Method: TranslateTransform
**
** Applies the specified translation to the local geometric transform. This method
** prepends the translation to the transform.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/10: BDurban - Coded
*********************************************************************
LPARAMETERS tnDx, tnDy, ;
			tiOrder AS EnumMatrixOrder

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	m.tiOrder = EVL(m.tiOrder, MatrixOrderPrepend)
	This.SetStatus(GdipTranslatePathGradientTransform(This.Handle, m.tnDx, m.tnDy, m.tiOrder))
CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL


** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.PathGradientBrush.TranslateTransform%28vs.80%29.aspx
** Parameters:
**  float dx, float dy
**  float dx, float dy, MatrixOrder order
** Returns: void
*********************************************************************

ENDPROC
PROCEDURE wrapmode_access
*********************************************************************
** Property: WrapMode (Access)
**
** Gets or sets a WrapMode enumeration that indicates the wrap mode for this PathGradientBrush
** object.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/10: BDurban - Coded
*********************************************************************

*!ToDo: Test this function

LOCAL liWrapMode
m.liWrapMode = 0

LOCAL loExc AS Exception
TRY
	This.SetStatus(GdipGetPathGradientWrapMode(This.Handle, @liWrapmode))

CATCH TO loExc
	THROW m.loExc
ENDTRY
RETURN m.liWrapMode

** .NET Help ********************************************************
** http://msdn2.microsoft.com/en-us/library/System.Drawing.Drawing2D.PathGradientBrush.WrapMode%28vs.80%29.aspx
** Returns: WrapMode
*********************************************************************

ENDPROC
PROCEDURE wrapmode_assign
*********************************************************************
** Property: WrapMode (Assign)
**
** Gets or sets a WrapMode enumeration that indicates the wrap mode for this PathGradientBrush
** object.
**
** History:
**  2006/03/07: Auto Generated
**	2006/05/10: BDurban - Coded
*********************************************************************
LPARAMETERS tiWrapMode

*!ToDo: Test this function

LOCAL loExc AS Exception
TRY
	This.SetStatus(GdipSetPathGradientWrapMode(This.Handle, m.tiWrapmode))
CATCH TO loExc
	THROW m.loExc
ENDTRY

RETURN NULL
ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
blend Gets or sets a Blend object that specifies positions and factors that define a custom falloff for the gradient.
centercolor Gets or sets the color at the center of the path gradient.
centerpoint Gets or sets the center point of the path gradient.
focusscales Gets or sets the focus point for the gradient falloff.
interpolationcolors Gets or sets a ColorBlend object that defines a multicolor linear gradient.
rectangle Gets a bounding rectangle for this PathGradientBrush object.
transform Gets or sets a Matrix object that defines a local geometric transform for this PathGradientBrush object.
wrapmode Gets or sets a WrapMode enumeration that indicates the wrap mode for this PathGradientBrush object.
^surroundcolors[1,0] Gets or sets an array of colors that correspond to the points in the path this PathGradientBrush object fills.
*multiplytransform Multiplies the Matrix object that represents the local geometric transform of this PathGradientBrush by the specified Matrix by prepending the specified Matrix.
*resettransform Resets the Transform property to identity.
*rotatetransform Applies a clockwise rotation of the specified angle to the local geometric transform.
*scaletransform Scales the local geometric transform by the specified amounts. This method prepends the scaling matrix to the transform.
*setblendtriangularshape Creates a gradient with a center color and a linear falloff to one surrounding color.
*setsigmabellshape Creates a gradient falloff between the center color and the first surrounding color based on a bell-shaped curve.
*translatetransform Applies the specified translation to the local geometric transform. This method prepends the translation to the transform.
*blend_access 
*blend_assign 
*centercolor_access 
*centercolor_assign 
*centerpoint_access 
*centerpoint_assign 
*focusscales_access 
*focusscales_assign 
*interpolationcolors_access 
*interpolationcolors_assign 
*rectangle_access 
*surroundcolors_access 
*surroundcolors_assign 
*transform_access 
*transform_assign 
*wrapmode_access 
*wrapmode_assign 
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED8]
drawing.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] xfcpathgradientbrush
[START RESERVED1]
 	 drawing.h^„M5 system.hf0•Ô4 gdiplusconstants.hnÎi05[END RESERVED1]
[EOF]
