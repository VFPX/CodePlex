SCCTEXT Version 4.0.0.2
PLATFORM C(8,0),UNIQUEID C(10,0),TIMESTAMP N(10,0),CLASS M(4,0),CLASSLOC M(4,0),BASECLASS M(4,0),OBJNAME M(4,0),PARENT M(4,0),PROPERTIES M(4,0),PROTECTED M(4,0),METHODS M(4,0),OBJCODE M(4,0),OLE M(4,0),OLE2 M(4,0),RESERVED1 M(4,0),RESERVED2 M(4,0),RESERVED3 M(4,0),RESERVED4 M(4,0),RESERVED5 M(4,0),RESERVED6 M(4,0),RESERVED7 M(4,0),RESERVED8 M(4,0),USER M(4,0)
1252

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] Class     
[START RESERVED1]
VERSION =   3.00[END RESERVED1]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1890LRE8T
[CLASS] shape
[BASECLASS] shape
[OBJNAME] splitter2
[START PROPERTIES]
Height = 4
Width = 100
MousePointer = 7
SpecialEffect = 0
rangemin = 0.2
rangemax = 0.8
Name = "splitter2"
[END PROPERTIES]
[START PROTECTED]
readme^
hidecontrols^
showcontrols^
hiddencontrols^
Init
MouseDown
[END PROTECTED]
[START METHODS]
PROCEDURE Destroy
* decrement instance counter, if 0 release object (this.release Dlls)

If type("_screen.___SplitterApi")="O" AND !ISNULL(_screen.___SplitterApi)
	_screen.___SplitterApi.nInstances = _screen.___SplitterApi.nInstances - 1
	If _screen.___SplitterApi.nInstances <= 0
		_screen.___SplitterApi.nInstances = .Null.
		_screen.RemoveObject("___SplitterApi")
	Endif
Endif


ENDPROC
PROCEDURE Init
* API FUNCTIONS - declare only one for all splitter with this class

IF !VARTYPE(_SCREEN.___SplitterApi)="O"
	IF AT(UPPER((this.ClassLibrary)),UPPER(SET("Classlib")))=0
		SET CLASSLIB TO (this.ClassLibrary) ADDITIVE
	ENDIF 	
	_SCREEN.AddObject("___SplitterApi","SplitterAPI")
ELSE
	_SCREEN.___SplitterApi.nInstances = _SCREEN.___SplitterApi.nInstances + 1	
ENDIF
RETURN VARTYPE(_SCREEN.___SplitterApi)="O"

ENDPROC
PROCEDURE MouseDown
Lparameters nButton, nShift, nXCoord, nYCoord
Local lcWindowName,lnScaleMode,lnMinRow,lnMaxRow,lnMRow1,lnMRow2
Local lnRows,lnTop,lnOldTop,lnMin,oldMRow2
Local llLockScreen,lnMousePointer
Local lhDC,lhMemDC,lhMemBmp,lHWnd,lnBmpHeight,nLeftOffset,nTopOffset,oContainer,xHeight
Local lcOldFormName,lhMemSplit

If nButton#1
   Return
Endif

lcOldFormName = Thisform.Name
Thisform.Name = Sys(2015)

lcWindowName=Thisform.Name
lnScaleMode=Thisform.ScaleMode
Thisform.ScaleMode=3  && pixels

oContainer=This.Parent
nLeftOffset=Objtoclient(This,2)-This.Left
nTopOffset=Objtoclient(This,1)-This.Top

lnMRow1=Mrow(lcWindowName,3)
If Type("lnMRow1")#"N" Or lnMRow1<=0
   Thisform.ScaleMode=lnScaleMode
   Thisform.Name = lcOldFormName
   Return
Endif

lnMRow1=lnMRow1-nTopOffset
If lnMRow1 <> This.Top+1
   lnMRow1 = This.Top+1
   Mouse At lnMRow1+nTopOffset, Mcol(lcWindowName,3) Pixels Window (lcWindowName)
Endif

* set some vars
llLockScreen=Thisform.LockScreen
lnMousePointer=Thisform.MousePointer
Thisform.MousePointer= 7
lnTop=This.Top

* check two parent level for Height- suppose that parent form always present
If Pemstatus(oContainer,"Height",5)
   xHeight	=	oContainer.Height
Else
   If Pemstatus(oContainer.Parent,"PageHeight",5)
      xHeight	=	oContainer.Parent.PageHeight
   Else
      * if error that oContainer.Height and oContainer.parent.width not exist, something wrong
      xHeight	=	oContainer.Parent.Height
   Endif
Endif

* RangeMin (RangeMax) < 1
* 		RangeMin (RangeMax) are used as coeficient (%/100)
* RangeMin (RangeMax) > 1
*		RangeMin (RangeMax) are used as absolute offset in pixels
* RangeMin (RangeMax) =0
*		RangeMin (RangeMax) are ignored - no restriction
Do Case
   Case This.RangeMin <= 0
      lnMinRow=This.Height*2
   Case This.RangeMin > 1
      lnMinRow=Max(This.Height*2,Int(This.RangeMin))
   Case This.RangeMin < 1
      lnMinRow=Max(This.Height*2,Int(This.RangeMin*xHeight))
Endcase

Do Case
   Case This.RangeMax <= 0
      lnMaxRow=xHeight-(This.Height*3)
   Case This.RangeMax > 1
      lnMaxRow=Min(xHeight-(This.Height*3),This.RangeMax)
   Case This.RangeMax < 1
      lnMaxRow=Min(xHeight-(This.Height*3),This.RangeMax*xHeight)
Endcase

If lnMinRow>lnMaxRow
   * nothing to move!!!
   Thisform.ScaleMode=lnScaleMode
   Thisform.Name = lcOldFormName
   Return
Endif

lnMRow2=lnMRow1
oldMRow2=lnMRow2

#Define SRCCOPY		13369376

* API CALLS
If Thisform.ShowWindow= 2
   * workaround, when showwindow=2 the handle is not the right one...
   * worst if you have a toolbar!
   *#define GW_HWNDFIRST        0
   #Define GW_HWNDLAST         1
   *#define GW_HWNDNEXT         2
   *#define GW_HWNDPREV         3
   *#define GW_OWNER            4
   #Define GW_CHILD            5

   lHWnd=Thisform.HWnd
   lHWnd=GS_SplitGetWindow(lHWnd,GW_CHILD)
   lHWnd=GS_SplitGetWindow(lHWnd,GW_HWNDLAST)
Else
   lHWnd=Thisform.HWnd
Endif

lhDC = GS_SplitGetDC(lHWnd)
lhMemDC = GS_SplitCreateCompatibleDC(lhDC)
* Take a copy of the portion of the form that can be dragged over
lnBmpHeight=This.Height
lhMemBmp = GS_SplitCreateCompatibleBitmap(lhDC, This.Width, lnBmpHeight)
lhMemSplit = GS_SplitCreateCompatibleBitmap(lhDC, This.Width, lnBmpHeight)
= GS_SplitSelectObject(lhMemDC , lhMemBmp)
= GS_SplitBitBlt(lhMemDC, 0, 0,  This.Width, lnBmpHeight, ;
   lhDC, This.Left+nLeftOffset, lnMRow1-1+nTopOffset, SRCCOPY)
= GS_SplitSelectObject(lhMemDC , lhMemSplit)
= GS_SplitBitBlt(lhMemDC, 0, 0,  This.Width, lnBmpHeight, ;
   lhDC, This.Left+nLeftOffset, lnMRow1-1+nTopOffset, SRCCOPY)

* Stop fox drawing in the screen
Thisform.LockScreen=.T.
This.hidecontrols(oContainer)

* update the display while dragging
Do While Mdown()
   DoEvents
   lnMRow2=Mrow(lcWindowName,3)-nTopOffset
   If Type("lnMRow2")#"N" Or lnMRow2=0
      Loop
   Endif
   If lnMRow2<=lnMinRow
      *force the mouse to stay at this position
      Mouse At lnMinRow+nTopOffset, Mcol(lcWindowName,3) Pixels Window (lcWindowName)
      lnMRow2=lnMinRow+1
   Endif
   If lnMRow2>=(lnMaxRow-This.Height)
      *force the mouse to stay at this position
      Mouse At lnMaxRow-This.Height+nTopOffset, Mcol(lcWindowName,3) Pixels Window (lcWindowName)
      lnMRow2=lnMaxRow-This.Height
   Endif
   lnMRow2=Min(Max(lnMRow2,lnMinRow),lnMaxRow)
   If oldMRow2=lnMRow2
      Loop
   Else
      * on mouse move, redraw a part of the screen from the memory copy
      * and draw "this" image at the mouse position
      * bitblt (dest...source...)
      With This
         .Top=lnTop+(lnMRow2-lnMRow1)
         *restore
         = GS_SplitSelectObject(lhMemDC , lhMemBmp)
         = GS_SplitBitBlt(lhDC, .Left+nLeftOffset, oldMRow2-1+nTopOffset, .Width, .Height+3,;
            lhMemDC, 0, 0,  SRCCOPY)
         *take a new copy
         = GS_SplitBitBlt(lhMemDC, 0, 0,  This.Width, lnBmpHeight, ;
            lhDC, This.Left+nLeftOffset, lnMRow2-1+nTopOffset, SRCCOPY)
         *draw
         = GS_SplitSelectObject(lhMemDC , lhMemSplit)
         = GS_SplitBitBlt(lhDC, .Left+nLeftOffset, .Top+nTopOffset, .Width, .Height+1,;
            lhMemDC, 0, 0,  SRCCOPY)

      Endwith
      oldMRow2=lnMRow2
   Endif
Enddo

This.showcontrols()
Thisform.Name = lcOldFormName

If lnMRow2<0
   lnMRow2=lnMRow1
Endif

lnRows=lnMRow2-lnMRow1
This.Top=lnTop+lnRows
Thisform.ScaleMode=lnScaleMode
Thisform.MousePointer=lnMousePointer

This.Split()

Thisform.LockScreen=llLockScreen

* free the memory
= GS_SplitReleaseDC(lHWnd, lhDC)
= GS_SplitDeleteObject(lhMemBmp)
= GS_SplitDeleteObject(lhMemSplit)
= GS_SplitDeleteDC(lhMemDC)
ENDPROC
PROCEDURE hidecontrols
* hide all controls include ActiveX with property visible inside container tObject
* without this splitter and form

LPARAMETERS tObject,nIndex
*	tObject is root object, if not passed, thisform is used
IF EMPTY(nIndex)
	nIndex=2
ENDIF

LOCAL lcObjectBaseClass, lObject, lTempObject
* build collection hidden object for reverse setting in showcontrols
* set valid object
IF VARTYPE(tObject)="O"
	lObject= tObject
ELSE
	lObject= THISFORM
ENDIF

* ignore this splitter
IF lObject = THIS
	RETURN nIndex
ENDIF

* unify
lcObjectBaseClass = LOWER(lObject.BASECLASS)+" " && " " for unique (page # pageframe)

* do not hide form window
IF lcObjectBaseClass # "form " AND PEMSTATUS(lObject,"visible",5)
	IF lObject.VISIBLE
		DIMENSION this.HiddenControls[nIndex]
		this.hiddencontrols[nIndex]=lObject
		lObject.VISIBLE = .F.
		nIndex=nIndex+1
	ENDIF
ENDIF

* recurse for all children
DO CASE
	CASE INLIST(lcObjectBaseClass,"pageframe ")
		FOR EACH lTempObject IN lObject.PAGES
			nIndex=THIS.hidecontrols(lTempObject,nIndex)
		ENDFOR
	CASE INLIST(lcObjectBaseClass,"form ","container ","page ")
		FOR EACH lTempObject IN lObject.CONTROLS
			nIndex=THIS.hidecontrols(lTempObject,nIndex)
		ENDFOR
	CASE INLIST(lcObjectBaseClass,"commandgroup ","optiongroup ")
		FOR EACH lTempObject IN lObject.BUTTONS
			nIndex=THIS.hidecontrols(lTempObject,nIndex)
		ENDFOR
ENDCASE

RETURN nIndex+1
ENDPROC
PROCEDURE readme
*!*	Splitter class
*!*	May 2004

*!*	Active-X controls always drive me nuts because they use there own windows handle.
*!*	You cannot put a fox native control over them to resize the control visually.
*!*	You have to use some tricks like changing the control to
*!*	another one for this operation and rechange it back after.
*!*	( See the class browser code )

*!*	What I want is a splitter that can handle this in a visual way
*!*	while keeping the form (look) unchanged until the end of the split.

*!*	After many try and fail, I have finally found a way to do it
*!*	by the use of API calls. IT WORK!!!
*!* Days of work to end with only a couple of code lines :)

*!*	I am not an API guru, so if you find a way to improve this class
*!*	feel free to let me know how :)

*!*	Tested with VFP 8-7 on Windows 2000
*!*	(no animal other than the usual fox was used in the tests)
*!*	Disclaimer: (...) <- put the usual disclaimer here!

*!*	Gérald Santerre
*!*	gerald.santerre@siteintranet.qc.ca


*!*		USAGE:

*!*		Drop this class on a form or a container between the objects that share the container.

*!*	New release, complete redesing.
*!*	If you already use a previous version of the class, read this carefully.
*!*	I have removed a couple of properties and change the way the classes work.
*!*	For this reason I have also renamed the classlib to avoid conflicts
*!*	with previous version of the class. The new design is cleaner and the control
*!*	don't touch anything in the form (except hiding controls during split).

*!*	A large part of the new design is from suggestions received
*!*	from "Jaromír Stacha" from Czech Republic.
*!*		Thank you Jaromir :).

*!*	The new splitter classes don't move or resize controls anymore.
*!*	The splitter.split() method is always called after a split operation
*!*	and you have to resize/reposition your controls from this (fake)event.
*!*	If you don't put code in the split() method, the form.resize() event
*!*	of the form will be called. See the resize() and splitter1.split()
*!*	method of the demo form for a working sample.

*!*	You have only 2 properties to set in the class,
*!*	RangeMin and RangeMax.
*!*	If you set the value of this properties between 0 and 1,
*!*	the value is handled as a % of the splitter's parent container width ot height.
*!*	For example, if you enter 0.2 as value for RangeMin,
*!*	you will be able to move the splitter down to 20% of the width/height
*!*	of the splitter's parent container.
*!*	Values greater than 1 will be handle as absolute values.
*!*	Don't forget to reset absolute values when the splitter's parent container is resized.

*!*	The splitter API is now self contained and you dont have
*!*	to worry about releasing the references to API functions.
*!*	The splitter now also handle correctly multiple instances
*!*	of the same form (or forms with the same name).
*!*	The splitter automatically hide every controls that are in
*!*	the same parent container (recursive) to avoid side effects
*!*	(like mouse cursor beam over text boxes).

*!*	Contact: gerald.santerre@siteintranet.qc.ca

ENDPROC
PROCEDURE showcontrols
* show temporary hidden objects and clear list (collection)
LPARAMETERS toRoot

IF ALEN(THIS.hiddencontrols,1)<2
	RETURN
ENDIF
FOR i=2 TO ALEN(THIS.hiddencontrols,1)
	IF TYPE("THIS.hiddencontrols[i]")="O"
		THIS.hiddencontrols[i].Visible=.T.
	ENDIF 	
ENDFOR

DIMENSION THIS.hiddencontrols[1]

ENDPROC
PROCEDURE split
*default behaviour
THISFORM.RESIZE()
ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
rangemin The splitter can be dragged to the top down to this value. Value < 1 is percent of parent height.
rangemax The splitter can be dragged to the bottom up to this value. Pixels from the top of the parent. Value < 1 is percent of parent height.
*readme 
*hidecontrols internal use
*showcontrols internal use
*split This method is called at the end of the split operation.
^hiddencontrols[1,1] Array of controls
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED7]
Up-Down Splitter class. Support ActiveX controls. Author: gerald.santerre@siteintranet.qc.ca[END RESERVED7]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] splitter2

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1AD1ADSOF
[CLASS] custom
[BASECLASS] custom
[OBJNAME] splitterapi
[START PROPERTIES]
Height = 15
Width = 27
ninstances = 1
Name = "splitterapi"
[END PROPERTIES]
[START METHODS]
PROCEDURE Destroy
Clear Dlls	;
	"GS_SplitGetDC",;
	"GS_SplitCreateCompatibleDC",;
	"GS_SplitCreateCompatibleBitmap",;
	"GS_SplitSelectObject",;
	"GS_SplitReleaseDC",;
	"GS_SplitDeleteDC",;
	"GS_SplitBitBlt",;
	"GS_SplitGetWindow",;
	"GS_SplitDeleteObject"
ENDPROC
PROCEDURE Init
Declare Long GetDC					in Win32API as GS_SplitGetDC Long hwnd
Declare Long CreateCompatibleDC		in Win32API as GS_SplitCreateCompatibleDC Long hdc
Declare Long CreateCompatibleBitmap in Win32API as GS_SplitCreateCompatibleBitmap  Long hdc, Long nWidth, Long nHeight
Declare Long SelectObject 			in Win32API as GS_SplitSelectObject  Long hdc, Long hObject
Declare Long ReleaseDC 				in Win32API as GS_SplitReleaseDC  Long hwnd, Long hdc
Declare Long DeleteDC 				in Win32API as GS_SplitDeleteDC  Long hdc
Declare Long BitBlt 				in Win32API as GS_SplitBitBlt  ;
	Long hDestDC, Long x, Long y, Long nWidth, Long nHeight, ;
	Long hSrcDC, Long xSrc, Long ySrc, Long dwRop
Declare INTEGER DeleteObject 		in Win32API as GS_SplitDeleteObject  Long hObject
DECLARE INTEGER GetWindow 			IN user32 as GS_SplitGetWindow  ;
    INTEGER hwnd,;
    INTEGER wFlag

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
ninstances
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED7]
Splitter API declaration class[END RESERVED7]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] splitterapi

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1U511766C
[CLASS] container
[BASECLASS] container
[OBJNAME] outlook2003bar
[START PROPERTIES]
Anchor = 15
Width = 200
Height = 400
imgfocusedselected = 
imgnotfocusedselected = 
imgfocusednotselected = 
maxshowedbuttons = 5
selectedbutton = 0
imgnotfocusednotselected = 
imgtitle = 
showedbuttons = 0
mnushowmoretext = Show more
mnushowlesstext = Show less
rgbfocusedselectedstart = (Rgb(247,192,91))
rgbfocusedselectedend = (Rgb(255,255,220))
rgbfocusednotselectedstart = (Rgb(255,255,220))
rgbfocusednotselectedend = (Rgb(247,192,91))
rgbnotfocusedselectedstart = (Rgb(250,229,147))
rgbnotfocusedselectedend = (Rgb(238,149,21))
rgbnotfocusednotselectedstart = (Rgb(203,225,252))
rgbnotfocusednotselectedend = (Rgb(126,165,224))
rgbtitlestart = (Rgb(85,131,211))
rgbtitleend = (Rgb(8,60,161))
rgbborder = (Rgb(0,45,150))
imgsplitbar = 
themenumber = 0
themessupport = (Null)
version = 1.0.1
Name = "outlook2003bar"
[END PROPERTIES]
[START PROTECTED]
themessupport^
version
addbutton^
selectedbutton_assign^
rearrangebuttons^
setcolorscheme^
creategradientimage^
themenumber_assign^
themessupport_access^
deletefiles^
[END PROTECTED]
[START METHODS]
PROCEDURE Destroy
If This.ThemesSupport
   Unbindevents(0, 0x031A)
Endif
ENDPROC
PROCEDURE Init
With Thisform
   .MinHeight = This.Height + 4
   .MinWidth = This.Width + 4
   .ShowTips = .T.
Endwith

With This
   .ImgFocusedSelected = Addbs(Sys(2023))+Sys(2015)+".bmp"
   .ImgFocusedNotSelected = Addbs(Sys(2023))+Sys(2015)+".bmp"
   .ImgNotFocusedSelected = Addbs(Sys(2023))+Sys(2015)+".bmp"
   .ImgNotFocusedNotSelected = Addbs(Sys(2023))+Sys(2015)+".bmp"
   .ImgTitle = Addbs(Sys(2023))+Sys(2015)+".bmp"
   .ImgSplitBar = Addbs(Sys(2023))+Sys(2015)+".bmp"
   .SetColorScheme()
   With .Panes
      Local loPane
      For Each loPane In .Pages
         This.AddButton(loPane.Caption,loPane.Picture24,loPane.Picture16)
      Endfor
      loPane = Null
   Endwith
   If .ThemesSupport
      Bindevent(0, 0x031A, This, "SetColorScheme")
   Endif
   Bindevent(This, "Destroy", This, "DeleteFiles")
Endwith
ENDPROC
PROCEDURE addbutton
Lparameters lcCaption, lcPicture24, lcPicture16
Thisform.LockScreen = .T.
With This
   .Panel.AddButton(lcCaption, lcPicture24)
   .OverflowPanel.AddButton(lcCaption, lcPicture16)
   If .ShowedButtons<.MaxShowedButtons
      .ShowMore()
   Endif
   .AdjustSplitterLimits()
Endwith
Thisform.LockScreen = .F.
ENDPROC
PROCEDURE adjustpanelheight
Local lnTopoAtual, lnAlturaDoPainel, lnShowedButtons

With This
   With .Splitter
      .Anchor = 0
      lnTopoAtual = .Top
      Local lnResto
      Do While .T.
         lnAlturaDoPainel = .Parent.OverflowPanel.Top - 6 - lnTopoAtual
         lnResto = Mod(lnAlturaDoPainel,32)
         If lnResto <> 0
            lnTopoAtual = lnTopoAtual - (32 - lnResto)
         Else
            .Top = lnTopoAtual
            Exit
         Endif
      Enddo
      .Anchor = 14
   Endwith

   With .SplitBar
      .Anchor = 0
      .Top = lnTopoAtual
      .Anchor = 14
   Endwith

   With .Panes
      .Anchor = 0
      .Height = lnTopoAtual - .Top
      .Anchor = 15
   Endwith

   With .Panel
      .Anchor = 0
      .Top = lnTopoAtual + 6
      .Height = lnAlturaDoPainel
      .Anchor = 14
      lnShowedButtons = Int(lnAlturaDoPainel / 32)
   Endwith

   .ShowedButtons = lnShowedButtons
   .ReArrangeButtons()
Endwith
ENDPROC
PROCEDURE adjustsplitterlimits
With This
   With .Splitter
      .RangeMax = This.OverflowPanel.Top + 2
      .RangeMin = .RangeMax - .Height - 1 - ;
         (Min(This.Panel.ControlCount,This.MaxShowedButtons) * 32)
   Endwith
   .AdjustPanelHeight()
Endwith
ENDPROC
PROCEDURE creategradientimage
Lparameters lnRGBColor1, lnRGBColor2, lnGradPixels, lcGradFile
Local lnGradMode, lnGradPixels, x1, y1, x2, y2, lnWidth, lnHeight

lnGradMode = 1
Do Case
Case lnGradMode = 1 && Vertical
	x1 = 0
	y1 = 0
	x2 = 1
	y2 = lnGradPixels
Case lnGradMode = 2 && Horizontal
	x1 = 0
	y1 = 0
	x2 = lnGradPixels
	y2 = 1
Case lnGradMode = 3 && Diagonal TopLeft -> BottomRight
	x1 = 0
	y1 = 0
	x2 = lnGradPixels
	y2 = lnGradPixels
Case lnGradMode = 4 && Diagonal BottomLeft -> TopRight
	x1 = 0
	y1 = lnGradPixels
	x2 = lnGradPixels
	y2 = 0
Endcase

lnWidth  = Iif(lnGradMode = 1, 1, lnGradPixels)
lnHeight = Iif(lnGradMode = 2, 1, lnGradPixels)

* Create Gradient Image
Set Classlib To _gdiplus Additive

* Create a colorObject and store ARGB color values to variables
Local loClr As GpColor Of _gdiplus
Local lnColor1, lnColor2
loClr = Createobject("gpColor")
loClr.FoxRGB = lnRGBColor1
lnColor1 = loClr.ARGB
loClr.FoxRGB = lnRGBColor2
lnColor2 = loClr.ARGB

* Create a bitmap
Local loBmp As GpBitmap Of _gdiplus
loBmp = Createobject("gpBitmap")
loBmp.Create(lnWidth, lnHeight)

* Get a bitmab graphics object
Local loGfx As GpGraphics Of _gdiplus
loGfx = Createobject("gpGraphics")
loGfx.CreateFromImage(loBmp)

* Declare API
Declare Long GdipCreateLineBrushI In GDIPlus ;
	String point1, String point2, ;
	Long color1, Long color2, ;
	Long wrapMode, Long @lineGradient

* Get a gradient brush
Local loBrush As GpBrush Of _gdiplus
Local hBrush && Brush Handle
hBrush = 0
GdipCreateLineBrushI(BinToC(x1,"4rs")+BinToC(y1,"4rs"), ;
	BINTOC(x2,"4rs")+BinToC(y2,"4rs"), ;
	lnColor1, lnColor2, 0, @hBrush)
loBrush = Createobject("gpBrush")
loBrush.SetHandle(hBrush, .T.)

* Fill the bitmap with our gradient
loGfx.FillRectangle(loBrush,0,0,lnWidth, lnHeight)
loBmp.SaveToFile(lcGradFile,"image/bmp")

Return

ENDPROC
PROCEDURE deletefiles
Local laImages[6], lnImage
laImages[1] = This.ImgFocusedSelected
laImages[2] = This.ImgFocusedNotSelected
laImages[3] = This.ImgNotFocusedSelected
laImages[4] = This.ImgNotFocusedNotSelected
laImages[5] = This.ImgTitle
laImages[6] = This.ImgSplitBar
For lnImage=1 To Alen(laImages,1)
   If Not Empty(laImages[lnImage])
      If File(laImages[lnImage])
         Clear Resources (laImages[lnImage])
         Erase (laImages[lnImage])
      Endif
   Endif
Endfor
Unbindevents(This, "Destroy", This, "DeleteFiles")
ENDPROC
PROCEDURE rearrangebuttons
With This.OverflowPanel
   Local lnLeft, lnMaxShowedButtons, lnControlCount, lnControl, llVisible
   With .Menubutton
      lnLeft = .Left
      lnMaxShowedButtons = Int(.Left / .Width)
   Endwith
   lnControlCount = .ControlCount
   For lnControl=lnControlCount To 2 Step -1
      With .Controls(lnControl)
         llVisible = .F.
         If .TabIndex > This.ShowedButtons
            If lnControl <= (This.ShowedButtons + lnMaxShowedButtons + 1)
               lnLeft = lnLeft - .Width
               .Anchor = 0
               .Left = lnLeft
               .Anchor = 9
               llVisible = .T.
            Endif
         Endif
         .Visible = llVisible
      Endwith
   Endfor
Endwith
ENDPROC
PROCEDURE selectedbutton_assign
Lparameters vNewVal
With This
   Local lnOldSelectedButton, lcTitle
   lnOldSelectedButton = .SelectedButton
   .SelectedButton = m.vNewVal

   With .Panel
      If lnOldSelectedButton>0
         .Controls(lnOldSelectedButton).ChangeBackground()
      Endif
      .Controls(m.vNewVal).ChangeBackground()
      lcTitle = .Controls(m.vNewVal).lblCaption.Caption
   Endwith

   With .OverflowPanel
      If lnOldSelectedButton>0
         .Controls(lnOldSelectedButton+1).ChangeBackground()
      Endif
      .Controls(m.vNewVal+1).ChangeBackground()
   Endwith

   .Title.lblCaption.Caption = lcTitle
   .Panes.ActivePage = m.vNewVal
Endwith
ENDPROC
PROCEDURE setcolorscheme
Lparameters HWnd As Integer, Msg As Integer, ;
   wParam As Integer, Lparam As Integer)
With This
   Local lnTheme
   If .ThemeNumber==0 && Automatic
      lnTheme = 1 && Blue
      If .ThemesSupport
         Local lnSysColor
         Declare Integer GetSysColor In Win32Api Integer
         lnSysColor = GetSysColor(2)
         Clear Dlls GetSysColor
         Do Case
            Case lnSysColor == 12632256 && Silver
               lnTheme = 2
            Case lnSysColor == 6922635 && Olive
               lnTheme = 3
         Endcase
      Endif
   Else
      lnTheme = .ThemeNumber
   Endif

   If lnTheme <> 4 && Not user defined
      * Focused and selected
      .rgbFocusedSelectedStart = Rgb(247,192,91)
      .rgbFocusedSelectedEnd = Rgb(255,255,220)
      * Focused and not selected
      .rgbFocusedNotSelectedStart = Rgb(255,255,220)
      .rgbFocusedNotSelectedEnd = Rgb(247,192,91)
      * Not Focused and selected
      .rgbNotFocusedSelectedStart = Rgb(250,229,147)
      .rgbNotFocusedSelectedEnd = Rgb(238,149,21)
      Do Case
         Case lnTheme = 3 &&6922635 && Olive
            * Border
            .rgbBorder = Rgb(125,134,118)
            * Not Focused and not selected
            .rgbNotFocusedNotSelectedStart = Rgb(230,242,200)
            .rgbNotFocusedNotSelectedEnd = Rgb(175,191,144)
            * Title
            .rgbTitleStart = Rgb(174,188,137)
            .rgbTitleEnd = Rgb(104,119,74)
         Case lnTheme = 2 && 12632256 && Silver
            * Border
            .rgbBorder = Rgb(132,131,136)
            * Not Focused and not selected
            .rgbNotFocusedNotSelectedStart = Rgb(220,222,236)
            .rgbNotFocusedNotSelectedEnd = Rgb(152,152,177)
            * Title
            .rgbTitleStart = Rgb(166,167,189)
            .rgbTitleEnd = Rgb(118,117,153)
         Otherwise && Blue
            * Border
            .rgbBorder = Rgb(0,45,150)
            * Not Focused and not selected
            .rgbNotFocusedNotSelectedStart = Rgb(203,225,252)
            .rgbNotFocusedNotSelectedEnd = Rgb(126,165,224)
            * Title
            .rgbTitleStart = Rgb(85,131,211)
            .rgbTitleEnd = Rgb(8,60,161)
      Endcase
   Endif

   Local lnRgbBorder, laColors[6,4], loButton, lnImage
   lnRgbBorder = .rgbBorder

   * Focused and selected
   laColors[1,1] = .rgbFocusedSelectedStart
   laColors[1,2] = .rgbFocusedSelectedEnd
   laColors[1,3] = 32
   laColors[1,4] = .ImgFocusedSelected
   * Focused and not selected
   laColors[2,1] = .rgbFocusedNotSelectedStart
   laColors[2,2] = .rgbFocusedNotSelectedEnd
   laColors[2,3] = 32
   laColors[2,4] = .ImgFocusedNotSelected
   * Not Focused and selected
   laColors[3,1] = .rgbNotFocusedSelectedStart
   laColors[3,2] = .rgbNotFocusedSelectedEnd
   laColors[3,3] = 32
   laColors[3,4] = .ImgNotFocusedSelected
   * Not Focused and not selected
   laColors[4,1] = .rgbNotFocusedNotSelectedStart
   laColors[4,2] = .rgbNotFocusedNotSelectedEnd
   laColors[4,3] = 32
   laColors[4,4] = .ImgNotFocusedNotSelected

   * Title
   laColors[5,1] = .rgbTitleStart
   laColors[5,2] = .rgbTitleEnd
   laColors[5,3] = 32
   laColors[5,4] = .ImgTitle
   * SplitBar
   laColors[6,1] = .rgbTitleStart
   laColors[6,2] = .rgbTitleEnd
   laColors[6,3] = 7
   laColors[6,4] = .ImgSplitBar

   .Title.Picture = ""
   .SplitBar.Picture = ""
   For Each loButton In .Panel.Controls
      loButton.Picture = ""
   Endfor
   loButton = Null
   With .OverflowPanel
      .Picture = ""
      For Each loButton In .Controls
         loButton.Picture = ""
      Endfor
   Endwith
   loButton = Null

   For lnImage=Iif(Evl(Msg,0)==0,1,4) To 6
      If File(laColors[lnImage,4])
         Clear Resources (laColors[lnImage,4])
         Erase (laColors[lnImage,4])
      Endif
      .CreateGradientImage(laColors[lnImage,1], laColors[lnImage,2], ;
         laColors[lnImage,3], laColors[lnImage,4])
   Endfor

   .BorderColor = lnRgbBorder
   With .Title
      .BorderColor = lnRgbBorder
      .Picture = This.ImgTitle
      .linBorder.BorderColor = lnRgbBorder
   Endwith
   .Splitter.BorderColor = lnRgbBorder
   With .SplitBar
      .Picture = This.ImgSplitBar
      .BorderColor = lnRgbBorder
   Endwith
   With .Panel
      .BorderColor = lnRgbBorder
      For Each loButton In .Controls
         With loButton
            .ChangeBackground(.F.)
            .BorderColor = lnRgbBorder
            .linBorder.BorderColor = lnRgbBorder
         Endwith
      Endfor
   Endwith
   loButton = Null
   With .OverflowPanel
      .Picture = laColors[4,4]
      For Each loButton In .Controls
         loButton.ChangeBackground(.F.)
      Endfor
   Endwith
   loButton = Null
Endwith
Return .T.
ENDPROC
PROCEDURE showless
With This
   With .Splitter
      .Anchor = 0
      .Top = .Top + 32
   Endwith
   .AdjustPanelHeight()
Endwith
ENDPROC
PROCEDURE showmore
With This
   With .Splitter
      .Anchor = 0
      .Top = .Top - 32
   Endwith
   .AdjustPanelHeight()
Endwith
ENDPROC
PROCEDURE themenumber_assign
Lparameters vNewVal
If Between(vNewVal,0,4)
	This.ThemeNumber = m.vNewVal
Else
	This.ThemeNumber = 1
Endif
ENDPROC
PROCEDURE themessupport_access
With This
	If Isnull(.ThemesSupport)
		Local llThemesSupport
		llThemesSupport = .F.
		If .ThemeNumber==0 && Automatic
			If Os(3)=="5" And Os(4)=="1" && Windows XP
				Declare Long IsThemeActive In UXTHEME
				llThemesSupport = (IsThemeActive()==1)
				Clear Dlls IsThemeActive
			Endif
		Endif
		.ThemesSupport = llThemesSupport
	Endif
Endwith
Return This.ThemesSupport
ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
10[END RESERVED2]
[START RESERVED3]
imgfocusedselected Internal to the class. Name and path of the image to show in the background when button receives the focus and is selected.
imgnotfocusedselected Internal to the class. Name and path of the image to show in the background when button does not have focus and is selected.
imgfocusednotselected Internal to the class. Name and path of the image to show in the background when button receives the focus and is not selected.
maxshowedbuttons Maximum number of buttons displayed in the panel.
selectedbutton Internal to the class. The number of selected button.
imgnotfocusednotselected Internal to the class. Name and path of the image to show in the background when button does not have focus and is not selected.
imgtitle Internal to the class. Name and path of the image to show in the background of title.
showedbuttons Internal to the class. The number of showed buttons.
mnushowmoretext The text that is displayed in the "Show more" shortcut menu item.
mnushowlesstext The text that is displayed in the "Show less" shortcut menu item.
rgbfocusedselectedstart Start RGB color (for gradient effect) of focused and selected button.
rgbfocusedselectedend End RGB color (for gradient effect) of focused and selected button.
rgbfocusednotselectedstart Start RGB color (for gradient effect) of focused and not selected button.
rgbfocusednotselectedend End RGB color (for gradient effect) of focused and not selected button.
rgbnotfocusedselectedstart Start RGB color (for gradient effect) of not focused and selected button.
rgbnotfocusedselectedend End RGB color (for gradient effect) of not focused and selected button.
rgbnotfocusednotselectedstart Start RGB color (for gradient effect) of not focused and not selected button.
rgbnotfocusednotselectedend End RGB color (for gradient effect) of not focused and not selected button.
rgbtitlestart Start RGB color (for gradient effect) of title.
rgbtitleend End RGB color (for gradient effect) of title.
rgbborder RGB color of control borders.
imgsplitbar Internal to the class. Name and path of the image to show in the background of splitbar.
themenumber 0- Automatic, 1- Blue, 2- Silver, 3- Olive and 4- User defined.
themessupport Specifies if the OS support themes.
version Outlook2003Bar version.
*addbutton Internal to the class. Add a new button.
*selectedbutton_assign Internal to the class. Occurs when SelectedButton property is changed.
*adjustpanelheight Internal to the class. Adjust the panel height to show the buttons.
*rearrangebuttons Internal to the class. Rearrange buttons to show in correctly order and position.
*adjustsplitterlimits Internal to the class. Adjust splitter RangeMin and RangeMax limits.
*showmore Internal to the class. Show more buttons in the panel.
*showless Internal to the class. Show less buttons in the panel.
*setcolorscheme Set color scheme.
*creategradientimage Create a gradient image.
*themenumber_assign Internal to the class. Occurs when ThemeNumber property is changed.
*themessupport_access Internal to the class. Occurs when ThemesSupport property is accessed.
*deletefiles Delete background image files.
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1UA0ZOJ6Y
[CLASS] pageframe
[BASECLASS] pageframe
[OBJNAME] Panes
[PARENT] outlook2003bar
[START PROPERTIES]
ErasePage = .T.
MemberClassLibrary = outlook2003bar.vcx
MemberClass = "pane"
Anchor = 15
ActivePage = 0
BorderWidth = 0
Top = 33
Left = 1
Width = 198
Height = 328
SpecialEffect = 2
Tabs = .F.
Themes = .F.
Name = "Panes"
[END PROPERTIES]
[START METHODS]
PROCEDURE Init
With This
   .SetAll("BackColor",.Parent.BackColor,"Page")
Endwith
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1UI0ZLI4Z
[CLASS] overflowpanel
[CLASSLOC] outlook2003bar.vcx
[BASECLASS] container
[OBJNAME] OverflowPanel
[PARENT] outlook2003bar
[START PROPERTIES]
Anchor = 14
Top = 367
Left = 1
Width = 198
Height = 32
Name = "OverflowPanel"
MENUBUTTON.imgPicture.Height = 16
MENUBUTTON.imgPicture.Width = 16
MENUBUTTON.imgPicture.Name = "imgPicture"
MENUBUTTON.Name = "MENUBUTTON"
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1UL0MVPZW
[CLASS] container
[BASECLASS] container
[OBJNAME] SplitBar
[PARENT] outlook2003bar
[START PROPERTIES]
Anchor = 14
Top = 361
Left = 0
Width = 200
Height = 7
Name = "SplitBar"
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1UL0MVPZX
[CLASS] image
[BASECLASS] image
[OBJNAME] imgSplitter
[PARENT] outlook2003bar.SplitBar
[START PROPERTIES]
Anchor = 768
Picture = outlook2003barsplitter.png
BackStyle = 0
Height = 3
Left = 81
Top = 2
Width = 35
Name = "imgSplitter"
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1UI0T3625
[CLASS] panel
[CLASSLOC] outlook2003bar.vcx
[BASECLASS] container
[OBJNAME] Panel
[PARENT] outlook2003bar
[START PROPERTIES]
Anchor = 14
Top = 367
Left = 0
Name = "Panel"
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1U70SDUSY
[CLASS] splitter2
[CLASSLOC] outlook2003bar.vcx
[BASECLASS] shape
[OBJNAME] Splitter
[PARENT] outlook2003bar
[START PROPERTIES]
Top = 361
Left = 0
Height = 7
Width = 200
Anchor = 14
BackStyle = 0
SpecialEffect = 1
rangemax = 373
rangemin = 365
Name = "Splitter"
[END PROPERTIES]
[START METHODS]
PROCEDURE Move
Lparameters nLeft, nTop, nWidth, nHeight
DoDefault(nLeft, nTop, nWidth, nHeight)
This.Parent.AdjustSplitterLimits()
ENDPROC
PROCEDURE split
This.Parent.AdjustPanelHeight()
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1UL0Z9NJY
[CLASS] container
[BASECLASS] container
[OBJNAME] Title
[PARENT] outlook2003bar
[START PROPERTIES]
Anchor = 11
Top = 1
Left = 1
Width = 198
Height = 32
BorderWidth = 0
Name = "Title"
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1UL0Z9NK0
[CLASS] label
[BASECLASS] label
[OBJNAME] lblCaption
[PARENT] outlook2003bar.Title
[START PROPERTIES]
FontBold = .T.
FontSize = 12
BackStyle = 0
Caption = "Caption"
Height = 21
Left = 7
Top = 5
Width = 190
ForeColor = 255,255,255
Name = "lblCaption"
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1UL0Z9NJZ
[CLASS] line
[BASECLASS] line
[OBJNAME] linBorder
[PARENT] outlook2003bar.Title
[START PROPERTIES]
Anchor = 14
Height = 0
Left = 0
Top = 31
Width = 198
Name = "linBorder"
[END PROPERTIES]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] outlook2003bar

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1UI0RVHJW
[CLASS] container
[BASECLASS] container
[OBJNAME] panelbutton
[START PROPERTIES]
Width = 198
Height = 32
MousePointer = 15
Name = "panelbutton"
[END PROPERTIES]
[START METHODS]
PROCEDURE Click
This.ChangeSelectedButton()
ENDPROC
PROCEDURE Init
Lparameters lcCaption, lcPicture
Local lnBorderColor
With This
   lnBorderColor = .Parent.Parent.rgbBorder
   .Anchor = 0
   .BorderColor = lnBorderColor
   .Left = 1
   .Top = ((.TabIndex*(.Height))-.Height)
   .Anchor = 10

   .lblCaption.Caption = lcCaption
   .imgPicture.Picture = lcPicture

   .linBorder.BorderColor = lnBorderColor

   .ChangeBackground(.F.)

   .Visible = .T.
Endwith
ENDPROC
PROCEDURE MouseEnter
Lparameters nButton, nShift, nXCoord, nYCoord
This.ChangeBackground(.T.)
ENDPROC
PROCEDURE MouseLeave
Lparameters nButton, nShift, nXCoord, nYCoord
This.ChangeBackground(.F.)
ENDPROC
PROCEDURE changebackground
Lparameters llGotFocus
#Define lnFocused 8
#Define lnNotFocused 16
#Define lnSelected 32
#Define lnNotSelected 64
Local lnState, lcImage
With This.Parent.Parent
   lnState = (Iif(llGotFocus,lnFocused,lnNotFocused) + ;
      Iif(.SelectedButton==This.TabIndex,lnSelected,lnNotSelected))
   Do Case
      Case lnState = (lnFocused + lnSelected)
         lcImage = .ImgFocusedSelected
      Case lnState = (lnFocused + lnNotSelected)
         lcImage = .ImgFocusedNotSelected
      Case lnState = (lnNotFocused + lnSelected)
         lcImage = .ImgNotFocusedSelected
      Case lnState = (lnNotFocused + lnNotSelected)
         lcImage = .ImgNotFocusedNotSelected
      Otherwise
         lcImage = ""
   Endcase
Endwith
This.Picture = lcImage
ENDPROC
PROCEDURE changeselectedbutton
This.Parent.Parent.SelectedButton = This.TabIndex
ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
4[END RESERVED2]
[START RESERVED3]
*changeselectedbutton Change selected button.
*changebackground Change button's background image.
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1UI0S1HJY
[CLASS] label
[BASECLASS] label
[OBJNAME] lblCaption
[PARENT] panelbutton
[START PROPERTIES]
FontBold = .T.
Anchor = 10
BackStyle = 0
Caption = ""
Height = 17
Left = 38
MousePointer = 15
Top = 7
Width = 156
Name = "lblCaption"
[END PROPERTIES]
[START METHODS]
PROCEDURE Click
This.Parent.ChangeSelectedButton()
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1UL0SBSRB
[CLASS] line
[BASECLASS] line
[OBJNAME] linBorder
[PARENT] panelbutton
[START PROPERTIES]
Anchor = 14
Height = 0
Left = 0
MousePointer = 15
Top = 31
Width = 198
Name = "linBorder"
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1U50YQXZ3
[CLASS] image
[BASECLASS] image
[OBJNAME] imgPicture
[PARENT] panelbutton
[START PROPERTIES]
BackStyle = 0
Height = 24
Left = 4
MousePointer = 15
Top = 4
Width = 24
Name = "imgPicture"
[END PROPERTIES]
[START METHODS]
PROCEDURE Click
This.Parent.ChangeSelectedButton()
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] panelbutton

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1UI0SRLME
[CLASS] container
[BASECLASS] container
[OBJNAME] panel
[START PROPERTIES]
Width = 200
Height = 0
BackStyle = 0
Name = "panel"
[END PROPERTIES]
[START METHODS]
PROCEDURE addbutton
Lparameters lcCaption, lcPicture
With This
	.Newobject("Button"+Alltrim(Str(.ControlCount + 1)),;
		"PanelButton","Outlook2003Bar",,;
		lcCaption,lcPicture)
Endwith
ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*addbutton Add a new button to panel.
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] panel

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1UI0X0WD5
[CLASS] container
[BASECLASS] container
[OBJNAME] overflowpanel
[START PROPERTIES]
Width = 198
Height = 32
BorderWidth = 0
Name = "overflowpanel"
[END PROPERTIES]
[START METHODS]
PROCEDURE addbutton
Lparameters lcCaption, lcPicture
With This
	Local lnControlCount
	lnControlCount = .ControlCount + 1

	.Newobject("Button"+Alltrim(Str(lnControlCount - 1)),;
		"OverflowPanelButton","Outlook2003Bar",,;
		lcCaption,lcPicture)
Endwith
ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
2[END RESERVED2]
[START RESERVED3]
*addbutton Add a new button to panel.
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1UJ0JP1H1
[CLASS] overflowpanelbutton
[CLASSLOC] outlook2003bar.vcx
[BASECLASS] container
[OBJNAME] MenuButton
[PARENT] overflowpanel
[START PROPERTIES]
Anchor = 9
Left = 174
Name = "MenuButton"
imgPicture.Picture = outlook2003bararrow.png
imgPicture.Height = 16
imgPicture.Width = 16
imgPicture.Name = "imgPicture"
[END PROPERTIES]
[START METHODS]
PROCEDURE Destroy
With This
   .ShortcutMenu.ClearMenu()
   .ShortcutMenu = Null
Endwith
ENDPROC
PROCEDURE Init
Nodefault
This.AddProperty("ShortcutMenu",Newobject("_ShortcutMenu","_menu"))
ENDPROC
PROCEDURE changeselectedbutton
Local lnButtonCount
lnButtonCount = This.Parent.ControlCount - 1
If lnButtonCount > 0
   Private loBar
   loBar = This.Parent.Parent
   With This.ShortcutMenu
      .NewMenu()
      Local laMenu[lnButtonCount, 2]
      laMenu=""
      Local loButton
      For Each loButton In This.Parent.Controls
         With loButton
            If Upper(.Class) == Upper("OverflowPanelButton") And .Name <> This.Name
               laMenu[.TabIndex, 1] = .imgPicture.ToolTipText
               laMenu[.TabIndex, 2] = .imgPicture.Picture
            Endif
         Endwith
      Endfor
      loButton = Null
      Local lnMenuItem
      For lnMenuItem=1 To Alen(laMenu,1)
         .AddMenuBar( laMenu[lnMenuItem, 1], ;
            "loBar.Selectedbutton = Bar()", ;
            "Picture '" + laMenu[lnMenuItem, 2] + "'",,;
            .F.,.F.,(lnMenuItem==loBar.Selectedbutton) )
      Endfor
      .AddMenuSeparator()
      .AddMenuBar(loBar.mnuShowMoreText,;
         "loBar.ShowMore()",,,.F.,;
         loBar.Showedbuttons>=Min(lnButtonCount,loBar.MaxShowedbuttons),.F.)
      .AddMenuBar(loBar.mnuShowLessText,;
         "loBar.ShowLess()",,,.F.,;
         loBar.Showedbuttons=0,.F.)
      .ShowMenu()
      .SetMenu()
   Endwith
   Release loBar
Endif
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] overflowpanel

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1UI0X1J9D
[CLASS] container
[BASECLASS] container
[OBJNAME] overflowpanelbutton
[START PROPERTIES]
Width = 24
Height = 32
BorderWidth = 0
MousePointer = 15
Name = "overflowpanelbutton"
[END PROPERTIES]
[START METHODS]
PROCEDURE Click
This.ChangeSelectedButton()
ENDPROC
PROCEDURE Init
Lparameters lcToolTipText, lcPicture
With This
   .TabIndex = .TabIndex - 1
   .Top = 0
   .SetAll("ToolTipText",lcToolTipText)
   .imgPicture.Picture = lcPicture

   If .TabIndex == 1
      .ChangeSelectedButton()
   Else
      .ChangeBackground(.F.)
   Endif
Endwith
ENDPROC
PROCEDURE MouseEnter
Lparameters nButton, nShift, nXCoord, nYCoord
This.ChangeBackground(.T.)
ENDPROC
PROCEDURE MouseLeave
Lparameters nButton, nShift, nXCoord, nYCoord
This.ChangeBackground(.F.)
ENDPROC
PROCEDURE changebackground
Lparameters llGotFocus
#Define lnFocused 8
#Define lnNotFocused 16
#Define lnSelected 32
#Define lnNotSelected 64
Local lnState, lcImage
With This.Parent.Parent
   lnState = (Iif(llGotFocus,lnFocused,lnNotFocused) + ;
      Iif(.SelectedButton==This.TabIndex,lnSelected,lnNotSelected))
   Do Case
      Case lnState = (lnFocused + lnSelected)
         lcImage = .ImgFocusedSelected
      Case lnState = (lnFocused + lnNotSelected)
         lcImage = .ImgFocusedNotSelected
      Case lnState = (lnNotFocused + lnSelected)
         lcImage = .ImgNotFocusedSelected
      Case lnState = (lnNotFocused + lnNotSelected)
         lcImage = .ImgNotFocusedNotSelected
      Otherwise
         lcImage = ""
   Endcase
Endwith
This.Picture = lcImage
ENDPROC
PROCEDURE changeselectedbutton
This.Parent.Parent.SelectedButton = This.TabIndex
ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
2[END RESERVED2]
[START RESERVED3]
*changeselectedbutton Change selected button.
*changebackground Change button's background image.
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1UJ0JLXYP
[CLASS] image
[BASECLASS] image
[OBJNAME] imgPicture
[PARENT] overflowpanelbutton
[START PROPERTIES]
BackStyle = 0
Height = 16
Left = 4
MousePointer = 15
Top = 8
Width = 16
Name = "imgPicture"
[END PROPERTIES]
[START METHODS]
PROCEDURE Click
This.Parent.ChangeSelectedButton()
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] overflowpanelbutton

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1VI0PGW5E
[CLASS] page
[BASECLASS] page
[OBJNAME] pane
[START PROPERTIES]
Caption = "Page1"
Height = 196
Width = 196
picture16 = ("")
picture24 = ("")
Name = "pane"
[END PROPERTIES]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
picture16 16x16 image displayed in the panel buttons.
picture24 24x24 image displayed in the panel buttons.
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] pane
[EOF]
